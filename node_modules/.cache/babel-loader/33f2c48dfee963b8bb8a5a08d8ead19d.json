{"ast":null,"code":"import { RenderTexture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { Matrix, Point, Rectangle } from '@pixi/math';\nimport { NitroContainer, NitroSprite } from '../../core';\nimport { Nitro } from '../../nitro/Nitro';\nimport { MouseEventType } from '../../nitro/ui/MouseEventType';\nimport { RoomSpriteMouseEvent } from '../events/RoomSpriteMouseEvent';\nimport { RoomObjectSpriteType } from '../object/enum/RoomObjectSpriteType';\nimport { RoomRotatingEffect, RoomShakingEffect } from '../utils';\nimport { RoomEnterEffect } from '../utils/RoomEnterEffect';\nimport { RoomGeometry } from '../utils/RoomGeometry';\nimport { Vector3d } from '../utils/Vector3d';\nimport { RoomObjectCache } from './cache/RoomObjectCache';\nimport { ExtendedSprite } from './utils/ExtendedSprite';\nimport { ObjectMouseData } from './utils/ObjectMouseData';\nimport { SortableSprite } from './utils/SortableSprite';\nexport class RoomSpriteCanvas {\n  constructor(container, id, width, height, scale) {\n    this._id = void 0;\n    this._container = void 0;\n    this._geometry = void 0;\n    this._animationFPS = void 0;\n    this._renderTimestamp = void 0;\n    this._totalTimeRunning = void 0;\n    this._lastFrame = void 0;\n    this._master = void 0;\n    this._display = void 0;\n    this._mask = void 0;\n    this._sortableSprites = void 0;\n    this._spriteCount = void 0;\n    this._activeSpriteCount = void 0;\n    this._spritePool = void 0;\n    this._skipObjectUpdate = void 0;\n    this._runningSlow = void 0;\n    this._width = void 0;\n    this._height = void 0;\n    this._renderedWidth = void 0;\n    this._renderedHeight = void 0;\n    this._screenOffsetX = void 0;\n    this._screenOffsetY = void 0;\n    this._mouseLocation = void 0;\n    this._mouseOldX = void 0;\n    this._mouseOldY = void 0;\n    this._mouseCheckCount = void 0;\n    this._mouseSpriteWasHit = void 0;\n    this._mouseActiveObjects = void 0;\n    this._eventCache = void 0;\n    this._eventId = void 0;\n    this._scale = void 0;\n    this._SafeStr_4507 = false;\n    this._rotation = 0;\n    this._rotationOrigin = null;\n    this._rotationRodLength = 0;\n    this._effectDirection = void 0;\n    this._effectLocation = void 0;\n    this._SafeStr_795 = 0;\n    this._restrictsScaling = void 0;\n    this._noSpriteVisibilityChecking = void 0;\n    this._usesExclusionRectangles = void 0;\n    this._usesMask = void 0;\n    this._canvasUpdated = void 0;\n    this._objectCache = void 0;\n    this._mouseListener = void 0;\n    this._id = id;\n    this._container = container;\n    this._geometry = new RoomGeometry(scale, new Vector3d(-135, 30, 0), new Vector3d(11, 11, 5), new Vector3d(-135, 0.5, 0));\n    this._animationFPS = Nitro.instance.getConfiguration('system.animation.fps', 24);\n    this._renderTimestamp = 0;\n    this._totalTimeRunning = 0;\n    this._lastFrame = 0;\n    this._master = null;\n    this._display = null;\n    this._mask = null;\n    this._sortableSprites = [];\n    this._spriteCount = 0;\n    this._activeSpriteCount = 0;\n    this._spritePool = [];\n    this._skipObjectUpdate = false;\n    this._runningSlow = false;\n    this._width = 0;\n    this._height = 0;\n    this._renderedWidth = 0;\n    this._renderedHeight = 0;\n    this._screenOffsetX = 0;\n    this._screenOffsetY = 0;\n    this._mouseLocation = new Point();\n    this._mouseOldX = 0;\n    this._mouseOldY = 0;\n    this._mouseCheckCount = 0;\n    this._mouseSpriteWasHit = false;\n    this._mouseActiveObjects = new Map();\n    this._eventCache = new Map();\n    this._eventId = 0;\n    this._scale = 1;\n    this._restrictsScaling = false;\n    this._noSpriteVisibilityChecking = false;\n    this._usesExclusionRectangles = false;\n    this._usesMask = true;\n    this._canvasUpdated = false;\n    this._objectCache = new RoomObjectCache(this._container.roomObjectVariableAccurateZ);\n    this._mouseListener = null;\n    this.setupCanvas();\n    this.initialize(width, height);\n  }\n\n  setupCanvas() {\n    if (!this._master) {\n      this._master = new NitroSprite();\n      this._master.interactiveChildren = false;\n    }\n\n    if (!this._display) {\n      const display = new NitroContainer();\n\n      this._master.addChild(display);\n\n      this._display = display;\n    }\n  }\n\n  dispose() {\n    this.cleanSprites(0, true);\n\n    if (this._geometry) {\n      this._geometry.dispose();\n\n      this._geometry = null;\n    }\n\n    if (this._mask) this._mask = null;\n\n    if (this._objectCache) {\n      this._objectCache.dispose();\n\n      this._objectCache = null;\n    }\n\n    if (this._master) {\n      while (this._master.children.length) {\n        const child = this._master.removeChildAt(0);\n\n        child.destroy();\n      }\n\n      if (this._master.parent) this._master.parent.removeChild(this._master);\n\n      this._master.destroy();\n\n      this._master = null;\n    }\n\n    this._display = null;\n    this._sortableSprites = [];\n\n    if (this._mouseActiveObjects) {\n      this._mouseActiveObjects.clear();\n\n      this._mouseActiveObjects = null;\n    }\n\n    if (this._spritePool) {\n      for (const sprite of this._spritePool) {\n        this.cleanSprite(sprite, true);\n      }\n\n      this._spritePool = [];\n    }\n\n    if (this._eventCache) {\n      this._eventCache.clear();\n\n      this._eventCache = null;\n    }\n\n    this._mouseListener = null;\n  }\n\n  initialize(width, height) {\n    width = width < 1 ? 1 : width;\n    height = height < 1 ? 1 : height;\n\n    if (this._usesMask) {\n      if (!this._mask) {\n        this._mask = new Graphics().beginFill(0xFF0000).drawRect(0, 0, width, height).endFill();\n\n        if (this._master) {\n          this._master.addChild(this._mask);\n\n          if (this._display) this._display.mask = this._mask;\n        }\n      } else {\n        this._mask.clear().beginFill(0xFF0000).drawRect(0, 0, width, height).endFill();\n      }\n    }\n\n    if (this._master) {\n      if (this._master.hitArea) {\n        const hitArea = this._master.hitArea;\n        hitArea.width = width;\n        hitArea.height = height;\n      } else {\n        this._master.hitArea = new Rectangle(0, 0, width, height);\n      }\n\n      if (this._master.filterArea) {\n        const filterArea = this._master.filterArea;\n        filterArea.width = width;\n        filterArea.height = height;\n      } else {\n        this._master.filterArea = new Rectangle(0, 0, width, height);\n      }\n    }\n\n    this._width = width;\n    this._height = height;\n  }\n\n  setMask(flag) {\n    if (flag && !this._usesMask) {\n      this._usesMask = true;\n\n      if (this._mask && this._mask.parent !== this._master) {\n        this._master.addChild(this._mask);\n\n        this._display.mask = this._mask;\n      }\n    } else if (!flag && this._usesMask) {\n      this._usesMask = false;\n\n      if (this._mask && this._mask.parent === this._master) {\n        this._master.removeChild(this._mask);\n\n        this._display.mask = null;\n      }\n    }\n  }\n\n  setScale(scale) {\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let offsetPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let override = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let asDelta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!this._master || !this._display) return;\n    if (this._restrictsScaling && !override) return;\n    if (!point) point = new Point(this._width / 2, this._height / 2);\n    if (!offsetPoint) offsetPoint = point;\n    point = this._display.toLocal(point);\n\n    if (asDelta) {\n      this._scale *= scale;\n    } else {\n      this._scale = scale;\n    }\n\n    this.screenOffsetX = offsetPoint.x - point.x * this._scale;\n    this.screenOffsetY = offsetPoint.y - point.y * this._scale;\n  }\n\n  render(time) {\n    let update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._canvasUpdated = false;\n    this._totalTimeRunning += Nitro.instance.ticker.deltaTime;\n    if (this._totalTimeRunning === this._renderTimestamp) return;\n    if (time === -1) time = this._renderTimestamp + 1;\n    if (!this._container || !this._geometry) return;\n    if (this._width !== this._renderedWidth || this._height !== this._renderedHeight) update = true;\n\n    if (this._display.x !== this._screenOffsetX || this._display.y !== this._screenOffsetY) {\n      this._display.x = this._screenOffsetX;\n      this._display.y = this._screenOffsetY;\n      update = true;\n    }\n\n    if (this._display.scale.x !== this._scale) {\n      this._display.scale.set(this._scale);\n\n      update = true;\n    }\n\n    this.doMagic();\n    const frame = Math.round(this._totalTimeRunning / (60 / this._animationFPS));\n    let updateVisuals = false;\n\n    if (frame !== this._lastFrame) {\n      this._lastFrame = frame;\n      updateVisuals = true;\n    }\n\n    let spriteCount = 0;\n    const objects = this._container.objects;\n\n    if (objects.size) {\n      for (const object of objects.values()) {\n        if (!object) continue;\n        spriteCount = spriteCount + this.renderObject(object, object.instanceId.toString(), time, update, updateVisuals, spriteCount);\n      }\n    }\n\n    this._sortableSprites.sort((a, b) => {\n      return b.z - a.z;\n    });\n\n    if (spriteCount < this._sortableSprites.length) {\n      this._sortableSprites.splice(spriteCount);\n    }\n\n    let iterator = 0;\n\n    while (iterator < spriteCount) {\n      const sprite = this._sortableSprites[iterator];\n      if (sprite && sprite.sprite) this.renderSprite(iterator, sprite);\n      iterator++;\n    }\n\n    this.cleanSprites(spriteCount);\n    if (update || updateVisuals) this._canvasUpdated = true;\n    this._renderTimestamp = this._totalTimeRunning;\n    this._renderedWidth = this._width;\n    this._renderedHeight = this._height;\n  }\n\n  skipSpriteVisibilityChecking() {\n    this._noSpriteVisibilityChecking = true;\n    this.render(-1, true);\n  }\n\n  resumeSpriteVisibilityChecking() {\n    this._noSpriteVisibilityChecking = false;\n  }\n\n  getSortableSpriteList() {\n    return this._objectCache.getSortableSpriteList();\n  }\n\n  getPlaneSortableSprites() {\n    return this._objectCache.getPlaneSortableSprites();\n  }\n\n  removeFromCache(identifier) {\n    this._objectCache.removeObjectCache(identifier);\n  }\n\n  renderObject(object, identifier, time, update, updateVisuals, count) {\n    if (!object) return 0;\n    const visualization = object.visualization;\n\n    if (!visualization) {\n      this.removeFromCache(identifier);\n      return 0;\n    }\n\n    const cache = this.getCacheItem(identifier);\n    cache.objectId = object.instanceId;\n    const locationCache = cache.location;\n    const sortableCache = cache.sprites;\n    const vector = locationCache.updateLocation(object, this._geometry);\n\n    if (!vector) {\n      this.removeFromCache(identifier);\n      return 0;\n    }\n\n    if (updateVisuals) visualization.update(this._geometry, time, !sortableCache.isEmpty || update, this._skipObjectUpdate && this._runningSlow);\n    if (locationCache.locationChanged) update = true;\n\n    if (!sortableCache.needsUpdate(visualization.instanceId, visualization.updateSpriteCounter) && !update) {\n      return sortableCache.spriteCount;\n    }\n\n    let x = vector.x;\n    let y = vector.y;\n    let z = vector.z;\n    if (x > 0) z = z + x * 1.2E-7;else z = z + -x * 1.2E-7;\n    x = x + Math.trunc(this._width / 2);\n    y = y + Math.trunc(this._height / 2);\n    let spriteCount = 0;\n\n    for (const sprite of visualization.sprites.values()) {\n      if (!sprite || !sprite.visible) continue;\n      const texture = sprite.texture;\n      const baseTexture = texture && texture.baseTexture;\n      if (!texture || !baseTexture) continue;\n      const spriteX = x + sprite.offsetX + this._screenOffsetX;\n      const spriteY = y + sprite.offsetY + this._screenOffsetY;\n\n      if (sprite.flipH) {\n        const checkX = x + -(texture.width + -sprite.offsetX) + this._screenOffsetX;\n        if (!this.isSpriteVisible(checkX, spriteY, texture.width, texture.height)) continue;\n      } else if (sprite.flipV) {\n        const checkY = y + -(texture.height + -sprite.offsetY) + this._screenOffsetY;\n        if (!this.isSpriteVisible(spriteX, checkY, texture.width, texture.height)) continue;\n      } else {\n        if (!this.isSpriteVisible(spriteX, spriteY, texture.width, texture.height)) continue;\n      }\n\n      let sortableSprite = sortableCache.getSprite(spriteCount);\n\n      if (!sortableSprite) {\n        sortableSprite = new SortableSprite();\n        sortableCache.addSprite(sortableSprite);\n\n        this._sortableSprites.push(sortableSprite);\n\n        sortableSprite.name = identifier;\n      }\n\n      sortableSprite.sprite = sprite;\n\n      if (sprite.spriteType === RoomObjectSpriteType.AVATAR || sprite.spriteType === RoomObjectSpriteType.AVATAR_OWN) {\n        sortableSprite.sprite.libraryAssetName = 'avatar_' + object.id;\n      }\n\n      sortableSprite.x = spriteX - this._screenOffsetX;\n      sortableSprite.y = spriteY - this._screenOffsetY;\n      sortableSprite.z = z + sprite.relativeDepth + 3.7E-11 * count;\n      spriteCount++;\n      count++;\n    }\n\n    sortableCache.setSpriteCount(spriteCount);\n    this._canvasUpdated = true;\n    return spriteCount;\n  }\n\n  getExtendedSprite(index) {\n    if (index < 0 || index >= this._spriteCount) return null;\n\n    const sprite = this._display.getChildAt(index);\n\n    if (!sprite) return null;\n    return sprite;\n  }\n\n  getExtendedSpriteIdentifier(sprite) {\n    if (!sprite) return '';\n    return sprite.name;\n  }\n\n  renderSprite(index, sprite) {\n    if (index >= this._spriteCount) {\n      this.createAndAddSprite(sprite);\n      return true;\n    }\n\n    if (!sprite) return false;\n    const objectSprite = sprite.sprite;\n    const extendedSprite = this.getExtendedSprite(index);\n    if (!objectSprite || !extendedSprite) return false;\n\n    if (extendedSprite.varyingDepth !== objectSprite.varyingDepth) {\n      if (extendedSprite.varyingDepth && !objectSprite.varyingDepth) {\n        this._display.removeChildAt(index);\n\n        this._spritePool.push(extendedSprite);\n\n        return this.renderSprite(index, sprite);\n      }\n\n      this.createAndAddSprite(sprite, index);\n      return true;\n    }\n\n    if (extendedSprite.needsUpdate(objectSprite.id, objectSprite.updateCounter) || RoomEnterEffect.isVisualizationOn()) {\n      extendedSprite.tag = objectSprite.tag;\n      extendedSprite.alphaTolerance = objectSprite.alphaTolerance;\n      extendedSprite.name = sprite.name;\n      extendedSprite.varyingDepth = objectSprite.varyingDepth;\n      extendedSprite.clickHandling = objectSprite.clickHandling;\n      extendedSprite.filters = objectSprite.filters;\n      const alpha = objectSprite.alpha / 255;\n      if (extendedSprite.alpha !== alpha) extendedSprite.alpha = alpha;\n      if (extendedSprite.tint !== objectSprite.color) extendedSprite.tint = objectSprite.color;\n      if (extendedSprite.blendMode !== objectSprite.blendMode) extendedSprite.blendMode = objectSprite.blendMode;\n      if (extendedSprite.texture !== objectSprite.texture) extendedSprite.setTexture(objectSprite.texture);\n\n      if (objectSprite.updateContainer) {\n        const length = extendedSprite.children.length;\n        if (length === 1) extendedSprite.removeChildAt(0);\n        extendedSprite.addChild(objectSprite.container);\n        objectSprite.updateContainer = false;\n      }\n\n      if (objectSprite.flipH) {\n        if (extendedSprite.scale.x !== -1) extendedSprite.scale.x = -1;\n      } else {\n        if (extendedSprite.scale.x !== 1) extendedSprite.scale.x = 1;\n      }\n\n      if (objectSprite.flipV) {\n        if (extendedSprite.scale.y !== -1) extendedSprite.scale.y = -1;\n      } else {\n        if (extendedSprite.scale.y !== 1) extendedSprite.scale.y = 1;\n      }\n\n      this.updateEnterRoomEffect(extendedSprite, objectSprite);\n    }\n\n    if (extendedSprite.x !== sprite.x) extendedSprite.x = sprite.x;\n    if (extendedSprite.y !== sprite.y) extendedSprite.y = sprite.y;\n    extendedSprite.offsetX = objectSprite.offsetX;\n    extendedSprite.offsetY = objectSprite.offsetY;\n    return true;\n  }\n\n  createAndAddSprite(sortableSprite) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    const sprite = sortableSprite.sprite;\n    if (!sprite) return;\n    let extendedSprite = null;\n    if (this._spritePool.length > 0) extendedSprite = this._spritePool.pop();\n    if (!extendedSprite) extendedSprite = new ExtendedSprite();\n    if (extendedSprite.children.length) extendedSprite.removeChildren();\n    extendedSprite.tag = sprite.tag;\n    extendedSprite.alphaTolerance = sprite.alphaTolerance;\n    extendedSprite.alpha = sprite.alpha / 255;\n    extendedSprite.tint = sprite.color;\n    extendedSprite.x = sortableSprite.x;\n    extendedSprite.y = sortableSprite.y;\n    extendedSprite.offsetX = sprite.offsetX;\n    extendedSprite.offsetY = sprite.offsetY;\n    extendedSprite.name = sprite.name;\n    extendedSprite.varyingDepth = sprite.varyingDepth;\n    extendedSprite.clickHandling = sprite.clickHandling;\n    extendedSprite.blendMode = sprite.blendMode;\n    extendedSprite.filters = sprite.filters;\n    extendedSprite.setTexture(sprite.texture);\n\n    if (sprite.updateContainer) {\n      extendedSprite.addChild(sprite.container);\n      sprite.updateContainer = false;\n    }\n\n    if (sprite.flipH) extendedSprite.scale.x = -1;\n    if (sprite.flipV) extendedSprite.scale.y = -1;\n    this.updateEnterRoomEffect(extendedSprite, sprite);\n\n    if (index < 0 || index >= this._spriteCount) {\n      this._display.addChild(extendedSprite);\n\n      this._spriteCount++;\n    } else {\n      this._display.addChildAt(extendedSprite, index);\n    }\n\n    this._activeSpriteCount++;\n  }\n\n  cleanSprites(spriteCount) {\n    let _arg_2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!this._display) return;\n    if (spriteCount < 0) spriteCount = 0;\n\n    if (spriteCount < this._activeSpriteCount || !this._activeSpriteCount) {\n      let iterator = this._spriteCount - 1;\n\n      while (iterator >= spriteCount) {\n        this.cleanSprite(this.getExtendedSprite(iterator), _arg_2);\n        iterator--;\n      }\n    }\n\n    this._activeSpriteCount = spriteCount;\n  }\n\n  updateEnterRoomEffect(sprite, _arg_2) {\n    if (!RoomEnterEffect.isVisualizationOn() || !_arg_2) return;\n\n    switch (_arg_2.spriteType) {\n      case RoomObjectSpriteType.AVATAR_OWN:\n        return;\n\n      case RoomObjectSpriteType.ROOM_PLANE:\n        sprite.alpha = RoomEnterEffect.getDelta(0.9);\n        return;\n\n      case RoomObjectSpriteType.AVATAR:\n        sprite.alpha = RoomEnterEffect.getDelta(0.5);\n        return;\n\n      default:\n        sprite.alpha = RoomEnterEffect.getDelta(0.1);\n    }\n  }\n\n  cleanSprite(sprite, _arg_2) {\n    if (!sprite) return;\n\n    if (!_arg_2) {\n      sprite.setTexture(null);\n    } else {\n      if (sprite.parent) sprite.parent.removeChild(sprite);\n      sprite.destroy({\n        children: true\n      });\n    }\n  }\n\n  update() {\n    if (!this._mouseCheckCount) {//this.checkMouseHits(this._mouseLocation.x, this._mouseLocation.y, MouseEventType.MOUSE_MOVE);\n    }\n\n    this._mouseCheckCount = 0;\n    this._eventId++;\n  }\n\n  setMouseListener(listener) {\n    this._mouseListener = listener;\n  }\n\n  getCacheItem(id) {\n    return this._objectCache.getObjectCache(id);\n  }\n\n  isSpriteVisible(x, y, width, height) {\n    if (this._noSpriteVisibilityChecking) return true;\n    x = (x - this._screenOffsetX) * this._scale + this._screenOffsetX;\n    y = (y - this._screenOffsetY) * this._scale + this._screenOffsetY;\n    width = width * this._scale;\n    height = height * this._scale;\n\n    if (x < this._width && x + width >= 0 && y < this._height && y + height >= 0) {\n      if (!this._usesExclusionRectangles) return true;\n    }\n\n    return false;\n  }\n\n  handleMouseEvent(x, y, type, altKey, ctrlKey, shiftKey, buttonDown) {\n    x = x - this._screenOffsetX;\n    y = y - this._screenOffsetY;\n    this._mouseLocation.x = x / this._scale;\n    this._mouseLocation.y = y / this._scale;\n    if (this._mouseCheckCount > 0 && type == MouseEventType.MOUSE_MOVE) return this._mouseSpriteWasHit;\n    this._mouseSpriteWasHit = this.checkMouseHits(Math.trunc(x / this._scale), Math.trunc(y / this._scale), type, altKey, ctrlKey, shiftKey, buttonDown);\n    this._mouseCheckCount++;\n    return this._mouseSpriteWasHit;\n  }\n\n  checkMouseHits(x, y, type) {\n    let altKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let ctrlKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let shiftKey = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let buttonDown = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const checkedSprites = [];\n    let didHitSprite = false;\n    let mouseEvent = null;\n    let spriteId = this._activeSpriteCount - 1;\n\n    while (spriteId >= 0) {\n      const extendedSprite = this.getExtendedSprite(spriteId);\n\n      if (extendedSprite && extendedSprite.containsPoint(new Point(x - extendedSprite.x, y - extendedSprite.y))) {\n        if (extendedSprite.clickHandling && (type === MouseEventType.MOUSE_CLICK || type === MouseEventType.DOUBLE_CLICK)) {//\n        } else {\n          const identifier = this.getExtendedSpriteIdentifier(extendedSprite);\n\n          if (checkedSprites.indexOf(identifier) === -1) {\n            const tag = extendedSprite.tag;\n\n            let mouseData = this._mouseActiveObjects.get(identifier);\n\n            if (mouseData) {\n              if (mouseData.spriteTag !== tag) {\n                mouseEvent = this.createMouseEvent(0, 0, 0, 0, MouseEventType.ROLL_OUT, mouseData.spriteTag, altKey, ctrlKey, shiftKey, buttonDown);\n                this.bufferMouseEvent(mouseEvent, identifier);\n              }\n            }\n\n            if (type === MouseEventType.MOUSE_MOVE && (!mouseData || mouseData.spriteTag !== tag)) {\n              mouseEvent = this.createMouseEvent(x, y, x - extendedSprite.x, y - extendedSprite.y, MouseEventType.ROLL_OVER, tag, altKey, ctrlKey, shiftKey, buttonDown);\n            } else {\n              mouseEvent = this.createMouseEvent(x, y, x - extendedSprite.x, y - extendedSprite.y, type, tag, altKey, ctrlKey, shiftKey, buttonDown);\n              mouseEvent.spriteOffsetX = extendedSprite.offsetX;\n              mouseEvent.spriteOffsetY = extendedSprite.offsetY;\n            }\n\n            if (!mouseData) {\n              mouseData = new ObjectMouseData();\n              mouseData.objectId = identifier;\n\n              this._mouseActiveObjects.set(identifier, mouseData);\n            }\n\n            mouseData.spriteTag = tag;\n\n            if (type !== MouseEventType.MOUSE_MOVE || x !== this._mouseOldX || y !== this._mouseOldY) {\n              this.bufferMouseEvent(mouseEvent, identifier);\n            }\n\n            checkedSprites.push(identifier);\n          }\n\n          didHitSprite = true;\n        }\n      }\n\n      spriteId--;\n    }\n\n    const keys = [];\n\n    for (const key of this._mouseActiveObjects.keys()) key && keys.push(key);\n\n    let index = 0;\n\n    while (index < keys.length) {\n      const key = keys[index];\n      if (checkedSprites.indexOf(key) >= 0) keys[index] = null;\n      index++;\n    }\n\n    index = 0;\n\n    while (index < keys.length) {\n      const key = keys[index];\n\n      if (key !== null) {\n        const existing = this._mouseActiveObjects.get(key);\n\n        if (existing) this._mouseActiveObjects.delete(key);\n        const mouseEvent = this.createMouseEvent(0, 0, 0, 0, MouseEventType.ROLL_OUT, existing.spriteTag, altKey, ctrlKey, shiftKey, buttonDown);\n        this.bufferMouseEvent(mouseEvent, key);\n      }\n\n      index++;\n    }\n\n    this.processMouseEvents();\n    this._mouseOldX = x;\n    this._mouseOldY = y;\n    return didHitSprite;\n  }\n\n  createMouseEvent(x, y, localX, localY, type, tag, altKey, ctrlKey, shiftKey, buttonDown) {\n    const screenX = x - this._width / 2;\n    const screenY = y - this._height / 2;\n    const canvasName = `canvas_${this._id}`;\n    return new RoomSpriteMouseEvent(type, canvasName + '_' + this._eventId, canvasName, tag, screenX, screenY, localX, localY, ctrlKey, altKey, shiftKey, buttonDown);\n  }\n\n  bufferMouseEvent(k, _arg_2) {\n    if (!k || !this._eventCache) return;\n\n    this._eventCache.delete(_arg_2);\n\n    this._eventCache.set(_arg_2, k);\n  }\n\n  processMouseEvents() {\n    if (!this._container || !this._eventCache) return;\n\n    for (const [key, event] of this._eventCache.entries()) {\n      if (!this._eventCache) return;\n      if (!event) continue;\n\n      const roomObject = this._container.getRoomObject(parseInt(key));\n\n      if (!roomObject) continue;\n\n      if (this._mouseListener) {\n        this._mouseListener.processRoomCanvasMouseEvent(event, roomObject, this._geometry);\n      } else {\n        const logic = roomObject.mouseHandler;\n\n        if (logic) {\n          logic.mouseEvent(event, this._geometry);\n        }\n      }\n    }\n\n    if (this._eventCache) this._eventCache.clear();\n  }\n\n  getDisplayAsTexture() {\n    this._noSpriteVisibilityChecking = true;\n    const k = this._scale;\n    const _local_2 = this._screenOffsetX;\n    const _local_3 = this._screenOffsetY;\n    this.setScale(1, null, null, true);\n    this._screenOffsetX = 0;\n    this._screenOffsetY = 0;\n    this.render(-1, true);\n    this._display.mask = null;\n\n    const bounds = this._display.getBounds();\n\n    const renderTexture = RenderTexture.create({\n      width: this._display.width,\n      height: this._display.height\n    });\n    Nitro.instance.renderer.render(this._display, {\n      renderTexture,\n      clear: true,\n      transform: new Matrix(1, 0, 0, 1, -bounds.x, -bounds.y)\n    });\n    this._display.mask = this._mask;\n    this._noSpriteVisibilityChecking = false;\n    this.setScale(k, null, null, true);\n    this._screenOffsetX = _local_2;\n    this._screenOffsetY = _local_3;\n    return renderTexture;\n  }\n\n  doMagic() {\n    const geometry = this.geometry;\n\n    if (this._rotation !== 0) {\n      let direction = this._effectDirection;\n      geometry.direction = new Vector3d(direction.x + this._rotation, direction.y, direction.z);\n      direction = geometry.direction;\n      geometry.setDepthVector(new Vector3d(direction.x, direction.y, 5));\n      const location = new Vector3d();\n      location.assign(this._rotationOrigin);\n      location.x = location.x + this._rotationRodLength * Math.cos((direction.x + 180) / 180 * 3.14159265358979) * Math.cos(direction.y / 180 * 3.14159265358979);\n      location.y = location.y + this._rotationRodLength * Math.sin((direction.x + 180) / 180 * 3.14159265358979) * Math.cos(direction.y / 180 * 3.14159265358979);\n      location.z = location.z + this._rotationRodLength * Math.sin(direction.y / 180 * 3.14159265358979);\n      geometry.location = location;\n      this._effectLocation = new Vector3d();\n\n      this._effectLocation.assign(location);\n\n      this._effectDirection = new Vector3d();\n\n      this._effectDirection.assign(geometry.direction);\n    }\n\n    if (RoomShakingEffect.isVisualizationOn() && !this._SafeStr_4507) {\n      this.changeShaking();\n    } else {\n      if (!RoomShakingEffect.isVisualizationOn() && this._SafeStr_4507) this.changeShaking();\n    }\n\n    if (RoomRotatingEffect.isVisualizationOn()) this.changeRotation();\n\n    if (this._SafeStr_4507) {\n      this._SafeStr_795++;\n      const _local_4 = this._effectDirection;\n\n      const _local_1 = Vector3d.sum(_local_4, new Vector3d(Math.sin(this._SafeStr_795 * 5 / 180 * 3.14159265358979) * 2, Math.sin(this._SafeStr_795 / 180 * 3.14159265358979) * 5, Math.sin(this._SafeStr_795 * 10 / 180 * 3.14159265358979) * 2));\n\n      geometry.direction = _local_1;\n    } else {\n      this._SafeStr_795 = 0;\n      geometry.direction = this._effectDirection;\n    }\n  }\n\n  changeShaking() {\n    this._SafeStr_4507 = !this._SafeStr_4507;\n\n    if (this._SafeStr_4507) {\n      const direction = this.geometry.direction;\n      this._effectDirection = new Vector3d(direction.x, direction.y, direction.z);\n    }\n  }\n\n  changeRotation() {\n    if (this._SafeStr_4507) return;\n    const geometry = this.geometry;\n    if (!geometry) return;\n\n    if (this._rotation === 0) {\n      const location = geometry.location;\n      const directionAxis = geometry.directionAxis;\n      this._effectLocation = new Vector3d();\n\n      this._effectLocation.assign(location);\n\n      this._effectDirection = new Vector3d();\n\n      this._effectDirection.assign(geometry.direction);\n\n      const intersection = RoomGeometry.getIntersectionVector(location, directionAxis, new Vector3d(0, 0, 0), new Vector3d(0, 0, 1));\n\n      if (intersection !== null) {\n        this._rotationOrigin = new Vector3d(intersection.x, intersection.y, intersection.z);\n        this._rotationRodLength = Vector3d.dif(intersection, location).length;\n        this._rotation = 1;\n      }\n\n      return;\n    }\n\n    this._rotation = 0;\n    geometry.location = this._effectLocation;\n    geometry.direction = this._effectDirection;\n    geometry.setDepthVector(new Vector3d(this._effectDirection.x, this._effectDirection.y, 5));\n  }\n\n  moveLeft() {\n    if (this._rotation !== 0) {\n      if (this._rotation === 1) {\n        this._rotation = -1;\n      } else {\n        this._rotation = this._rotation - 1;\n      }\n\n      return;\n    }\n\n    const geometry = this.geometry;\n    const direction = (geometry.direction.x - 90) / 180 * 3.14159265358979;\n    geometry.location = Vector3d.sum(geometry.location, new Vector3d(Math.cos(direction) * Math.sqrt(2), Math.sin(direction) * Math.sqrt(2)));\n  }\n\n  moveRight() {\n    if (this._rotation !== 0) {\n      if (this._rotation === -1) {\n        this._rotation = 1;\n      } else {\n        this._rotation = this._rotation + 1;\n      }\n\n      return;\n    }\n\n    const geometry = this.geometry;\n    const direction = (geometry.direction.x + 90) / 180 * 3.14159265358979;\n    geometry.location = Vector3d.sum(geometry.location, new Vector3d(Math.cos(direction) * Math.sqrt(2), Math.sin(direction) * Math.sqrt(2)));\n  }\n\n  moveUp() {\n    if (this._rotation !== 0) return;\n    const geometry = this.geometry;\n    const direction = geometry.direction.x / 180 * 3.14159265358979;\n    geometry.location = Vector3d.sum(geometry.location, new Vector3d(Math.cos(direction) * Math.sqrt(2), Math.sin(direction) * Math.sqrt(2)));\n  }\n\n  moveDown() {\n    if (this._rotation !== 0) return;\n    const geometry = this.geometry;\n    const direction = (geometry.direction.x + 180) / 180 * 3.14159265358979;\n    geometry.location = Vector3d.sum(geometry.location, new Vector3d(Math.cos(direction) * Math.sqrt(2), Math.sin(direction) * Math.sqrt(2)));\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get geometry() {\n    return this._geometry;\n  }\n\n  get master() {\n    return this._master;\n  }\n\n  get display() {\n    return this._display;\n  }\n\n  get screenOffsetX() {\n    return this._screenOffsetX;\n  }\n\n  set screenOffsetX(x) {\n    x = Math.trunc(x);\n    this._mouseLocation.x = this._mouseLocation.x - (x - this._screenOffsetX);\n    this._screenOffsetX = x;\n  }\n\n  get screenOffsetY() {\n    return this._screenOffsetY;\n  }\n\n  set screenOffsetY(y) {\n    y = Math.trunc(y);\n    this._mouseLocation.y = this._mouseLocation.y - (y - this._screenOffsetY);\n    this._screenOffsetY = y;\n  }\n\n  get scale() {\n    return this._scale;\n  }\n\n  get width() {\n    return this._width * this._scale;\n  }\n\n  get height() {\n    return this._height * this._scale;\n  }\n\n  get restrictsScaling() {\n    return this._restrictsScaling;\n  }\n\n  set restrictsScaling(flag) {\n    this._restrictsScaling = flag;\n  }\n\n  get canvasUpdated() {\n    return this._canvasUpdated;\n  }\n\n  set canvasUpdated(flag) {\n    this._canvasUpdated = flag;\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/room/renderer/RoomSpriteCanvas.ts"],"names":["RenderTexture","Graphics","Matrix","Point","Rectangle","NitroContainer","NitroSprite","Nitro","MouseEventType","RoomSpriteMouseEvent","RoomObjectSpriteType","RoomRotatingEffect","RoomShakingEffect","RoomEnterEffect","RoomGeometry","Vector3d","RoomObjectCache","ExtendedSprite","ObjectMouseData","SortableSprite","RoomSpriteCanvas","constructor","container","id","width","height","scale","_id","_container","_geometry","_animationFPS","_renderTimestamp","_totalTimeRunning","_lastFrame","_master","_display","_mask","_sortableSprites","_spriteCount","_activeSpriteCount","_spritePool","_skipObjectUpdate","_runningSlow","_width","_height","_renderedWidth","_renderedHeight","_screenOffsetX","_screenOffsetY","_mouseLocation","_mouseOldX","_mouseOldY","_mouseCheckCount","_mouseSpriteWasHit","_mouseActiveObjects","_eventCache","_eventId","_scale","_SafeStr_4507","_rotation","_rotationOrigin","_rotationRodLength","_effectDirection","_effectLocation","_SafeStr_795","_restrictsScaling","_noSpriteVisibilityChecking","_usesExclusionRectangles","_usesMask","_canvasUpdated","_objectCache","_mouseListener","instance","getConfiguration","Map","roomObjectVariableAccurateZ","setupCanvas","initialize","interactiveChildren","display","addChild","dispose","cleanSprites","children","length","child","removeChildAt","destroy","parent","removeChild","clear","sprite","cleanSprite","beginFill","drawRect","endFill","mask","hitArea","filterArea","setMask","flag","setScale","point","offsetPoint","override","asDelta","toLocal","screenOffsetX","x","screenOffsetY","y","render","time","update","ticker","deltaTime","set","doMagic","frame","Math","round","updateVisuals","spriteCount","objects","size","object","values","renderObject","instanceId","toString","sort","a","b","z","splice","iterator","renderSprite","skipSpriteVisibilityChecking","resumeSpriteVisibilityChecking","getSortableSpriteList","getPlaneSortableSprites","removeFromCache","identifier","removeObjectCache","count","visualization","cache","getCacheItem","objectId","locationCache","location","sortableCache","sprites","vector","updateLocation","isEmpty","locationChanged","needsUpdate","updateSpriteCounter","trunc","visible","texture","baseTexture","spriteX","offsetX","spriteY","offsetY","flipH","checkX","isSpriteVisible","flipV","checkY","sortableSprite","getSprite","addSprite","push","name","spriteType","AVATAR","AVATAR_OWN","libraryAssetName","relativeDepth","setSpriteCount","getExtendedSprite","index","getChildAt","getExtendedSpriteIdentifier","createAndAddSprite","objectSprite","extendedSprite","varyingDepth","updateCounter","isVisualizationOn","tag","alphaTolerance","clickHandling","filters","alpha","tint","color","blendMode","setTexture","updateContainer","updateEnterRoomEffect","pop","removeChildren","addChildAt","_arg_2","ROOM_PLANE","getDelta","setMouseListener","listener","getObjectCache","handleMouseEvent","type","altKey","ctrlKey","shiftKey","buttonDown","MOUSE_MOVE","checkMouseHits","checkedSprites","didHitSprite","mouseEvent","spriteId","containsPoint","MOUSE_CLICK","DOUBLE_CLICK","indexOf","mouseData","get","spriteTag","createMouseEvent","ROLL_OUT","bufferMouseEvent","ROLL_OVER","spriteOffsetX","spriteOffsetY","keys","key","existing","delete","processMouseEvents","localX","localY","screenX","screenY","canvasName","k","event","entries","roomObject","getRoomObject","parseInt","processRoomCanvasMouseEvent","logic","mouseHandler","getDisplayAsTexture","_local_2","_local_3","bounds","getBounds","renderTexture","create","renderer","transform","geometry","direction","setDepthVector","assign","cos","sin","changeShaking","changeRotation","_local_4","_local_1","sum","directionAxis","intersection","getIntersectionVector","dif","moveLeft","sqrt","moveRight","moveUp","moveDown","master","restrictsScaling","canvasUpdated"],"mappings":"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","sourcesContent":["import { RenderTexture } from '@pixi/core';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport { Matrix, Point, Rectangle } from '@pixi/math';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { NitroContainer, NitroSprite } from '../../core';\r\nimport { Nitro } from '../../nitro/Nitro';\r\nimport { MouseEventType } from '../../nitro/ui/MouseEventType';\r\nimport { RoomObjectSpriteData } from '../data/RoomObjectSpriteData';\r\nimport { RoomSpriteMouseEvent } from '../events/RoomSpriteMouseEvent';\r\nimport { RoomObjectSpriteType } from '../object/enum/RoomObjectSpriteType';\r\nimport { IRoomObject } from '../object/IRoomObject';\r\nimport { IRoomObjectSprite } from '../object/visualization/IRoomObjectSprite';\r\nimport { IRoomObjectSpriteVisualization } from '../object/visualization/IRoomObjectSpriteVisualization';\r\nimport { RoomRotatingEffect, RoomShakingEffect } from '../utils';\r\nimport { IRoomGeometry } from '../utils/IRoomGeometry';\r\nimport { RoomEnterEffect } from '../utils/RoomEnterEffect';\r\nimport { RoomGeometry } from '../utils/RoomGeometry';\r\nimport { Vector3d } from '../utils/Vector3d';\r\nimport { RoomObjectCache } from './cache/RoomObjectCache';\r\nimport { RoomObjectCacheItem } from './cache/RoomObjectCacheItem';\r\nimport { IRoomCanvasMouseListener } from './IRoomCanvasMouseListener';\r\nimport { IRoomRenderingCanvas } from './IRoomRenderingCanvas';\r\nimport { IRoomSpriteCanvasContainer } from './IRoomSpriteCanvasContainer';\r\nimport { ExtendedSprite } from './utils/ExtendedSprite';\r\nimport { ObjectMouseData } from './utils/ObjectMouseData';\r\nimport { SortableSprite } from './utils/SortableSprite';\r\n\r\nexport class RoomSpriteCanvas implements IRoomRenderingCanvas\r\n{\r\n    private _id: number;\r\n    private _container: IRoomSpriteCanvasContainer;\r\n\r\n    private _geometry: RoomGeometry;\r\n    private _animationFPS: number;\r\n    private _renderTimestamp: number;\r\n    private _totalTimeRunning: number;\r\n    private _lastFrame: number;\r\n\r\n    private _master: Sprite;\r\n    private _display: Container;\r\n    private _mask: Graphics;\r\n\r\n    private _sortableSprites: SortableSprite[];\r\n    private _spriteCount: number;\r\n    private _activeSpriteCount: number;\r\n    private _spritePool: ExtendedSprite[];\r\n    private _skipObjectUpdate: boolean;\r\n    private _runningSlow: boolean;\r\n\r\n    private _width: number;\r\n    private _height: number;\r\n    private _renderedWidth: number;\r\n    private _renderedHeight: number;\r\n    private _screenOffsetX: number;\r\n    private _screenOffsetY: number;\r\n    private _mouseLocation: Point;\r\n    private _mouseOldX: number;\r\n    private _mouseOldY: number;\r\n    private _mouseCheckCount: number;\r\n    private _mouseSpriteWasHit: boolean;\r\n    private _mouseActiveObjects: Map<string, ObjectMouseData>;\r\n    private _eventCache: Map<string, RoomSpriteMouseEvent>;\r\n    private _eventId: number;\r\n    private _scale: number;\r\n\r\n    private _SafeStr_4507: boolean = false;\r\n    private _rotation: number = 0;\r\n    private _rotationOrigin: Vector3d = null;\r\n    private _rotationRodLength: number = 0;\r\n    private _effectDirection: Vector3d;\r\n    private _effectLocation: Vector3d;\r\n    private _SafeStr_795: number = 0;\r\n\r\n    private _restrictsScaling: boolean;\r\n    private _noSpriteVisibilityChecking: boolean;\r\n    private _usesExclusionRectangles: boolean;\r\n    private _usesMask: boolean;\r\n    private _canvasUpdated: boolean;\r\n\r\n    private _objectCache: RoomObjectCache;\r\n\r\n    private _mouseListener: IRoomCanvasMouseListener;\r\n\r\n    constructor(container: IRoomSpriteCanvasContainer, id: number, width: number, height: number, scale: number)\r\n    {\r\n        this._id = id;\r\n        this._container = container;\r\n\r\n        this._geometry = new RoomGeometry(scale, new Vector3d(-135, 30, 0), new Vector3d(11, 11, 5), new Vector3d(-135, 0.5, 0));\r\n        this._animationFPS = Nitro.instance.getConfiguration<number>('system.animation.fps', 24);\r\n        this._renderTimestamp = 0;\r\n        this._totalTimeRunning = 0;\r\n        this._lastFrame = 0;\r\n\r\n        this._master = null;\r\n        this._display = null;\r\n        this._mask = null;\r\n\r\n        this._sortableSprites = [];\r\n        this._spriteCount = 0;\r\n        this._activeSpriteCount = 0;\r\n        this._spritePool = [];\r\n        this._skipObjectUpdate = false;\r\n        this._runningSlow = false;\r\n\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._renderedWidth = 0;\r\n        this._renderedHeight = 0;\r\n        this._screenOffsetX = 0;\r\n        this._screenOffsetY = 0;\r\n        this._mouseLocation = new Point;\r\n        this._mouseOldX = 0;\r\n        this._mouseOldY = 0;\r\n        this._mouseCheckCount = 0;\r\n        this._mouseSpriteWasHit = false;\r\n        this._mouseActiveObjects = new Map();\r\n        this._eventCache = new Map();\r\n        this._eventId = 0;\r\n        this._scale = 1;\r\n\r\n        this._restrictsScaling = false;\r\n        this._noSpriteVisibilityChecking = false;\r\n        this._usesExclusionRectangles = false;\r\n        this._usesMask = true;\r\n        this._canvasUpdated = false;\r\n\r\n        this._objectCache = new RoomObjectCache(this._container.roomObjectVariableAccurateZ);\r\n\r\n        this._mouseListener = null;\r\n\r\n        this.setupCanvas();\r\n        this.initialize(width, height);\r\n    }\r\n\r\n    private setupCanvas(): void\r\n    {\r\n        if(!this._master)\r\n        {\r\n            this._master = new NitroSprite();\r\n\r\n            this._master.interactiveChildren = false;\r\n        }\r\n\r\n        if(!this._display)\r\n        {\r\n            const display = new NitroContainer();\r\n\r\n            this._master.addChild(display);\r\n\r\n            this._display = display;\r\n        }\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        this.cleanSprites(0, true);\r\n\r\n        if(this._geometry)\r\n        {\r\n            this._geometry.dispose();\r\n\r\n            this._geometry = null;\r\n        }\r\n\r\n        if(this._mask) this._mask = null;\r\n\r\n        if(this._objectCache)\r\n        {\r\n            this._objectCache.dispose();\r\n\r\n            this._objectCache = null;\r\n        }\r\n\r\n        if(this._master)\r\n        {\r\n            while(this._master.children.length)\r\n            {\r\n                const child = this._master.removeChildAt(0);\r\n\r\n                child.destroy();\r\n            }\r\n\r\n            if(this._master.parent) this._master.parent.removeChild(this._master);\r\n\r\n            this._master.destroy();\r\n\r\n            this._master = null;\r\n        }\r\n\r\n        this._display = null;\r\n        this._sortableSprites = [];\r\n\r\n        if(this._mouseActiveObjects)\r\n        {\r\n            this._mouseActiveObjects.clear();\r\n\r\n            this._mouseActiveObjects = null;\r\n        }\r\n\r\n        if(this._spritePool)\r\n        {\r\n            for(const sprite of this._spritePool)\r\n            {\r\n                this.cleanSprite(sprite, true);\r\n            }\r\n\r\n            this._spritePool = [];\r\n        }\r\n\r\n        if(this._eventCache)\r\n        {\r\n            this._eventCache.clear();\r\n\r\n            this._eventCache = null;\r\n        }\r\n\r\n        this._mouseListener = null;\r\n    }\r\n\r\n    public initialize(width: number, height: number): void\r\n    {\r\n        width = width < 1 ? 1 : width;\r\n        height = height < 1 ? 1 : height;\r\n\r\n        if(this._usesMask)\r\n        {\r\n            if(!this._mask)\r\n            {\r\n                this._mask = new Graphics()\r\n                    .beginFill(0xFF0000)\r\n                    .drawRect(0, 0, width, height)\r\n                    .endFill();\r\n\r\n                if(this._master)\r\n                {\r\n                    this._master.addChild(this._mask);\r\n\r\n                    if(this._display) this._display.mask = this._mask;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this._mask\r\n                    .clear()\r\n                    .beginFill(0xFF0000)\r\n                    .drawRect(0, 0, width, height)\r\n                    .endFill();\r\n            }\r\n        }\r\n\r\n        if(this._master)\r\n        {\r\n            if(this._master.hitArea)\r\n            {\r\n                const hitArea = (this._master.hitArea as Rectangle);\r\n\r\n                hitArea.width = width;\r\n                hitArea.height = height;\r\n            }\r\n            else\r\n            {\r\n                this._master.hitArea = new Rectangle(0, 0, width, height);\r\n            }\r\n\r\n            if(this._master.filterArea)\r\n            {\r\n                const filterArea = this._master.filterArea;\r\n\r\n                filterArea.width = width;\r\n                filterArea.height = height;\r\n            }\r\n            else\r\n            {\r\n                this._master.filterArea = new Rectangle(0, 0, width, height);\r\n            }\r\n        }\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n\r\n    public setMask(flag: boolean): void\r\n    {\r\n        if(flag && !this._usesMask)\r\n        {\r\n            this._usesMask = true;\r\n\r\n            if(this._mask && (this._mask.parent !== this._master))\r\n            {\r\n                this._master.addChild(this._mask);\r\n\r\n                this._display.mask = this._mask;\r\n            }\r\n        }\r\n\r\n        else if(!flag && this._usesMask)\r\n        {\r\n            this._usesMask = false;\r\n\r\n            if(this._mask && (this._mask.parent === this._master))\r\n            {\r\n                this._master.removeChild(this._mask);\r\n\r\n                this._display.mask = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setScale(scale: number, point: Point = null, offsetPoint: Point = null, override: boolean = false, asDelta: boolean = false): void\r\n    {\r\n        if(!this._master || !this._display) return;\r\n\r\n        if(this._restrictsScaling && !override) return;\r\n\r\n        if(!point) point = new Point((this._width / 2), (this._height / 2));\r\n\r\n        if(!offsetPoint) offsetPoint = point;\r\n\r\n        point = this._display.toLocal(point);\r\n\r\n        if(asDelta)\r\n        {\r\n            this._scale *= scale;\r\n        }\r\n        else\r\n        {\r\n            this._scale = scale;\r\n        }\r\n\r\n        this.screenOffsetX = (offsetPoint.x - (point.x * this._scale));\r\n        this.screenOffsetY = (offsetPoint.y - (point.y * this._scale));\r\n    }\r\n\r\n    public render(time: number, update: boolean = false): void\r\n    {\r\n        this._canvasUpdated = false;\r\n\r\n        this._totalTimeRunning += Nitro.instance.ticker.deltaTime;\r\n\r\n        if(this._totalTimeRunning === this._renderTimestamp) return;\r\n\r\n        if(time === -1) time = (this._renderTimestamp + 1);\r\n\r\n        if(!this._container || !this._geometry) return;\r\n\r\n        if((this._width !== this._renderedWidth) || (this._height !== this._renderedHeight)) update = true;\r\n\r\n        if((this._display.x !== this._screenOffsetX) || (this._display.y !== this._screenOffsetY))\r\n        {\r\n            this._display.x = this._screenOffsetX;\r\n            this._display.y = this._screenOffsetY;\r\n\r\n            update = true;\r\n        }\r\n\r\n        if(this._display.scale.x !== this._scale)\r\n        {\r\n            this._display.scale.set(this._scale);\r\n\r\n            update = true;\r\n        }\r\n\r\n        this.doMagic();\r\n\r\n        const frame = Math.round(this._totalTimeRunning / (60 / this._animationFPS));\r\n\r\n        let updateVisuals = false;\r\n\r\n        if(frame !== this._lastFrame)\r\n        {\r\n            this._lastFrame = frame;\r\n\r\n            updateVisuals = true;\r\n        }\r\n\r\n        let spriteCount = 0;\r\n\r\n        const objects = this._container.objects;\r\n\r\n        if(objects.size)\r\n        {\r\n            for(const object of objects.values())\r\n            {\r\n                if(!object) continue;\r\n\r\n                spriteCount = (spriteCount + this.renderObject(object, object.instanceId.toString(), time, update, updateVisuals, spriteCount));\r\n            }\r\n        }\r\n\r\n        this._sortableSprites.sort((a, b) =>\r\n        {\r\n            return b.z - a.z;\r\n        });\r\n\r\n        if(spriteCount < this._sortableSprites.length)\r\n        {\r\n            this._sortableSprites.splice(spriteCount);\r\n        }\r\n\r\n        let iterator = 0;\r\n\r\n        while(iterator < spriteCount)\r\n        {\r\n            const sprite = this._sortableSprites[iterator];\r\n\r\n            if(sprite && sprite.sprite) this.renderSprite(iterator, sprite);\r\n\r\n            iterator++;\r\n        }\r\n\r\n        this.cleanSprites(spriteCount);\r\n\r\n        if(update || updateVisuals) this._canvasUpdated = true;\r\n\r\n        this._renderTimestamp = this._totalTimeRunning;\r\n        this._renderedWidth = this._width;\r\n        this._renderedHeight = this._height;\r\n    }\r\n\r\n    public skipSpriteVisibilityChecking(): void\r\n    {\r\n        this._noSpriteVisibilityChecking = true;\r\n\r\n        this.render(-1, true);\r\n    }\r\n\r\n    public resumeSpriteVisibilityChecking(): void\r\n    {\r\n        this._noSpriteVisibilityChecking = false;\r\n    }\r\n\r\n    public getSortableSpriteList(): RoomObjectSpriteData[]\r\n    {\r\n        return this._objectCache.getSortableSpriteList();\r\n    }\r\n\r\n    public getPlaneSortableSprites(): SortableSprite[]\r\n    {\r\n        return this._objectCache.getPlaneSortableSprites();\r\n    }\r\n\r\n    public removeFromCache(identifier: string): void\r\n    {\r\n        this._objectCache.removeObjectCache(identifier);\r\n    }\r\n\r\n    private renderObject(object: IRoomObject, identifier: string, time: number, update: boolean, updateVisuals: boolean, count: number): number\r\n    {\r\n        if(!object) return 0;\r\n\r\n        const visualization = object.visualization as IRoomObjectSpriteVisualization;\r\n\r\n        if(!visualization)\r\n        {\r\n            this.removeFromCache(identifier);\r\n\r\n            return 0;\r\n        }\r\n\r\n        const cache = this.getCacheItem(identifier);\r\n        cache.objectId = object.instanceId;\r\n\r\n        const locationCache = cache.location;\r\n        const sortableCache = cache.sprites;\r\n\r\n        const vector = locationCache.updateLocation(object, this._geometry);\r\n\r\n        if(!vector)\r\n        {\r\n            this.removeFromCache(identifier);\r\n\r\n            return 0;\r\n        }\r\n\r\n        if(updateVisuals) visualization.update(this._geometry, time, (!sortableCache.isEmpty || update), (this._skipObjectUpdate && this._runningSlow));\r\n\r\n        if(locationCache.locationChanged) update = true;\r\n\r\n        if(!sortableCache.needsUpdate(visualization.instanceId, visualization.updateSpriteCounter) && !update)\r\n        {\r\n            return sortableCache.spriteCount;\r\n        }\r\n\r\n        let x = vector.x;\r\n        let y = vector.y;\r\n        let z = vector.z;\r\n\r\n        if(x > 0) z = (z + (x * 1.2E-7));\r\n        else z = (z + (-(x) * 1.2E-7));\r\n\r\n        x = (x + Math.trunc(this._width / 2));\r\n        y = (y + Math.trunc(this._height / 2));\r\n\r\n        let spriteCount = 0;\r\n\r\n        for(const sprite of visualization.sprites.values())\r\n        {\r\n            if(!sprite || !sprite.visible) continue;\r\n\r\n            const texture = sprite.texture;\r\n            const baseTexture = texture && texture.baseTexture;\r\n\r\n            if(!texture || !baseTexture) continue;\r\n\r\n            const spriteX = ((x + sprite.offsetX) + this._screenOffsetX);\r\n            const spriteY = ((y + sprite.offsetY) + this._screenOffsetY);\r\n\r\n            if(sprite.flipH)\r\n            {\r\n                const checkX = ((x + (-(texture.width + (-(sprite.offsetX))))) + this._screenOffsetX);\r\n\r\n                if(!this.isSpriteVisible(checkX, spriteY, texture.width, texture.height)) continue;\r\n            }\r\n\r\n            else if(sprite.flipV)\r\n            {\r\n                const checkY = ((y + (-(texture.height + (-(sprite.offsetY))))) + this._screenOffsetY);\r\n\r\n                if(!this.isSpriteVisible(spriteX, checkY, texture.width, texture.height)) continue;\r\n            }\r\n\r\n            else\r\n            {\r\n                if(!this.isSpriteVisible(spriteX, spriteY, texture.width, texture.height)) continue;\r\n            }\r\n\r\n            let sortableSprite = sortableCache.getSprite(spriteCount);\r\n\r\n            if(!sortableSprite)\r\n            {\r\n                sortableSprite = new SortableSprite();\r\n\r\n                sortableCache.addSprite(sortableSprite);\r\n\r\n                this._sortableSprites.push(sortableSprite);\r\n\r\n                sortableSprite.name = identifier;\r\n            }\r\n\r\n            sortableSprite.sprite = sprite;\r\n\r\n            if((sprite.spriteType === RoomObjectSpriteType.AVATAR) || (sprite.spriteType === RoomObjectSpriteType.AVATAR_OWN))\r\n            {\r\n                sortableSprite.sprite.libraryAssetName = 'avatar_' + object.id;\r\n            }\r\n\r\n            sortableSprite.x = (spriteX - this._screenOffsetX);\r\n            sortableSprite.y = (spriteY - this._screenOffsetY);\r\n            sortableSprite.z = ((z + sprite.relativeDepth) + (3.7E-11 * count));\r\n\r\n            spriteCount++;\r\n            count++;\r\n        }\r\n\r\n        sortableCache.setSpriteCount(spriteCount);\r\n\r\n        this._canvasUpdated = true;\r\n\r\n        return spriteCount;\r\n    }\r\n\r\n    private getExtendedSprite(index: number): ExtendedSprite\r\n    {\r\n        if((index < 0) || (index >= this._spriteCount)) return null;\r\n\r\n        const sprite = (this._display.getChildAt(index) as ExtendedSprite);\r\n\r\n        if(!sprite) return null;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    protected getExtendedSpriteIdentifier(sprite: ExtendedSprite): string\r\n    {\r\n        if(!sprite) return '';\r\n\r\n        return sprite.name;\r\n    }\r\n\r\n    private renderSprite(index: number, sprite: SortableSprite): boolean\r\n    {\r\n        if(index >= this._spriteCount)\r\n        {\r\n            this.createAndAddSprite(sprite);\r\n\r\n            return true;\r\n        }\r\n\r\n        if(!sprite) return false;\r\n\r\n        const objectSprite = sprite.sprite;\r\n        const extendedSprite = this.getExtendedSprite(index);\r\n\r\n        if(!objectSprite || !extendedSprite) return false;\r\n\r\n        if(extendedSprite.varyingDepth !== objectSprite.varyingDepth)\r\n        {\r\n            if(extendedSprite.varyingDepth && !objectSprite.varyingDepth)\r\n            {\r\n                this._display.removeChildAt(index);\r\n\r\n                this._spritePool.push(extendedSprite);\r\n\r\n                return this.renderSprite(index, sprite);\r\n            }\r\n\r\n            this.createAndAddSprite(sprite, index);\r\n\r\n            return true;\r\n        }\r\n\r\n        if(extendedSprite.needsUpdate(objectSprite.id, objectSprite.updateCounter) || RoomEnterEffect.isVisualizationOn())\r\n        {\r\n            extendedSprite.tag = objectSprite.tag;\r\n            extendedSprite.alphaTolerance = objectSprite.alphaTolerance;\r\n            extendedSprite.name = sprite.name;\r\n            extendedSprite.varyingDepth = objectSprite.varyingDepth;\r\n            extendedSprite.clickHandling = objectSprite.clickHandling;\r\n            extendedSprite.filters = objectSprite.filters;\r\n\r\n            const alpha = (objectSprite.alpha / 255);\r\n\r\n            if(extendedSprite.alpha !== alpha) extendedSprite.alpha = alpha;\r\n\r\n            if(extendedSprite.tint !== objectSprite.color) extendedSprite.tint = objectSprite.color;\r\n\r\n            if(extendedSprite.blendMode !== objectSprite.blendMode) extendedSprite.blendMode = objectSprite.blendMode;\r\n\r\n            if(extendedSprite.texture !== objectSprite.texture) extendedSprite.setTexture(objectSprite.texture);\r\n\r\n            if(objectSprite.updateContainer)\r\n            {\r\n                const length = extendedSprite.children.length;\r\n\r\n                if(length === 1) extendedSprite.removeChildAt(0);\r\n\r\n                extendedSprite.addChild(objectSprite.container);\r\n\r\n                objectSprite.updateContainer = false;\r\n            }\r\n\r\n            if(objectSprite.flipH)\r\n            {\r\n                if(extendedSprite.scale.x !== -1) extendedSprite.scale.x = -1;\r\n            }\r\n            else\r\n            {\r\n                if(extendedSprite.scale.x !== 1) extendedSprite.scale.x = 1;\r\n            }\r\n\r\n            if(objectSprite.flipV)\r\n            {\r\n                if(extendedSprite.scale.y !== -1) extendedSprite.scale.y = -1;\r\n            }\r\n            else\r\n            {\r\n                if(extendedSprite.scale.y !== 1) extendedSprite.scale.y = 1;\r\n            }\r\n\r\n            this.updateEnterRoomEffect(extendedSprite, objectSprite);\r\n        }\r\n\r\n        if(extendedSprite.x !== sprite.x) extendedSprite.x = sprite.x;\r\n        if(extendedSprite.y !== sprite.y) extendedSprite.y = sprite.y;\r\n\r\n        extendedSprite.offsetX = objectSprite.offsetX;\r\n        extendedSprite.offsetY = objectSprite.offsetY;\r\n\r\n        return true;\r\n    }\r\n\r\n    private createAndAddSprite(sortableSprite: SortableSprite, index: number = -1): void\r\n    {\r\n        const sprite = sortableSprite.sprite;\r\n\r\n        if(!sprite) return;\r\n\r\n        let extendedSprite: ExtendedSprite = null;\r\n\r\n        if(this._spritePool.length > 0) extendedSprite = this._spritePool.pop();\r\n\r\n        if(!extendedSprite) extendedSprite = new ExtendedSprite();\r\n\r\n        if(extendedSprite.children.length) extendedSprite.removeChildren();\r\n\r\n        extendedSprite.tag = sprite.tag;\r\n        extendedSprite.alphaTolerance = sprite.alphaTolerance;\r\n        extendedSprite.alpha = (sprite.alpha / 255);\r\n        extendedSprite.tint = sprite.color;\r\n        extendedSprite.x = sortableSprite.x;\r\n        extendedSprite.y = sortableSprite.y;\r\n        extendedSprite.offsetX = sprite.offsetX;\r\n        extendedSprite.offsetY = sprite.offsetY;\r\n        extendedSprite.name = sprite.name;\r\n        extendedSprite.varyingDepth = sprite.varyingDepth;\r\n        extendedSprite.clickHandling = sprite.clickHandling;\r\n        extendedSprite.blendMode = sprite.blendMode;\r\n        extendedSprite.filters = sprite.filters;\r\n\r\n        extendedSprite.setTexture(sprite.texture);\r\n\r\n        if(sprite.updateContainer)\r\n        {\r\n            extendedSprite.addChild(sprite.container);\r\n\r\n            sprite.updateContainer = false;\r\n        }\r\n\r\n        if(sprite.flipH) extendedSprite.scale.x = -1;\r\n\r\n        if(sprite.flipV) extendedSprite.scale.y = -1;\r\n\r\n        this.updateEnterRoomEffect(extendedSprite, sprite);\r\n\r\n        if((index < 0) || (index >= this._spriteCount))\r\n        {\r\n            this._display.addChild(extendedSprite);\r\n\r\n            this._spriteCount++;\r\n        }\r\n        else\r\n        {\r\n            this._display.addChildAt(extendedSprite, index);\r\n        }\r\n\r\n        this._activeSpriteCount++;\r\n    }\r\n\r\n    private cleanSprites(spriteCount: number, _arg_2: boolean = false): void\r\n    {\r\n        if(!this._display) return;\r\n\r\n        if(spriteCount < 0) spriteCount = 0;\r\n\r\n        if((spriteCount < this._activeSpriteCount) || !this._activeSpriteCount)\r\n        {\r\n            let iterator = (this._spriteCount - 1);\r\n\r\n            while(iterator >= spriteCount)\r\n            {\r\n                this.cleanSprite(this.getExtendedSprite(iterator), _arg_2);\r\n\r\n                iterator--;\r\n            }\r\n        }\r\n\r\n        this._activeSpriteCount = spriteCount;\r\n    }\r\n\r\n    private updateEnterRoomEffect(sprite: ExtendedSprite, _arg_2: IRoomObjectSprite): void\r\n    {\r\n        if(!RoomEnterEffect.isVisualizationOn() || !_arg_2) return;\r\n\r\n        switch(_arg_2.spriteType)\r\n        {\r\n            case RoomObjectSpriteType.AVATAR_OWN:\r\n                return;\r\n            case RoomObjectSpriteType.ROOM_PLANE:\r\n                sprite.alpha = RoomEnterEffect.getDelta(0.9);\r\n                return;\r\n            case RoomObjectSpriteType.AVATAR:\r\n                sprite.alpha = RoomEnterEffect.getDelta(0.5);\r\n                return;\r\n            default:\r\n                sprite.alpha = RoomEnterEffect.getDelta(0.1);\r\n        }\r\n    }\r\n\r\n    private cleanSprite(sprite: ExtendedSprite, _arg_2: boolean): void\r\n    {\r\n        if(!sprite) return;\r\n\r\n        if(!_arg_2)\r\n        {\r\n            sprite.setTexture(null);\r\n        }\r\n        else\r\n        {\r\n            if(sprite.parent) sprite.parent.removeChild(sprite);\r\n\r\n            sprite.destroy({\r\n                children: true\r\n            });\r\n        }\r\n    }\r\n\r\n    public update(): void\r\n    {\r\n        if(!this._mouseCheckCount)\r\n        {\r\n            //this.checkMouseHits(this._mouseLocation.x, this._mouseLocation.y, MouseEventType.MOUSE_MOVE);\r\n        }\r\n\r\n        this._mouseCheckCount = 0;\r\n\r\n        this._eventId++;\r\n    }\r\n\r\n    public setMouseListener(listener: IRoomCanvasMouseListener): void\r\n    {\r\n        this._mouseListener = listener;\r\n    }\r\n\r\n    private getCacheItem(id: string): RoomObjectCacheItem\r\n    {\r\n        return this._objectCache.getObjectCache(id);\r\n    }\r\n\r\n    private isSpriteVisible(x: number, y: number, width: number, height: number): boolean\r\n    {\r\n        if(this._noSpriteVisibilityChecking) return true;\r\n\r\n        x = (((x - this._screenOffsetX) * this._scale) + this._screenOffsetX);\r\n        y = (((y - this._screenOffsetY) * this._scale) + this._screenOffsetY);\r\n        width = (width * this._scale);\r\n        height = (height * this._scale);\r\n\r\n        if(((x < this._width) && ((x + width) >= 0)) && ((y < this._height) && ((y + height) >= 0)))\r\n        {\r\n            if(!this._usesExclusionRectangles) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public handleMouseEvent(x: number, y: number, type: string, altKey: boolean, ctrlKey: boolean, shiftKey: boolean, buttonDown: boolean): boolean\r\n    {\r\n        x = (x - this._screenOffsetX);\r\n        y = (y - this._screenOffsetY);\r\n\r\n        this._mouseLocation.x = (x / this._scale);\r\n        this._mouseLocation.y = (y / this._scale);\r\n\r\n        if((this._mouseCheckCount > 0) && (type == MouseEventType.MOUSE_MOVE)) return this._mouseSpriteWasHit;\r\n\r\n        this._mouseSpriteWasHit = this.checkMouseHits(Math.trunc(x / this._scale), Math.trunc(y / this._scale), type, altKey, ctrlKey, shiftKey, buttonDown);\r\n\r\n        this._mouseCheckCount++;\r\n\r\n        return this._mouseSpriteWasHit;\r\n    }\r\n\r\n    private checkMouseHits(x: number, y: number, type: string, altKey: boolean = false, ctrlKey: boolean = false, shiftKey: boolean = false, buttonDown: boolean = false): boolean\r\n    {\r\n        const checkedSprites: string[] = [];\r\n\r\n        let didHitSprite = false;\r\n        let mouseEvent: RoomSpriteMouseEvent = null;\r\n        let spriteId = (this._activeSpriteCount - 1);\r\n\r\n        while(spriteId >= 0)\r\n        {\r\n            const extendedSprite = this.getExtendedSprite(spriteId);\r\n\r\n            if(extendedSprite && extendedSprite.containsPoint(new Point((x - extendedSprite.x), (y - extendedSprite.y))))\r\n            {\r\n                if(extendedSprite.clickHandling && ((type === MouseEventType.MOUSE_CLICK) || (type === MouseEventType.DOUBLE_CLICK)))\r\n                {\r\n                    //\r\n                }\r\n                else\r\n                {\r\n                    const identifier = this.getExtendedSpriteIdentifier(extendedSprite);\r\n\r\n                    if(checkedSprites.indexOf(identifier) === -1)\r\n                    {\r\n                        const tag = extendedSprite.tag;\r\n\r\n                        let mouseData = this._mouseActiveObjects.get(identifier);\r\n\r\n                        if(mouseData)\r\n                        {\r\n                            if(mouseData.spriteTag !== tag)\r\n                            {\r\n                                mouseEvent = this.createMouseEvent(0, 0, 0, 0, MouseEventType.ROLL_OUT, mouseData.spriteTag, altKey, ctrlKey, shiftKey, buttonDown);\r\n\r\n                                this.bufferMouseEvent(mouseEvent, identifier);\r\n                            }\r\n                        }\r\n\r\n                        if((type === MouseEventType.MOUSE_MOVE) && (!mouseData || (mouseData.spriteTag !== tag)))\r\n                        {\r\n                            mouseEvent = this.createMouseEvent(x, y, (x - extendedSprite.x), (y - extendedSprite.y), MouseEventType.ROLL_OVER, tag, altKey, ctrlKey, shiftKey, buttonDown);\r\n                        }\r\n                        else\r\n                        {\r\n                            mouseEvent = this.createMouseEvent(x, y, (x - extendedSprite.x), (y - extendedSprite.y), type, tag, altKey, ctrlKey, shiftKey, buttonDown);\r\n\r\n                            mouseEvent.spriteOffsetX = extendedSprite.offsetX;\r\n                            mouseEvent.spriteOffsetY = extendedSprite.offsetY;\r\n                        }\r\n\r\n                        if(!mouseData)\r\n                        {\r\n                            mouseData = new ObjectMouseData();\r\n\r\n                            mouseData.objectId = identifier;\r\n                            this._mouseActiveObjects.set(identifier, mouseData);\r\n                        }\r\n\r\n                        mouseData.spriteTag = tag;\r\n\r\n                        if(((type !== MouseEventType.MOUSE_MOVE) || (x !== this._mouseOldX)) || (y !== this._mouseOldY))\r\n                        {\r\n                            this.bufferMouseEvent(mouseEvent, identifier);\r\n                        }\r\n\r\n                        checkedSprites.push(identifier);\r\n                    }\r\n\r\n                    didHitSprite = true;\r\n                }\r\n            }\r\n\r\n            spriteId--;\r\n        }\r\n\r\n        const keys: string[] = [];\r\n\r\n        for(const key of this._mouseActiveObjects.keys()) key && keys.push(key);\r\n\r\n        let index = 0;\r\n\r\n        while(index < keys.length)\r\n        {\r\n            const key = keys[index];\r\n\r\n            if(checkedSprites.indexOf(key) >= 0) keys[index] = null;\r\n\r\n            index++;\r\n        }\r\n\r\n        index = 0;\r\n\r\n        while(index < keys.length)\r\n        {\r\n            const key = keys[index];\r\n\r\n            if(key !== null)\r\n            {\r\n                const existing = this._mouseActiveObjects.get(key);\r\n\r\n                if(existing) this._mouseActiveObjects.delete(key);\r\n\r\n                const mouseEvent = this.createMouseEvent(0, 0, 0, 0, MouseEventType.ROLL_OUT, existing.spriteTag, altKey, ctrlKey, shiftKey, buttonDown);\r\n\r\n                this.bufferMouseEvent(mouseEvent, key);\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        this.processMouseEvents();\r\n        this._mouseOldX = x;\r\n        this._mouseOldY = y;\r\n\r\n        return didHitSprite;\r\n    }\r\n\r\n    protected createMouseEvent(x: number, y: number, localX: number, localY: number, type: string, tag: string, altKey: boolean, ctrlKey: boolean, shiftKey: boolean, buttonDown: boolean): RoomSpriteMouseEvent\r\n    {\r\n        const screenX: number = (x - (this._width / 2));\r\n        const screenY: number = (y - (this._height / 2));\r\n        const canvasName = `canvas_${ this._id }`;\r\n\r\n        return new RoomSpriteMouseEvent(type, ((canvasName + '_') + this._eventId), canvasName, tag, screenX, screenY, localX, localY, ctrlKey, altKey, shiftKey, buttonDown);\r\n    }\r\n\r\n    protected bufferMouseEvent(k: RoomSpriteMouseEvent, _arg_2: string): void\r\n    {\r\n        if(!k || !this._eventCache) return;\r\n\r\n        this._eventCache.delete(_arg_2);\r\n        this._eventCache.set(_arg_2, k);\r\n    }\r\n\r\n    protected processMouseEvents(): void\r\n    {\r\n        if(!this._container || !this._eventCache) return;\r\n\r\n        for(const [ key, event ] of this._eventCache.entries())\r\n        {\r\n            if(!this._eventCache) return;\r\n\r\n            if(!event) continue;\r\n\r\n            const roomObject = this._container.getRoomObject(parseInt(key));\r\n\r\n            if(!roomObject) continue;\r\n\r\n            if(this._mouseListener)\r\n            {\r\n                this._mouseListener.processRoomCanvasMouseEvent(event, roomObject, this._geometry);\r\n            }\r\n            else\r\n            {\r\n                const logic = roomObject.mouseHandler;\r\n\r\n                if(logic)\r\n                {\r\n                    logic.mouseEvent(event, this._geometry);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(this._eventCache) this._eventCache.clear();\r\n    }\r\n\r\n    public getDisplayAsTexture(): RenderTexture\r\n    {\r\n        this._noSpriteVisibilityChecking = true;\r\n        const k = this._scale;\r\n        const _local_2 = this._screenOffsetX;\r\n        const _local_3 = this._screenOffsetY;\r\n        this.setScale(1, null, null, true);\r\n        this._screenOffsetX = 0;\r\n        this._screenOffsetY = 0;\r\n        this.render(-1, true);\r\n\r\n        this._display.mask = null;\r\n\r\n        const bounds = this._display.getBounds();\r\n\r\n        const renderTexture = RenderTexture.create({\r\n            width: this._display.width,\r\n            height: this._display.height\r\n        });\r\n\r\n        Nitro.instance.renderer.render(this._display, {\r\n            renderTexture,\r\n            clear: true,\r\n            transform: new Matrix(1, 0, 0, 1, -(bounds.x), -(bounds.y))\r\n        });\r\n\r\n        this._display.mask = this._mask;\r\n\r\n        this._noSpriteVisibilityChecking = false;\r\n        this.setScale(k, null, null, true);\r\n        this._screenOffsetX = _local_2;\r\n        this._screenOffsetY = _local_3;\r\n\r\n        return renderTexture;\r\n    }\r\n\r\n    private doMagic(): void\r\n    {\r\n        const geometry = (this.geometry as RoomGeometry);\r\n\r\n        if(this._rotation !== 0)\r\n        {\r\n            let direction = this._effectDirection;\r\n\r\n            geometry.direction = new Vector3d((direction.x + this._rotation), direction.y, direction.z);\r\n\r\n            direction = (geometry.direction as Vector3d);\r\n\r\n            geometry.setDepthVector(new Vector3d(direction.x, direction.y, 5));\r\n\r\n            const location = new Vector3d();\r\n\r\n            location.assign(this._rotationOrigin);\r\n\r\n            location.x = (location.x + ((this._rotationRodLength * Math.cos((((direction.x + 180) / 180) * 3.14159265358979))) * Math.cos(((direction.y / 180) * 3.14159265358979))));\r\n            location.y = (location.y + ((this._rotationRodLength * Math.sin((((direction.x + 180) / 180) * 3.14159265358979))) * Math.cos(((direction.y / 180) * 3.14159265358979))));\r\n            location.z = (location.z + (this._rotationRodLength * Math.sin(((direction.y / 180) * 3.14159265358979))));\r\n\r\n            geometry.location = location;\r\n\r\n            this._effectLocation = new Vector3d();\r\n            this._effectLocation.assign(location);\r\n            this._effectDirection = new Vector3d();\r\n            this._effectDirection.assign(geometry.direction);\r\n        }\r\n\r\n        if(RoomShakingEffect.isVisualizationOn() && !this._SafeStr_4507)\r\n        {\r\n            this.changeShaking();\r\n        }\r\n        else\r\n        {\r\n            if(!RoomShakingEffect.isVisualizationOn() && this._SafeStr_4507) this.changeShaking();\r\n        }\r\n\r\n        if(RoomRotatingEffect.isVisualizationOn()) this.changeRotation();\r\n\r\n        if(this._SafeStr_4507)\r\n        {\r\n            this._SafeStr_795++;\r\n\r\n            const _local_4 = this._effectDirection;\r\n            const _local_1 = Vector3d.sum(_local_4, new Vector3d((Math.sin((((this._SafeStr_795 * 5) / 180) * 3.14159265358979)) * 2), (Math.sin(((this._SafeStr_795 / 180) * 3.14159265358979)) * 5), (Math.sin((((this._SafeStr_795 * 10) / 180) * 3.14159265358979)) * 2)));\r\n\r\n            geometry.direction = _local_1;\r\n        }\r\n        else\r\n        {\r\n            this._SafeStr_795 = 0;\r\n\r\n            geometry.direction = this._effectDirection;\r\n        }\r\n    }\r\n\r\n    private changeShaking(): void\r\n    {\r\n        this._SafeStr_4507 = !this._SafeStr_4507;\r\n\r\n        if(this._SafeStr_4507)\r\n        {\r\n            const direction = this.geometry.direction;\r\n\r\n            this._effectDirection = new Vector3d(direction.x, direction.y, direction.z);\r\n        }\r\n    }\r\n\r\n    private changeRotation(): void\r\n    {\r\n        if(this._SafeStr_4507) return;\r\n\r\n        const geometry = (this.geometry as RoomGeometry);\r\n\r\n        if(!geometry) return;\r\n\r\n        if(this._rotation === 0)\r\n        {\r\n            const location = geometry.location;\r\n            const directionAxis = geometry.directionAxis;\r\n\r\n            this._effectLocation = new Vector3d();\r\n            this._effectLocation.assign(location);\r\n            this._effectDirection = new Vector3d();\r\n            this._effectDirection.assign(geometry.direction);\r\n\r\n            const intersection = RoomGeometry.getIntersectionVector(location, directionAxis, new Vector3d(0, 0, 0), new Vector3d(0, 0, 1));\r\n\r\n            if(intersection !== null)\r\n            {\r\n                this._rotationOrigin = new Vector3d(intersection.x, intersection.y, intersection.z);\r\n                this._rotationRodLength = Vector3d.dif(intersection, location).length;\r\n                this._rotation = 1;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this._rotation = 0;\r\n\r\n        geometry.location = this._effectLocation;\r\n        geometry.direction = this._effectDirection;\r\n        geometry.setDepthVector(new Vector3d(this._effectDirection.x, this._effectDirection.y, 5));\r\n    }\r\n\r\n    public moveLeft(): void\r\n    {\r\n        if(this._rotation !== 0)\r\n        {\r\n            if(this._rotation === 1)\r\n            {\r\n                this._rotation = -1;\r\n            }\r\n            else\r\n            {\r\n                this._rotation = (this._rotation - 1);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const geometry = (this.geometry as RoomGeometry);\r\n        const direction = (((geometry.direction.x - 90) / 180) * 3.14159265358979);\r\n\r\n        geometry.location = Vector3d.sum(geometry.location, new Vector3d((Math.cos(direction) * Math.sqrt(2)), (Math.sin(direction) * Math.sqrt(2))));\r\n    }\r\n\r\n    public moveRight(): void\r\n    {\r\n        if(this._rotation !== 0)\r\n        {\r\n            if(this._rotation === -1)\r\n            {\r\n                this._rotation = 1;\r\n            }\r\n            else\r\n            {\r\n                this._rotation = (this._rotation + 1);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const geometry = (this.geometry as RoomGeometry);\r\n        const direction = (((geometry.direction.x + 90) / 180) * 3.14159265358979);\r\n\r\n        geometry.location = Vector3d.sum(geometry.location, new Vector3d((Math.cos(direction) * Math.sqrt(2)), (Math.sin(direction) * Math.sqrt(2))));\r\n    }\r\n\r\n    public moveUp(): void\r\n    {\r\n        if(this._rotation !== 0) return;\r\n\r\n        const geometry = (this.geometry as RoomGeometry);\r\n        const direction = ((geometry.direction.x / 180) * 3.14159265358979);\r\n\r\n        geometry.location = Vector3d.sum(geometry.location, new Vector3d((Math.cos(direction) * Math.sqrt(2)), (Math.sin(direction) * Math.sqrt(2))));\r\n    }\r\n\r\n    public moveDown(): void\r\n    {\r\n        if(this._rotation !== 0) return;\r\n\r\n        const geometry = (this.geometry as RoomGeometry);\r\n        const direction = (((geometry.direction.x + 180) / 180) * 3.14159265358979);\r\n\r\n        geometry.location = Vector3d.sum(geometry.location, new Vector3d((Math.cos(direction) * Math.sqrt(2)), (Math.sin(direction) * Math.sqrt(2))));\r\n    }\r\n\r\n    public get id(): number\r\n    {\r\n        return this._id;\r\n    }\r\n\r\n    public get geometry(): IRoomGeometry\r\n    {\r\n        return this._geometry;\r\n    }\r\n\r\n    public get master(): DisplayObject\r\n    {\r\n        return this._master;\r\n    }\r\n\r\n    public get display(): DisplayObject\r\n    {\r\n        return this._display;\r\n    }\r\n\r\n    public get screenOffsetX(): number\r\n    {\r\n        return this._screenOffsetX;\r\n    }\r\n\r\n    public set screenOffsetX(x: number)\r\n    {\r\n        x = Math.trunc(x);\r\n\r\n        this._mouseLocation.x = (this._mouseLocation.x - (x - this._screenOffsetX));\r\n        this._screenOffsetX = x;\r\n    }\r\n\r\n    public get screenOffsetY(): number\r\n    {\r\n        return this._screenOffsetY;\r\n    }\r\n\r\n    public set screenOffsetY(y: number)\r\n    {\r\n        y = Math.trunc(y);\r\n\r\n        this._mouseLocation.y = (this._mouseLocation.y - (y - this._screenOffsetY));\r\n        this._screenOffsetY = y;\r\n    }\r\n\r\n    public get scale(): number\r\n    {\r\n        return this._scale;\r\n    }\r\n\r\n    public get width(): number\r\n    {\r\n        return (this._width * this._scale);\r\n    }\r\n\r\n    public get height(): number\r\n    {\r\n        return (this._height * this._scale);\r\n    }\r\n\r\n    public get restrictsScaling(): boolean\r\n    {\r\n        return this._restrictsScaling;\r\n    }\r\n\r\n    public set restrictsScaling(flag: boolean)\r\n    {\r\n        this._restrictsScaling = flag;\r\n    }\r\n\r\n    public get canvasUpdated(): boolean\r\n    {\r\n        return this._canvasUpdated;\r\n    }\r\n\r\n    public set canvasUpdated(flag: boolean)\r\n    {\r\n        this._canvasUpdated = flag;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}