{"ast":null,"code":"import { Graphics } from '@pixi/graphics';\nimport { Vector3d } from '../../../../../../../room/utils/Vector3d';\nimport { PlaneVisualizationAnimationLayer } from '../animated/PlaneVisualizationAnimationLayer';\nimport { PlaneVisualizationLayer } from './PlaneVisualizationLayer';\nexport class PlaneVisualization {\n  constructor(size, totalLayers, geometry) {\n    this._layers = void 0;\n    this._geometry = void 0;\n    this._cachedBitmapData = void 0;\n    this._cachedBitmapNormal = void 0;\n    this._isCached = void 0;\n    this._hasAnimationLayers = void 0;\n    this._layers = [];\n    this._geometry = geometry;\n    this._cachedBitmapData = null;\n    this._cachedBitmapNormal = new Vector3d();\n    this._isCached = false;\n    this._hasAnimationLayers = false;\n    if (totalLayers < 0) totalLayers = 0;\n    let index = 0;\n\n    while (index < totalLayers) {\n      this._layers.push(null);\n\n      index++;\n    }\n  }\n\n  get geometry() {\n    return this._geometry;\n  }\n\n  get hasAnimationLayers() {\n    return this._hasAnimationLayers;\n  }\n\n  dispose() {\n    if (this._layers && this._layers.length) {\n      for (const layer of this._layers) {\n        if (!layer) continue;\n        layer.dispose();\n      }\n\n      this._layers = null;\n    }\n\n    this._geometry = null;\n\n    if (this._cachedBitmapData) {\n      this._cachedBitmapData.destroy();\n\n      this._cachedBitmapData = null;\n    }\n\n    if (this._cachedBitmapNormal) this._cachedBitmapNormal = null;\n  }\n\n  clearCache() {\n    if (!this._isCached) return;\n\n    if (this._cachedBitmapData) {\n      this._cachedBitmapData.destroy();\n\n      this._cachedBitmapData = null;\n    }\n\n    if (this._cachedBitmapNormal) {\n      this._cachedBitmapNormal.assign(new Vector3d());\n    }\n\n    if (this._layers && this._layers.length) {\n      for (const layer of this._layers) {\n        if (!layer) continue;\n        const planeLayer = layer;\n        planeLayer.clearCache();\n      }\n    }\n\n    this._isCached = false;\n  }\n\n  setLayer(layerId, material, color, align) {\n    let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (layerId < 0 || layerId > this._layers.length) return false;\n    let layer = this._layers[layerId];\n    if (layer) layer.dispose();\n    layer = new PlaneVisualizationLayer(material, color, align, offset);\n    this._layers[layerId] = layer;\n    return true;\n  }\n\n  setAnimationLayer(layerId, animationItems, collection) {\n    if (layerId < 0 || layerId > this._layers.length) return false;\n    let layer = this._layers[layerId];\n    if (layer) layer.dispose();\n    layer = new PlaneVisualizationAnimationLayer(animationItems, collection);\n    this._layers[layerId] = layer;\n    this._hasAnimationLayers = true;\n    return true;\n  }\n\n  getLayers() {\n    return this._layers;\n  }\n\n  render(canvas, width, height, normal, useTexture) {\n    let offsetX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let offsetY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    let maxX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let maxY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let dimensionX = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let dimensionY = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    let timeSinceStartMs = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;\n    if (width < 1) width = 1;\n    if (height < 1) height = 1;\n    if (!canvas || canvas.width !== width || canvas.height !== height) canvas = null;\n\n    if (this._cachedBitmapData) {\n      if (this._cachedBitmapData.width === width && this._cachedBitmapData.height === height && Vector3d.isEqual(this._cachedBitmapNormal, normal)) {\n        if (!this.hasAnimationLayers) {\n          if (canvas) {\n            canvas.addChild(this._cachedBitmapData);\n            return canvas; // const texture = TextureUtils.generateTexture(this._cachedBitmapData, new Rectangle(0, 0, width, height));\n            // if(texture)\n            // {\n            //     canvas\n            //         .beginTextureFill({ texture })\n            //         .drawRect(0, 0, texture.width, texture.height)\n            //         .endFill();\n            //     return canvas;\n            // }\n          }\n\n          return this._cachedBitmapData;\n        }\n      } else {\n        this._cachedBitmapData.destroy();\n\n        this._cachedBitmapData = null;\n      }\n    }\n\n    this._isCached = true;\n\n    if (!this._cachedBitmapData) {\n      this._cachedBitmapData = new Graphics().beginFill(0xFFFFFF).drawRect(0, 0, width, height).endFill();\n    } else {\n      this._cachedBitmapData.beginFill(0xFFFFFF).drawRect(0, 0, width, height).endFill();\n    }\n\n    if (!canvas) canvas = this._cachedBitmapData;\n\n    this._cachedBitmapNormal.assign(normal);\n\n    if (this._layers && this._layers.length) {\n      for (const layer of this._layers) {\n        if (!layer) continue;\n\n        if (layer instanceof PlaneVisualizationLayer) {\n          layer.render(canvas, width, height, normal, useTexture, offsetX, offsetY);\n        } else if (layer instanceof PlaneVisualizationAnimationLayer) {\n          layer.render(canvas, width, height, normal, offsetX, offsetY, maxX, maxY, dimensionX, dimensionY, timeSinceStartMs);\n        }\n      }\n    }\n\n    if (canvas && canvas !== this._cachedBitmapData) {\n      this._cachedBitmapData.addChild(canvas.clone()); // const texture = TextureUtils.generateTexture(canvas, new Rectangle(0, 0, canvas.width, canvas.height));\n      // this._cachedBitmapData\n      //     .beginTextureFill({ texture })\n      //     .drawRect(0, 0, canvas.width, canvas.height)\n      //     .endFill();\n\n\n      return canvas;\n    }\n\n    return this._cachedBitmapData;\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/rasterizer/basic/PlaneVisualization.ts"],"names":["Graphics","Vector3d","PlaneVisualizationAnimationLayer","PlaneVisualizationLayer","PlaneVisualization","constructor","size","totalLayers","geometry","_layers","_geometry","_cachedBitmapData","_cachedBitmapNormal","_isCached","_hasAnimationLayers","index","push","hasAnimationLayers","dispose","length","layer","destroy","clearCache","assign","planeLayer","setLayer","layerId","material","color","align","offset","setAnimationLayer","animationItems","collection","getLayers","render","canvas","width","height","normal","useTexture","offsetX","offsetY","maxX","maxY","dimensionX","dimensionY","timeSinceStartMs","isEqual","addChild","beginFill","drawRect","endFill","clone"],"mappings":"AAAA,SAASA,QAAT,QAAyB,gBAAzB;AAKA,SAASC,QAAT,QAAyB,0CAAzB;AACA,SAASC,gCAAT,QAAiD,8CAAjD;AAEA,SAASC,uBAAT,QAAwC,2BAAxC;AAEA,OAAO,MAAMC,kBAAN,CACP;AAQIC,EAAAA,WAAW,CAACC,IAAD,EAAeC,WAAf,EAAoCC,QAApC,EACX;AAAA,SARQC,OAQR;AAAA,SAPQC,SAOR;AAAA,SANQC,iBAMR;AAAA,SALQC,mBAKR;AAAA,SAJQC,SAIR;AAAA,SAHQC,mBAGR;AACI,SAAKL,OAAL,GAAe,EAAf;AACA,SAAKC,SAAL,GAAiBF,QAAjB;AACA,SAAKG,iBAAL,GAAyB,IAAzB;AACA,SAAKC,mBAAL,GAA2B,IAAIX,QAAJ,EAA3B;AACA,SAAKY,SAAL,GAAiB,KAAjB;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AAEA,QAAGP,WAAW,GAAG,CAAjB,EAAoBA,WAAW,GAAG,CAAd;AAEpB,QAAIQ,KAAK,GAAG,CAAZ;;AAEA,WAAMA,KAAK,GAAGR,WAAd,EACA;AACI,WAAKE,OAAL,CAAaO,IAAb,CAAkB,IAAlB;;AAEAD,MAAAA,KAAK;AACR;AACJ;;AAEkB,MAARP,QAAQ,GACnB;AACI,WAAO,KAAKE,SAAZ;AACH;;AAE4B,MAAlBO,kBAAkB,GAC7B;AACI,WAAO,KAAKH,mBAAZ;AACH;;AAEMI,EAAAA,OAAO,GACd;AACI,QAAG,KAAKT,OAAL,IAAgB,KAAKA,OAAL,CAAaU,MAAhC,EACA;AACI,WAAI,MAAMC,KAAV,IAAmB,KAAKX,OAAxB,EACA;AACI,YAAG,CAACW,KAAJ,EAAW;AAEXA,QAAAA,KAAK,CAACF,OAAN;AACH;;AAED,WAAKT,OAAL,GAAe,IAAf;AACH;;AAED,SAAKC,SAAL,GAAiB,IAAjB;;AAEA,QAAG,KAAKC,iBAAR,EACA;AACI,WAAKA,iBAAL,CAAuBU,OAAvB;;AAEA,WAAKV,iBAAL,GAAyB,IAAzB;AACH;;AAED,QAAG,KAAKC,mBAAR,EAA6B,KAAKA,mBAAL,GAA2B,IAA3B;AAChC;;AAEMU,EAAAA,UAAU,GACjB;AACI,QAAG,CAAC,KAAKT,SAAT,EAAoB;;AAEpB,QAAG,KAAKF,iBAAR,EACA;AACI,WAAKA,iBAAL,CAAuBU,OAAvB;;AAEA,WAAKV,iBAAL,GAAyB,IAAzB;AACH;;AAED,QAAG,KAAKC,mBAAR,EACA;AACI,WAAKA,mBAAL,CAAyBW,MAAzB,CAAgC,IAAItB,QAAJ,EAAhC;AACH;;AAED,QAAG,KAAKQ,OAAL,IAAgB,KAAKA,OAAL,CAAaU,MAAhC,EACA;AACI,WAAI,MAAMC,KAAV,IAAmB,KAAKX,OAAxB,EACA;AACI,YAAG,CAACW,KAAJ,EAAW;AAEX,cAAMI,UAAU,GAAGJ,KAAnB;AAEAI,QAAAA,UAAU,CAACF,UAAX;AACH;AACJ;;AAED,SAAKT,SAAL,GAAiB,KAAjB;AACH;;AAEMY,EAAAA,QAAQ,CAACC,OAAD,EAAkBC,QAAlB,EAA2CC,KAA3C,EAA0DC,KAA1D,EACf;AAAA,QADwFC,MACxF,uEADyG,CACzG;AACI,QAAIJ,OAAO,GAAG,CAAX,IAAkBA,OAAO,GAAG,KAAKjB,OAAL,CAAaU,MAA5C,EAAqD,OAAO,KAAP;AAErD,QAAIC,KAAK,GAAG,KAAKX,OAAL,CAAaiB,OAAb,CAAZ;AAEA,QAAGN,KAAH,EAAUA,KAAK,CAACF,OAAN;AAEVE,IAAAA,KAAK,GAAG,IAAIjB,uBAAJ,CAA4BwB,QAA5B,EAAsCC,KAAtC,EAA6CC,KAA7C,EAAoDC,MAApD,CAAR;AAEA,SAAKrB,OAAL,CAAaiB,OAAb,IAAwBN,KAAxB;AAEA,WAAO,IAAP;AACH;;AAEMW,EAAAA,iBAAiB,CAACL,OAAD,EAAkBM,cAAlB,EAAuCC,UAAvC,EACxB;AACI,QAAIP,OAAO,GAAG,CAAX,IAAkBA,OAAO,GAAG,KAAKjB,OAAL,CAAaU,MAA5C,EAAqD,OAAO,KAAP;AAErD,QAAIC,KAAK,GAAG,KAAKX,OAAL,CAAaiB,OAAb,CAAZ;AAEA,QAAGN,KAAH,EAAUA,KAAK,CAACF,OAAN;AAEVE,IAAAA,KAAK,GAAG,IAAIlB,gCAAJ,CAAqC8B,cAArC,EAAqDC,UAArD,CAAR;AAEA,SAAKxB,OAAL,CAAaiB,OAAb,IAAwBN,KAAxB;AACA,SAAKN,mBAAL,GAA2B,IAA3B;AAEA,WAAO,IAAP;AACH;;AAEMoB,EAAAA,SAAS,GAChB;AACI,WAAO,KAAKzB,OAAZ;AACH;;AAEM0B,EAAAA,MAAM,CAACC,MAAD,EAAmBC,KAAnB,EAAkCC,MAAlC,EAAkDC,MAAlD,EAAqEC,UAArE,EACb;AAAA,QADuGC,OACvG,uEADyH,CACzH;AAAA,QAD4HC,OAC5H,uEAD8I,CAC9I;AAAA,QADiJC,IACjJ,uEADgK,CAChK;AAAA,QADmKC,IACnK,uEADkL,CAClL;AAAA,QADqLC,UACrL,uEAD0M,CAC1M;AAAA,QAD6MC,UAC7M,0EADkO,CAClO;AAAA,QADqOC,gBACrO,0EADgQ,CAChQ;AACI,QAAGV,KAAK,GAAG,CAAX,EAAcA,KAAK,GAAG,CAAR;AAEd,QAAGC,MAAM,GAAG,CAAZ,EAAeA,MAAM,GAAG,CAAT;AAEf,QAAI,CAACF,MAAD,IAAYA,MAAM,CAACC,KAAP,KAAiBA,KAA9B,IAA0CD,MAAM,CAACE,MAAP,KAAkBA,MAA/D,EAAwEF,MAAM,GAAG,IAAT;;AAExE,QAAG,KAAKzB,iBAAR,EACA;AACI,UAAK,KAAKA,iBAAL,CAAuB0B,KAAvB,KAAiCA,KAAlC,IAA6C,KAAK1B,iBAAL,CAAuB2B,MAAvB,KAAkCA,MAAhF,IAA6FrC,QAAQ,CAAC+C,OAAT,CAAiB,KAAKpC,mBAAtB,EAA2C2B,MAA3C,CAAhG,EACA;AACI,YAAG,CAAC,KAAKtB,kBAAT,EACA;AACI,cAAGmB,MAAH,EACA;AACIA,YAAAA,MAAM,CAACa,QAAP,CAAgB,KAAKtC,iBAArB;AAEA,mBAAOyB,MAAP,CAHJ,CAII;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH;;AAED,iBAAO,KAAKzB,iBAAZ;AACH;AACJ,OAxBD,MA0BA;AACI,aAAKA,iBAAL,CAAuBU,OAAvB;;AAEA,aAAKV,iBAAL,GAAyB,IAAzB;AACH;AACJ;;AAED,SAAKE,SAAL,GAAiB,IAAjB;;AAEA,QAAG,CAAC,KAAKF,iBAAT,EACA;AACI,WAAKA,iBAAL,GAAyB,IAAIX,QAAJ,GACpBkD,SADoB,CACV,QADU,EAEpBC,QAFoB,CAEX,CAFW,EAER,CAFQ,EAELd,KAFK,EAEEC,MAFF,EAGpBc,OAHoB,EAAzB;AAIH,KAND,MAQA;AACI,WAAKzC,iBAAL,CACKuC,SADL,CACe,QADf,EAEKC,QAFL,CAEc,CAFd,EAEiB,CAFjB,EAEoBd,KAFpB,EAE2BC,MAF3B,EAGKc,OAHL;AAIH;;AAED,QAAG,CAAChB,MAAJ,EAAYA,MAAM,GAAG,KAAKzB,iBAAd;;AAEZ,SAAKC,mBAAL,CAAyBW,MAAzB,CAAgCgB,MAAhC;;AAEA,QAAG,KAAK9B,OAAL,IAAgB,KAAKA,OAAL,CAAaU,MAAhC,EACA;AACI,WAAI,MAAMC,KAAV,IAAmB,KAAKX,OAAxB,EACA;AACI,YAAG,CAACW,KAAJ,EAAW;;AAEX,YAAGA,KAAK,YAAYjB,uBAApB,EACA;AACIiB,UAAAA,KAAK,CAACe,MAAN,CAAaC,MAAb,EAAqBC,KAArB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,UAA5C,EAAwDC,OAAxD,EAAiEC,OAAjE;AACH,SAHD,MAKK,IAAGtB,KAAK,YAAYlB,gCAApB,EACL;AACIkB,UAAAA,KAAK,CAACe,MAAN,CAAaC,MAAb,EAAqBC,KAArB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4CE,OAA5C,EAAqDC,OAArD,EAA8DC,IAA9D,EAAoEC,IAApE,EAA0EC,UAA1E,EAAsFC,UAAtF,EAAkGC,gBAAlG;AACH;AACJ;AACJ;;AAED,QAAGX,MAAM,IAAKA,MAAM,KAAK,KAAKzB,iBAA9B,EACA;AACI,WAAKA,iBAAL,CAAuBsC,QAAvB,CAAgCb,MAAM,CAACiB,KAAP,EAAhC,EADJ,CAEI;AAEA;AACA;AACA;AACA;;;AAEA,aAAOjB,MAAP;AACH;;AAED,WAAO,KAAKzB,iBAAZ;AACH;;AApOL","sourcesContent":["import { Graphics } from '@pixi/graphics';\r\nimport { IDisposable } from '../../../../../../../core/common/disposable/IDisposable';\r\nimport { IGraphicAssetCollection } from '../../../../../../../room/object/visualization/utils/IGraphicAssetCollection';\r\nimport { IRoomGeometry } from '../../../../../../../room/utils/IRoomGeometry';\r\nimport { IVector3D } from '../../../../../../../room/utils/IVector3D';\r\nimport { Vector3d } from '../../../../../../../room/utils/Vector3d';\r\nimport { PlaneVisualizationAnimationLayer } from '../animated/PlaneVisualizationAnimationLayer';\r\nimport { PlaneMaterial } from './PlaneMaterial';\r\nimport { PlaneVisualizationLayer } from './PlaneVisualizationLayer';\r\n\r\nexport class PlaneVisualization\r\n{\r\n    private _layers: IDisposable[];\r\n    private _geometry: IRoomGeometry;\r\n    private _cachedBitmapData: Graphics;\r\n    private _cachedBitmapNormal: Vector3d;\r\n    private _isCached: boolean;\r\n    private _hasAnimationLayers: boolean;\r\n\r\n    constructor(size: number, totalLayers: number, geometry: IRoomGeometry)\r\n    {\r\n        this._layers = [];\r\n        this._geometry = geometry;\r\n        this._cachedBitmapData = null;\r\n        this._cachedBitmapNormal = new Vector3d();\r\n        this._isCached = false;\r\n        this._hasAnimationLayers = false;\r\n\r\n        if(totalLayers < 0) totalLayers = 0;\r\n\r\n        let index = 0;\r\n\r\n        while(index < totalLayers)\r\n        {\r\n            this._layers.push(null);\r\n\r\n            index++;\r\n        }\r\n    }\r\n\r\n    public get geometry(): IRoomGeometry\r\n    {\r\n        return this._geometry;\r\n    }\r\n\r\n    public get hasAnimationLayers(): boolean\r\n    {\r\n        return this._hasAnimationLayers;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._layers && this._layers.length)\r\n        {\r\n            for(const layer of this._layers)\r\n            {\r\n                if(!layer) continue;\r\n\r\n                layer.dispose();\r\n            }\r\n\r\n            this._layers = null;\r\n        }\r\n\r\n        this._geometry = null;\r\n\r\n        if(this._cachedBitmapData)\r\n        {\r\n            this._cachedBitmapData.destroy();\r\n\r\n            this._cachedBitmapData = null;\r\n        }\r\n\r\n        if(this._cachedBitmapNormal) this._cachedBitmapNormal = null;\r\n    }\r\n\r\n    public clearCache(): void\r\n    {\r\n        if(!this._isCached) return;\r\n\r\n        if(this._cachedBitmapData)\r\n        {\r\n            this._cachedBitmapData.destroy();\r\n\r\n            this._cachedBitmapData = null;\r\n        }\r\n\r\n        if(this._cachedBitmapNormal)\r\n        {\r\n            this._cachedBitmapNormal.assign(new Vector3d());\r\n        }\r\n\r\n        if(this._layers && this._layers.length)\r\n        {\r\n            for(const layer of this._layers)\r\n            {\r\n                if(!layer) continue;\r\n\r\n                const planeLayer = layer as PlaneVisualizationLayer;\r\n\r\n                planeLayer.clearCache();\r\n            }\r\n        }\r\n\r\n        this._isCached = false;\r\n    }\r\n\r\n    public setLayer(layerId: number, material: PlaneMaterial, color: number, align: number, offset: number = 0): boolean\r\n    {\r\n        if((layerId < 0) || (layerId > this._layers.length)) return false;\r\n\r\n        let layer = this._layers[layerId];\r\n\r\n        if(layer) layer.dispose();\r\n\r\n        layer = new PlaneVisualizationLayer(material, color, align, offset);\r\n\r\n        this._layers[layerId] = layer;\r\n\r\n        return true;\r\n    }\r\n\r\n    public setAnimationLayer(layerId: number, animationItems: any, collection: IGraphicAssetCollection): boolean\r\n    {\r\n        if((layerId < 0) || (layerId > this._layers.length)) return false;\r\n\r\n        let layer = this._layers[layerId] as IDisposable;\r\n\r\n        if(layer) layer.dispose();\r\n\r\n        layer = new PlaneVisualizationAnimationLayer(animationItems, collection);\r\n\r\n        this._layers[layerId] = layer;\r\n        this._hasAnimationLayers = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public getLayers(): PlaneVisualizationLayer[]\r\n    {\r\n        return this._layers as PlaneVisualizationLayer[];\r\n    }\r\n\r\n    public render(canvas: Graphics, width: number, height: number, normal: IVector3D, useTexture: boolean, offsetX: number = 0, offsetY: number = 0, maxX: number = 0, maxY: number = 0, dimensionX: number = 0, dimensionY: number = 0, timeSinceStartMs: number = 0): Graphics\r\n    {\r\n        if(width < 1) width = 1;\r\n\r\n        if(height < 1) height = 1;\r\n\r\n        if((!canvas || (canvas.width !== width)) || (canvas.height !== height)) canvas = null;\r\n\r\n        if(this._cachedBitmapData)\r\n        {\r\n            if(((this._cachedBitmapData.width === width) && (this._cachedBitmapData.height === height)) && (Vector3d.isEqual(this._cachedBitmapNormal, normal)))\r\n            {\r\n                if(!this.hasAnimationLayers)\r\n                {\r\n                    if(canvas)\r\n                    {\r\n                        canvas.addChild(this._cachedBitmapData);\r\n\r\n                        return canvas;\r\n                        // const texture = TextureUtils.generateTexture(this._cachedBitmapData, new Rectangle(0, 0, width, height));\r\n\r\n                        // if(texture)\r\n                        // {\r\n                        //     canvas\r\n                        //         .beginTextureFill({ texture })\r\n                        //         .drawRect(0, 0, texture.width, texture.height)\r\n                        //         .endFill();\r\n\r\n                        //     return canvas;\r\n                        // }\r\n                    }\r\n\r\n                    return this._cachedBitmapData;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this._cachedBitmapData.destroy();\r\n\r\n                this._cachedBitmapData = null;\r\n            }\r\n        }\r\n\r\n        this._isCached = true;\r\n\r\n        if(!this._cachedBitmapData)\r\n        {\r\n            this._cachedBitmapData = new Graphics()\r\n                .beginFill(0xFFFFFF)\r\n                .drawRect(0, 0, width, height)\r\n                .endFill();\r\n        }\r\n        else\r\n        {\r\n            this._cachedBitmapData\r\n                .beginFill(0xFFFFFF)\r\n                .drawRect(0, 0, width, height)\r\n                .endFill();\r\n        }\r\n\r\n        if(!canvas) canvas = this._cachedBitmapData;\r\n\r\n        this._cachedBitmapNormal.assign(normal);\r\n\r\n        if(this._layers && this._layers.length)\r\n        {\r\n            for(const layer of this._layers)\r\n            {\r\n                if(!layer) continue;\r\n\r\n                if(layer instanceof PlaneVisualizationLayer)\r\n                {\r\n                    layer.render(canvas, width, height, normal, useTexture, offsetX, offsetY);\r\n                }\r\n\r\n                else if(layer instanceof PlaneVisualizationAnimationLayer)\r\n                {\r\n                    layer.render(canvas, width, height, normal, offsetX, offsetY, maxX, maxY, dimensionX, dimensionY, timeSinceStartMs);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(canvas && (canvas !== this._cachedBitmapData))\r\n        {\r\n            this._cachedBitmapData.addChild(canvas.clone());\r\n            // const texture = TextureUtils.generateTexture(canvas, new Rectangle(0, 0, canvas.width, canvas.height));\r\n\r\n            // this._cachedBitmapData\r\n            //     .beginTextureFill({ texture })\r\n            //     .drawRect(0, 0, canvas.width, canvas.height)\r\n            //     .endFill();\r\n\r\n            return canvas;\r\n        }\r\n\r\n        return this._cachedBitmapData;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}