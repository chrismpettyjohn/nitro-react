{"ast":null,"code":"import { NitroManager } from '../common/NitroManager';\nimport { ConfigurationEvent } from './ConfigurationEvent';\nexport class ConfigurationManager extends NitroManager {\n  constructor() {\n    super();\n    this._definitions = void 0;\n    this._pendingUrls = void 0;\n    this._missingKeys = void 0;\n    this._definitions = new Map();\n    this._pendingUrls = [];\n    this._missingKeys = [];\n    this.onConfigurationLoaded = this.onConfigurationLoaded.bind(this);\n  }\n\n  onInit() {\n    this.parseConfiguration(this.getDefaultConfig(), true);\n    this._pendingUrls = this.getValue('config.urls').slice();\n    this.loadNextConfiguration();\n  }\n\n  loadNextConfiguration() {\n    if (!this._pendingUrls.length) {\n      this.dispatchConfigurationEvent(ConfigurationEvent.LOADED);\n      return;\n    }\n\n    this.loadConfigurationFromUrl(this._pendingUrls[0]);\n  }\n\n  loadConfigurationFromUrl(url) {\n    if (!url || url === '') {\n      this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\n      return;\n    }\n\n    fetch(url).then(response => response.json()).then(data => this.onConfigurationLoaded(data, url)).catch(err => this.onConfigurationFailed(err));\n  }\n\n  onConfigurationLoaded(data, url) {\n    if (!data) return;\n\n    if (this.parseConfiguration(data)) {\n      const index = this._pendingUrls.indexOf(url);\n\n      if (index >= 0) this._pendingUrls.splice(index, 1);\n      this.loadNextConfiguration();\n      return;\n    }\n\n    this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\n  }\n\n  onConfigurationFailed(error) {\n    this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\n  }\n\n  dispatchConfigurationEvent(type) {\n    this.events && this.events.dispatchEvent(new ConfigurationEvent(type));\n  }\n\n  parseConfiguration(data) {\n    let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!data) return false;\n\n    try {\n      const regex = new RegExp(/\\${(.*?)}/g);\n\n      for (const key in data) {\n        let value = data[key];\n        if (typeof value === 'string') value = this.interpolate(value, regex);\n\n        if (this._definitions.has(key)) {\n          if (overrides) this.setValue(key, value);\n        } else {\n          this.setValue(key, value);\n        }\n      }\n\n      return true;\n    } catch (e) {\n      this.logger.error(e.stack);\n      return false;\n    }\n  }\n\n  interpolate(value) {\n    let regex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!regex) regex = new RegExp(/\\${(.*?)}/g);\n    const pieces = value.match(regex);\n\n    if (pieces && pieces.length) {\n      for (const piece of pieces) {\n        const existing = this._definitions.get(this.removeInterpolateKey(piece));\n\n        if (existing) value = value.replace(piece, existing);\n      }\n    }\n\n    return value;\n  }\n\n  removeInterpolateKey(value) {\n    return value.replace('${', '').replace('}', '');\n  }\n\n  getValue(key) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    let existing = this._definitions.get(key);\n\n    if (existing === undefined) {\n      if (this._missingKeys.indexOf(key) >= 0) return value;\n\n      this._missingKeys.push(key);\n\n      this.logger.warn(`Missing configuration key: ${key}`);\n      existing = value;\n    }\n\n    return existing;\n  }\n\n  setValue(key, value) {\n    this._definitions.set(key, value);\n  }\n\n  getDefaultConfig() {\n    //@ts-ignore\n    return NitroConfig;\n  }\n\n  get definitions() {\n    return this._definitions;\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/core/configuration/ConfigurationManager.ts"],"names":["NitroManager","ConfigurationEvent","ConfigurationManager","constructor","_definitions","_pendingUrls","_missingKeys","Map","onConfigurationLoaded","bind","onInit","parseConfiguration","getDefaultConfig","getValue","slice","loadNextConfiguration","length","dispatchConfigurationEvent","LOADED","loadConfigurationFromUrl","url","FAILED","fetch","then","response","json","data","catch","err","onConfigurationFailed","index","indexOf","splice","error","type","events","dispatchEvent","overrides","regex","RegExp","key","value","interpolate","has","setValue","e","logger","stack","pieces","match","piece","existing","get","removeInterpolateKey","replace","undefined","push","warn","set","NitroConfig","definitions"],"mappings":"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","sourcesContent":["import { NitroManager } from '../common/NitroManager';\r\nimport { ConfigurationEvent } from './ConfigurationEvent';\r\nimport { IConfigurationManager } from './IConfigurationManager';\r\n\r\nexport class ConfigurationManager extends NitroManager implements IConfigurationManager\r\n{\r\n    private _definitions: Map<string, unknown>;\r\n    private _pendingUrls: string[];\r\n    private _missingKeys: string[];\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._definitions = new Map();\r\n        this._pendingUrls = [];\r\n        this._missingKeys = [];\r\n\r\n        this.onConfigurationLoaded = this.onConfigurationLoaded.bind(this);\r\n    }\r\n\r\n    protected onInit(): void\r\n    {\r\n        this.parseConfiguration(this.getDefaultConfig(), true);\r\n\r\n        this._pendingUrls = this.getValue<string[]>('config.urls').slice();\r\n\r\n        this.loadNextConfiguration();\r\n    }\r\n\r\n    private loadNextConfiguration(): void\r\n    {\r\n        if(!this._pendingUrls.length)\r\n        {\r\n            this.dispatchConfigurationEvent(ConfigurationEvent.LOADED);\r\n\r\n            return;\r\n        }\r\n\r\n        this.loadConfigurationFromUrl(this._pendingUrls[0]);\r\n    }\r\n\r\n    public loadConfigurationFromUrl(url: string): void\r\n    {\r\n        if(!url || (url === ''))\r\n        {\r\n            this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\r\n\r\n            return;\r\n        }\r\n\r\n        fetch(url)\r\n            .then(response => response.json())\r\n            .then(data => this.onConfigurationLoaded(data, url))\r\n            .catch(err => this.onConfigurationFailed(err));\r\n    }\r\n\r\n    private onConfigurationLoaded(data: { [index: string]: any }, url: string): void\r\n    {\r\n        if(!data) return;\r\n\r\n        if(this.parseConfiguration(data))\r\n        {\r\n            const index = this._pendingUrls.indexOf(url);\r\n\r\n            if(index >= 0) this._pendingUrls.splice(index, 1);\r\n\r\n            this.loadNextConfiguration();\r\n\r\n            return;\r\n        }\r\n\r\n        this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\r\n    }\r\n\r\n    private onConfigurationFailed(error: Error): void\r\n    {\r\n        this.dispatchConfigurationEvent(ConfigurationEvent.FAILED);\r\n    }\r\n\r\n    private dispatchConfigurationEvent(type: string): void\r\n    {\r\n        this.events && this.events.dispatchEvent(new ConfigurationEvent(type));\r\n    }\r\n\r\n    private parseConfiguration(data: { [index: string]: any }, overrides: boolean = false): boolean\r\n    {\r\n        if(!data) return false;\r\n\r\n        try\r\n        {\r\n            const regex = new RegExp(/\\${(.*?)}/g);\r\n\r\n            for(const key in data)\r\n            {\r\n                let value = data[key];\r\n\r\n                if(typeof value === 'string') value = this.interpolate((value as string), regex);\r\n\r\n                if(this._definitions.has(key))\r\n                {\r\n                    if(overrides) this.setValue(key, value);\r\n                }\r\n                else\r\n                {\r\n                    this.setValue(key, value);\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        catch (e)\r\n        {\r\n            this.logger.error(e.stack);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public interpolate(value: string, regex: RegExp = null): string\r\n    {\r\n        if(!regex) regex = new RegExp(/\\${(.*?)}/g);\r\n\r\n        const pieces = value.match(regex);\r\n\r\n        if(pieces && pieces.length)\r\n        {\r\n            for(const piece of pieces)\r\n            {\r\n                const existing = (this._definitions.get(this.removeInterpolateKey(piece)) as string);\r\n\r\n                if(existing) (value = value.replace(piece, existing));\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private removeInterpolateKey(value: string): string\r\n    {\r\n        return value.replace('${', '').replace('}', '');\r\n    }\r\n\r\n    public getValue<T>(key: string, value: T = null): T\r\n    {\r\n        let existing = this._definitions.get(key);\r\n\r\n        if(existing === undefined)\r\n        {\r\n            if(this._missingKeys.indexOf(key) >= 0) return value;\r\n\r\n            this._missingKeys.push(key);\r\n            this.logger.warn(`Missing configuration key: ${ key }`);\r\n\r\n            existing = value;\r\n        }\r\n\r\n        return (existing as T);\r\n    }\r\n\r\n    public setValue(key: string, value: string): void\r\n    {\r\n        this._definitions.set(key, value);\r\n    }\r\n\r\n    public getDefaultConfig(): { [index: string]: any }\r\n    {\r\n        //@ts-ignore\r\n        return NitroConfig as { [index: string]: any };\r\n    }\r\n\r\n    public get definitions(): Map<string, unknown>\r\n    {\r\n        return this._definitions;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}