{"ast":null,"code":"import { Matrix, Point } from '@pixi/math';\nimport { NitroSprite } from '../../../../../../../core';\nimport { Randomizer } from '../../utils';\nexport class PlaneMaterialCell {\n  constructor(texture) {\n    let assets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let offsetPoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this._cachedSprite = void 0;\n    this._texture = void 0;\n    this._extraItemOffsets = void 0;\n    this._extraItemAssets = void 0;\n    this._extraItemCount = 0;\n    this._cachedSprite = null;\n    this._texture = texture;\n    this._extraItemOffsets = [];\n    this._extraItemAssets = [];\n    this._extraItemCount = 0;\n\n    if (assets && assets.length && limit > 0) {\n      let assetIndex = 0;\n\n      while (assetIndex < assets.length) {\n        const graphic = assets[assetIndex];\n        if (graphic) this._extraItemAssets.push(graphic);\n        assetIndex++;\n      }\n\n      if (this._extraItemAssets.length) {\n        if (offsetPoints) {\n          let pointIndex = 0;\n\n          while (pointIndex < offsetPoints.length) {\n            const point = offsetPoints[pointIndex];\n            if (point) this._extraItemOffsets.push(new Point(point.x, point.y));\n            pointIndex++;\n          }\n        }\n\n        this._extraItemCount = limit;\n      }\n    }\n  }\n\n  get isStatic() {\n    return this._extraItemCount == 0;\n  }\n\n  dispose() {\n    if (this._texture) {\n      this._texture.dispose();\n\n      this._texture = null;\n    }\n\n    if (this._cachedSprite) {\n      this._cachedSprite.destroy();\n\n      this._cachedSprite = null;\n    }\n\n    this._extraItemAssets = null;\n    this._extraItemOffsets = null;\n    this._extraItemCount = 0;\n  }\n\n  clearCache() {\n    if (this._cachedSprite) {\n      this._cachedSprite.destroy();\n\n      this._cachedSprite = null;\n    }\n  }\n\n  getHeight(normal) {\n    if (this._texture) {\n      const texture = this._texture.getBitmap(normal);\n\n      if (texture) return texture.height;\n    }\n\n    return 0;\n  }\n\n  render(normal, textureOffsetX, textureOffsetY) {\n    if (!this._texture) return null;\n\n    const texture = this._texture.getBitmap(normal);\n\n    if (!texture) return null;\n    const bitmap = new NitroSprite(texture);\n\n    if (textureOffsetX !== 0 || textureOffsetY !== 0) {\n      while (textureOffsetX < 0) textureOffsetX += texture.width;\n\n      while (textureOffsetY < 0) textureOffsetY += texture.height;\n\n      bitmap.x = textureOffsetX % texture.width;\n      bitmap.y = textureOffsetY % texture.height;\n\n      if (textureOffsetX) {\n        bitmap.anchor.x = 1;\n        bitmap.scale.x = -1;\n      }\n\n      if (textureOffsetY) {\n        bitmap.anchor.y = 1;\n        bitmap.scale.y = -1;\n      }\n    }\n\n    if (bitmap) {\n      if (!this.isStatic) {\n        if (this._cachedSprite) {\n          if (this._cachedSprite.width !== bitmap.width || this._cachedSprite.height !== bitmap.height) {\n            this._cachedSprite.destroy();\n\n            this._cachedSprite = null;\n          }\n        }\n\n        if (!this._cachedSprite) {\n          this._cachedSprite = new NitroSprite(texture);\n        }\n\n        const limitMin = Math.min(this._extraItemCount, this._extraItemOffsets.length);\n        const limitMax = Math.max(this._extraItemCount, this._extraItemOffsets.length);\n        const offsetIndexes = Randomizer.getArray(this._extraItemCount, limitMax);\n        let i = 0;\n\n        while (i < limitMin) {\n          const offset = this._extraItemOffsets[offsetIndexes[i]];\n          const item = this._extraItemAssets[i % this._extraItemAssets.length];\n\n          if (offset && item) {\n            const assetTexture = item.texture;\n\n            if (assetTexture) {\n              const offsetFinal = new Point(offset.x + item.offsetX, offset.y + item.offsetY);\n              const flipMatrix = new Matrix();\n              let x = 1;\n              let y = 1;\n              let translateX = 0;\n              let translateY = 0;\n\n              if (item.flipH) {\n                x = -1;\n                translateX = assetTexture.width;\n              }\n\n              if (item.flipV) {\n                y = -1;\n                translateY = assetTexture.height;\n              }\n\n              let offsetX = offsetFinal.x + translateX;\n              offsetX = offsetX >> 1 << 1;\n              flipMatrix.scale(x, y);\n              flipMatrix.translate(offsetX, offsetFinal.y + translateY);\n              const sprite = new NitroSprite(assetTexture);\n              sprite.transform.setFromMatrix(flipMatrix);\n              sprite.x = flipMatrix.tx;\n              sprite.y = flipMatrix.ty;\n\n              this._cachedSprite.addChild(sprite);\n            }\n          }\n\n          i++;\n        }\n\n        return this._cachedSprite;\n      }\n\n      return bitmap;\n    }\n\n    return null;\n  }\n\n  getAssetName(normal) {\n    return this._texture == null ? null : this._texture.getAssetName(normal);\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/rasterizer/basic/PlaneMaterialCell.ts"],"names":["Matrix","Point","NitroSprite","Randomizer","PlaneMaterialCell","constructor","texture","assets","offsetPoints","limit","_cachedSprite","_texture","_extraItemOffsets","_extraItemAssets","_extraItemCount","length","assetIndex","graphic","push","pointIndex","point","x","y","isStatic","dispose","destroy","clearCache","getHeight","normal","getBitmap","height","render","textureOffsetX","textureOffsetY","bitmap","width","anchor","scale","limitMin","Math","min","limitMax","max","offsetIndexes","getArray","i","offset","item","assetTexture","offsetFinal","offsetX","offsetY","flipMatrix","translateX","translateY","flipH","flipV","translate","sprite","transform","setFromMatrix","tx","ty","addChild","getAssetName"],"mappings":"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","sourcesContent":["import { Matrix, Point } from '@pixi/math';\r\nimport { NitroSprite } from '../../../../../../../core';\r\nimport { IGraphicAsset } from '../../../../../../../room/object/visualization/utils/IGraphicAsset';\r\nimport { IVector3D } from '../../../../../../../room/utils/IVector3D';\r\nimport { Randomizer } from '../../utils';\r\nimport { PlaneTexture } from './PlaneTexture';\r\n\r\nexport class PlaneMaterialCell\r\n{\r\n    private _cachedSprite: NitroSprite;\r\n    private _texture: PlaneTexture;\r\n    private _extraItemOffsets: Point[];\r\n    private _extraItemAssets: IGraphicAsset[];\r\n    private _extraItemCount: number = 0;\r\n\r\n    constructor(texture: PlaneTexture, assets: IGraphicAsset[] = null, offsetPoints: Point[] = null, limit: number = 0)\r\n    {\r\n        this._cachedSprite = null;\r\n        this._texture = texture;\r\n        this._extraItemOffsets = [];\r\n        this._extraItemAssets = [];\r\n        this._extraItemCount = 0;\r\n\r\n        if(assets && assets.length && (limit > 0))\r\n        {\r\n            let assetIndex = 0;\r\n\r\n            while(assetIndex < assets.length)\r\n            {\r\n                const graphic = assets[assetIndex];\r\n\r\n                if(graphic) this._extraItemAssets.push(graphic);\r\n\r\n                assetIndex++;\r\n            }\r\n\r\n            if(this._extraItemAssets.length)\r\n            {\r\n                if(offsetPoints)\r\n                {\r\n                    let pointIndex = 0;\r\n\r\n                    while(pointIndex < offsetPoints.length)\r\n                    {\r\n                        const point = offsetPoints[pointIndex];\r\n\r\n                        if(point) this._extraItemOffsets.push(new Point(point.x, point.y));\r\n\r\n                        pointIndex++;\r\n                    }\r\n                }\r\n\r\n                this._extraItemCount = limit;\r\n            }\r\n        }\r\n    }\r\n\r\n    public get isStatic(): boolean\r\n    {\r\n        return this._extraItemCount == 0;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._texture)\r\n        {\r\n            this._texture.dispose();\r\n\r\n            this._texture = null;\r\n        }\r\n\r\n        if(this._cachedSprite)\r\n        {\r\n            this._cachedSprite.destroy();\r\n\r\n            this._cachedSprite = null;\r\n        }\r\n\r\n        this._extraItemAssets = null;\r\n        this._extraItemOffsets = null;\r\n        this._extraItemCount = 0;\r\n    }\r\n\r\n    public clearCache(): void\r\n    {\r\n        if(this._cachedSprite)\r\n        {\r\n            this._cachedSprite.destroy();\r\n\r\n            this._cachedSprite = null;\r\n        }\r\n    }\r\n\r\n    public getHeight(normal: IVector3D): number\r\n    {\r\n        if(this._texture)\r\n        {\r\n            const texture = this._texture.getBitmap(normal);\r\n\r\n            if(texture) return texture.height;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public render(normal: IVector3D, textureOffsetX: number, textureOffsetY: number): NitroSprite\r\n    {\r\n        if(!this._texture) return null;\r\n\r\n        const texture = this._texture.getBitmap(normal);\r\n\r\n        if(!texture) return null;\r\n\r\n        const bitmap = new NitroSprite(texture);\r\n\r\n        if((textureOffsetX !== 0) || (textureOffsetY !== 0))\r\n        {\r\n            while(textureOffsetX < 0) textureOffsetX += texture.width;\r\n\r\n            while(textureOffsetY < 0) textureOffsetY += texture.height;\r\n\r\n            bitmap.x = (textureOffsetX % texture.width);\r\n            bitmap.y = (textureOffsetY % texture.height);\r\n\r\n            if(textureOffsetX)\r\n            {\r\n                bitmap.anchor.x = 1;\r\n                bitmap.scale.x = -1;\r\n            }\r\n\r\n            if(textureOffsetY)\r\n            {\r\n                bitmap.anchor.y = 1;\r\n                bitmap.scale.y = -1;\r\n            }\r\n        }\r\n\r\n        if(bitmap)\r\n        {\r\n            if(!this.isStatic)\r\n            {\r\n                if(this._cachedSprite)\r\n                {\r\n                    if((this._cachedSprite.width !== bitmap.width) || (this._cachedSprite.height !== bitmap.height))\r\n                    {\r\n                        this._cachedSprite.destroy();\r\n\r\n                        this._cachedSprite = null;\r\n                    }\r\n                }\r\n\r\n                if(!this._cachedSprite)\r\n                {\r\n                    this._cachedSprite = new NitroSprite(texture);\r\n                }\r\n\r\n                const limitMin = Math.min(this._extraItemCount, this._extraItemOffsets.length);\r\n                const limitMax = Math.max(this._extraItemCount, this._extraItemOffsets.length);\r\n                const offsetIndexes = Randomizer.getArray(this._extraItemCount, limitMax);\r\n\r\n                let i = 0;\r\n\r\n                while(i < limitMin)\r\n                {\r\n                    const offset = this._extraItemOffsets[offsetIndexes[i]];\r\n                    const item = this._extraItemAssets[(i % this._extraItemAssets.length)];\r\n\r\n                    if(offset && item)\r\n                    {\r\n                        const assetTexture = item.texture;\r\n\r\n                        if(assetTexture)\r\n                        {\r\n                            const offsetFinal = new Point((offset.x + item.offsetX), (offset.y + item.offsetY));\r\n                            const flipMatrix = new Matrix();\r\n\r\n                            let x = 1;\r\n                            let y = 1;\r\n                            let translateX = 0;\r\n                            let translateY = 0;\r\n\r\n                            if(item.flipH)\r\n                            {\r\n                                x = -1;\r\n                                translateX = assetTexture.width;\r\n                            }\r\n\r\n                            if(item.flipV)\r\n                            {\r\n                                y = -1;\r\n                                translateY = assetTexture.height;\r\n                            }\r\n\r\n                            let offsetX = (offsetFinal.x + translateX);\r\n                            offsetX = ((offsetX >> 1) << 1);\r\n\r\n                            flipMatrix.scale(x, y);\r\n                            flipMatrix.translate(offsetX, (offsetFinal.y + translateY));\r\n\r\n                            const sprite = new NitroSprite(assetTexture);\r\n\r\n                            sprite.transform.setFromMatrix(flipMatrix);\r\n\r\n                            sprite.x = flipMatrix.tx;\r\n                            sprite.y = flipMatrix.ty;\r\n\r\n                            this._cachedSprite.addChild(sprite);\r\n                        }\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n\r\n                return this._cachedSprite;\r\n            }\r\n\r\n            return bitmap;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public getAssetName(normal:IVector3D): string\r\n    {\r\n        return (this._texture == null) ? null : this._texture.getAssetName(normal);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}