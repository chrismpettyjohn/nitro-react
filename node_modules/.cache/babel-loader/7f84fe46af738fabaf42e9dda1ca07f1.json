{"ast":null,"code":"import { NitroBaseTexture, NitroFilter } from './proxy';\nconst vertex = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`;\nconst fragment = `\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D lut;\nuniform int channel;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec4 adjusted = currentColor;\n\n    if(currentColor.a > 0.0)\n    {\n        if(channel == 0)\n        {\n            adjusted = texture2D(lut, vec2((currentColor.r * 255.0 + 0.5) / 256.0, 0.5));\n        } else if(channel == 1) {\n            adjusted = texture2D(lut, vec2((currentColor.g * 255.0 + 0.5) / 256.0, 0.5));\n        } else if(channel == 2) {\n            adjusted = texture2D(lut, vec2((currentColor.b * 255.0 + 0.5) / 256.0, 0.5));\n        } else if(channel == 3) {\n            adjusted = texture2D(lut, vec2((currentColor.a * 255.0 + 0.5) / 256.0, 0.5));\n        }\n    }\n\n    gl_FragColor = vec4(adjusted.r, adjusted.g, adjusted.b, currentColor.a);\n}`;\nexport class PaletteMapFilter extends NitroFilter {\n  constructor(palette) {\n    let channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PaletteMapFilter.CHANNEL_RED;\n    super(vertex, fragment);\n    this._lut = void 0;\n    this._channel = void 0;\n    this._channel = channel;\n    let lut = [];\n    lut = this.getLutForPalette(palette);\n    this._lut = NitroBaseTexture.fromBuffer(Uint8Array.from(lut), lut.length / 4, 1, {\n      mipmap: 0,\n      scaleMode: 0\n    });\n    this.uniforms.lut = this._lut;\n    this.uniforms.channel = this._channel;\n  }\n\n  getLutForPalette(data) {\n    const lut = [];\n\n    for (let i = 0; i < data.length; i++) {\n      // R\n      lut[i * 4 + PaletteMapFilter.CHANNEL_RED] = data[i] >> 16 & 0xFF; // G\n\n      lut[i * 4 + PaletteMapFilter.CHANNEL_GREEN] = data[i] >> 8 & 0xFF; // B\n\n      lut[i * 4 + PaletteMapFilter.CHANNEL_BLUE] = data[i] & 0xFF; // A\n\n      lut[i * 4 + PaletteMapFilter.CHANNEL_ALPHA] = data[i] >> 24 & 0xFF;\n    }\n\n    return lut;\n  }\n\n  get lut() {\n    return this._lut;\n  }\n\n  get channel() {\n    return this._channel;\n  }\n\n}\nPaletteMapFilter.CHANNEL_RED = 0;\nPaletteMapFilter.CHANNEL_GREEN = 1;\nPaletteMapFilter.CHANNEL_BLUE = 2;\nPaletteMapFilter.CHANNEL_ALPHA = 3;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/core/utils/PaletteMapFilter.ts"],"names":["NitroBaseTexture","NitroFilter","vertex","fragment","PaletteMapFilter","constructor","palette","channel","CHANNEL_RED","_lut","_channel","lut","getLutForPalette","fromBuffer","Uint8Array","from","length","mipmap","scaleMode","uniforms","data","i","CHANNEL_GREEN","CHANNEL_BLUE","CHANNEL_ALPHA"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,SAA9C;AAEA,MAAMC,MAAM,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EATA;AAWA,MAAMC,QAAQ,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAzBA;AA2BA,OAAO,MAAMC,gBAAN,SAA+BH,WAA/B,CACP;AASII,EAAAA,WAAW,CAACC,OAAD,EACX;AAAA,QAD+BC,OAC/B,uEADyCH,gBAAgB,CAACI,WAC1D;AACI,UAAMN,MAAN,EAAcC,QAAd;AADJ,SAJQM,IAIR;AAAA,SAHQC,QAGR;AAEI,SAAKA,QAAL,GAAgBH,OAAhB;AACA,QAAII,GAAa,GAAG,EAApB;AAEAA,IAAAA,GAAG,GAAG,KAAKC,gBAAL,CAAsBN,OAAtB,CAAN;AAEA,SAAKG,IAAL,GAAYT,gBAAgB,CAACa,UAAjB,CAA4BC,UAAU,CAACC,IAAX,CAAgBJ,GAAhB,CAA5B,EAAkDA,GAAG,CAACK,MAAJ,GAAa,CAA/D,EAAkE,CAAlE,EAAqE;AAAEC,MAAAA,MAAM,EAAE,CAAV;AAAaC,MAAAA,SAAS,EAAE;AAAxB,KAArE,CAAZ;AAEA,SAAKC,QAAL,CAAcR,GAAd,GAAoB,KAAKF,IAAzB;AACA,SAAKU,QAAL,CAAcZ,OAAd,GAAwB,KAAKG,QAA7B;AACH;;AAEOE,EAAAA,gBAAgB,CAACQ,IAAD,EACxB;AACI,UAAMT,GAAG,GAAG,EAAZ;;AAEA,SAAI,IAAIU,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,IAAI,CAACJ,MAAxB,EAAgCK,CAAC,EAAjC,EACA;AACI;AACAV,MAAAA,GAAG,CAAEU,CAAC,GAAG,CAAL,GAAUjB,gBAAgB,CAACI,WAA5B,CAAH,GAAgDY,IAAI,CAACC,CAAD,CAAJ,IAAW,EAAZ,GAAkB,IAAjE,CAFJ,CAGI;;AACAV,MAAAA,GAAG,CAAEU,CAAC,GAAG,CAAL,GAAUjB,gBAAgB,CAACkB,aAA5B,CAAH,GAAkDF,IAAI,CAACC,CAAD,CAAJ,IAAW,CAAZ,GAAiB,IAAlE,CAJJ,CAKI;;AACAV,MAAAA,GAAG,CAAEU,CAAC,GAAG,CAAL,GAAUjB,gBAAgB,CAACmB,YAA5B,CAAH,GAAgDH,IAAI,CAACC,CAAD,CAAJ,GAAU,IAA1D,CANJ,CAOI;;AACAV,MAAAA,GAAG,CAAEU,CAAC,GAAG,CAAL,GAAUjB,gBAAgB,CAACoB,aAA5B,CAAH,GAAkDJ,IAAI,CAACC,CAAD,CAAJ,IAAW,EAAZ,GAAkB,IAAnE;AACH;;AAED,WAAOV,GAAP;AACH;;AAEa,MAAHA,GAAG,GACd;AACI,WAAO,KAAKF,IAAZ;AACH;;AAEiB,MAAPF,OAAO,GAClB;AACI,WAAO,KAAKG,QAAZ;AACH;;AAlDL;AADaN,gB,CAEcI,W,GAAc,C;AAF5BJ,gB,CAGckB,a,GAAgB,C;AAH9BlB,gB,CAIcmB,Y,GAAe,C;AAJ7BnB,gB,CAKcoB,a,GAAgB,C","sourcesContent":["import { NitroBaseTexture, NitroFilter } from './proxy';\r\n\r\nconst vertex = `\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nuniform mat3 projectionMatrix;\r\nvarying vec2 vTextureCoord;\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}`;\r\n\r\nconst fragment = `\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D lut;\r\nuniform int channel;\r\n\r\nvoid main(void) {\r\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\r\n    vec4 adjusted = currentColor;\r\n\r\n    if(currentColor.a > 0.0)\r\n    {\r\n        if(channel == 0)\r\n        {\r\n            adjusted = texture2D(lut, vec2((currentColor.r * 255.0 + 0.5) / 256.0, 0.5));\r\n        } else if(channel == 1) {\r\n            adjusted = texture2D(lut, vec2((currentColor.g * 255.0 + 0.5) / 256.0, 0.5));\r\n        } else if(channel == 2) {\r\n            adjusted = texture2D(lut, vec2((currentColor.b * 255.0 + 0.5) / 256.0, 0.5));\r\n        } else if(channel == 3) {\r\n            adjusted = texture2D(lut, vec2((currentColor.a * 255.0 + 0.5) / 256.0, 0.5));\r\n        }\r\n    }\r\n\r\n    gl_FragColor = vec4(adjusted.r, adjusted.g, adjusted.b, currentColor.a);\r\n}`;\r\n\r\nexport class PaletteMapFilter extends NitroFilter\r\n{\r\n    public static readonly CHANNEL_RED = 0;\r\n    public static readonly CHANNEL_GREEN = 1;\r\n    public static readonly CHANNEL_BLUE = 2;\r\n    public static readonly CHANNEL_ALPHA = 3;\r\n\r\n    private _lut: NitroBaseTexture;\r\n    private _channel: number;\r\n\r\n    constructor(palette: number[], channel = PaletteMapFilter.CHANNEL_RED)\r\n    {\r\n        super(vertex, fragment);\r\n        this._channel = channel;\r\n        let lut: number[] = [];\r\n\r\n        lut = this.getLutForPalette(palette);\r\n\r\n        this._lut = NitroBaseTexture.fromBuffer(Uint8Array.from(lut), lut.length / 4, 1, { mipmap: 0, scaleMode: 0 });\r\n\r\n        this.uniforms.lut = this._lut;\r\n        this.uniforms.channel = this._channel;\r\n    }\r\n\r\n    private getLutForPalette(data: number[]): number[]\r\n    {\r\n        const lut = [];\r\n\r\n        for(let i = 0; i < data.length; i++)\r\n        {\r\n            // R\r\n            lut[(i * 4) + PaletteMapFilter.CHANNEL_RED] = ((data[i] >> 16) & 0xFF);\r\n            // G\r\n            lut[(i * 4) + PaletteMapFilter.CHANNEL_GREEN] = ((data[i] >> 8) & 0xFF);\r\n            // B\r\n            lut[(i * 4) + PaletteMapFilter.CHANNEL_BLUE] = (data[i] & 0xFF);\r\n            // A\r\n            lut[(i * 4) + PaletteMapFilter.CHANNEL_ALPHA] = ((data[i] >> 24) & 0xFF);\r\n        }\r\n\r\n        return lut;\r\n    }\r\n\r\n    public get lut(): NitroBaseTexture\r\n    {\r\n        return this._lut;\r\n    }\r\n\r\n    public get channel(): number\r\n    {\r\n        return this._channel;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}