{"ast":null,"code":"import { GetRoomEngine } from '../nitro';\nimport { FurniCategory } from './FurniCategory';\nimport { GroupItem } from './GroupItem';\nexport const createGroupItem = function (type, category, stuffData) {\n  let extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;\n  return new GroupItem(type, category, GetRoomEngine(), stuffData, extra);\n};\n\nconst addSingleFurnitureItem = (set, item, unseen) => {\n  const groupItems = [];\n\n  for (const groupItem of set) {\n    if (groupItem.type === item.type) groupItems.push(groupItem);\n  }\n\n  for (const groupItem of groupItems) {\n    if (groupItem.getItemById(item.id)) return groupItem;\n  }\n\n  const groupItem = createGroupItem(item.type, item.category, item.stuffData, item.extra);\n  groupItem.push(item);\n\n  if (unseen) {\n    groupItem.hasUnseenItems = true;\n    set.unshift(groupItem);\n  } else {\n    set.push(groupItem);\n  }\n\n  return groupItem;\n};\n\nconst addGroupableFurnitureItem = (set, item, unseen) => {\n  let existingGroup = null;\n\n  for (const groupItem of set) {\n    if (groupItem.type === item.type && groupItem.isWallItem === item.isWallItem && groupItem.isGroupable) {\n      if (item.category === FurniCategory.POSTER) {\n        if (groupItem.stuffData.getLegacyString() === item.stuffData.getLegacyString()) {\n          existingGroup = groupItem;\n          break;\n        }\n      } else if (item.category === FurniCategory.GUILD_FURNI) {\n        if (item.stuffData.compare(groupItem.stuffData)) {\n          existingGroup = groupItem;\n          break;\n        }\n      } else {\n        existingGroup = groupItem;\n        break;\n      }\n    }\n  }\n\n  if (existingGroup) {\n    existingGroup.push(item);\n\n    if (unseen) {\n      existingGroup.hasUnseenItems = true;\n      const index = set.indexOf(existingGroup);\n      if (index >= 0) set.splice(index, 1);\n      set.unshift(existingGroup);\n    }\n\n    return existingGroup;\n  }\n\n  existingGroup = createGroupItem(item.type, item.category, item.stuffData, item.extra);\n  existingGroup.push(item);\n\n  if (unseen) {\n    existingGroup.hasUnseenItems = true;\n    set.unshift(existingGroup);\n  } else {\n    set.push(existingGroup);\n  }\n\n  return existingGroup;\n};\n\nexport const addFurnitureItem = (set, item, unseen) => {\n  if (!item.isGroupable) {\n    addSingleFurnitureItem(set, item, unseen);\n  } else {\n    addGroupableFurnitureItem(set, item, unseen);\n  }\n};\nexport const mergeFurniFragments = (fragment, totalFragments, fragmentNumber, fragments) => {\n  if (totalFragments === 1) return fragment;\n  fragments[fragmentNumber] = fragment;\n\n  for (const frag of fragments) {\n    if (!frag) return null;\n  }\n\n  const merged = new Map();\n\n  for (const frag of fragments) {\n    for (const [key, value] of frag) merged.set(key, value);\n\n    frag.clear();\n  }\n\n  fragments = null;\n  return merged;\n};\nexport const getAllItemIds = groupItems => {\n  const itemIds = [];\n\n  for (const groupItem of groupItems) {\n    let totalCount = groupItem.getTotalCount();\n    if (groupItem.category === FurniCategory.POST_IT) totalCount = 1;\n    let i = 0;\n\n    while (i < totalCount) {\n      itemIds.push(groupItem.getItemByIndex(i).id);\n      i++;\n    }\n  }\n\n  return itemIds;\n};","map":{"version":3,"sources":["/var/www/game.bobba.ca/src/api/inventory/FurnitureUtilities.ts"],"names":["GetRoomEngine","FurniCategory","GroupItem","createGroupItem","type","category","stuffData","extra","NaN","addSingleFurnitureItem","set","item","unseen","groupItems","groupItem","push","getItemById","id","hasUnseenItems","unshift","addGroupableFurnitureItem","existingGroup","isWallItem","isGroupable","POSTER","getLegacyString","GUILD_FURNI","compare","index","indexOf","splice","addFurnitureItem","mergeFurniFragments","fragment","totalFragments","fragmentNumber","fragments","frag","merged","Map","key","value","clear","getAllItemIds","itemIds","totalCount","getTotalCount","POST_IT","i","getItemByIndex"],"mappings":"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","sourcesContent":["import { FurnitureListItemParser, IObjectData } from '@nitrots/nitro-renderer';\nimport { GetRoomEngine } from '../nitro';\nimport { FurniCategory } from './FurniCategory';\nimport { FurnitureItem } from './FurnitureItem';\nimport { GroupItem } from './GroupItem';\n\nexport const createGroupItem = (type: number, category: number, stuffData: IObjectData, extra: number = NaN) => new GroupItem(type, category, GetRoomEngine(), stuffData, extra);\n\nconst addSingleFurnitureItem = (set: GroupItem[], item: FurnitureItem, unseen: boolean) =>\n{\n    const groupItems: GroupItem[] = [];\n\n    for(const groupItem of set)\n    {\n        if(groupItem.type === item.type) groupItems.push(groupItem);\n    }\n\n    for(const groupItem of groupItems)\n    {\n        if(groupItem.getItemById(item.id)) return groupItem;\n    }\n\n    const groupItem = createGroupItem(item.type, item.category, item.stuffData, item.extra);\n\n    groupItem.push(item);\n\n    if(unseen)\n    {\n        groupItem.hasUnseenItems = true;\n\n        set.unshift(groupItem);\n    }\n    else\n    {\n        set.push(groupItem);\n    }\n\n    return groupItem;\n}\n\nconst addGroupableFurnitureItem = (set: GroupItem[], item: FurnitureItem, unseen: boolean) =>\n{\n    let existingGroup: GroupItem = null;\n\n    for(const groupItem of set)\n    {\n        if((groupItem.type === item.type) && (groupItem.isWallItem === item.isWallItem) && groupItem.isGroupable)\n        {\n            if(item.category === FurniCategory.POSTER)\n            {\n                if(groupItem.stuffData.getLegacyString() === item.stuffData.getLegacyString())\n                {\n                    existingGroup = groupItem;\n\n                    break;\n                }\n            }\n\n            else if(item.category === FurniCategory.GUILD_FURNI)\n            {\n                if(item.stuffData.compare(groupItem.stuffData))\n                {\n                    existingGroup = groupItem;\n\n                    break;\n                }\n            }\n\n            else\n            {\n                existingGroup = groupItem;\n\n                break;\n            }\n        }\n    }\n\n    if(existingGroup)\n    {\n        existingGroup.push(item);\n\n        if(unseen)\n        {\n            existingGroup.hasUnseenItems = true;\n\n            const index = set.indexOf(existingGroup);\n\n            if(index >= 0) set.splice(index, 1);\n            \n            set.unshift(existingGroup);\n        }\n\n        return existingGroup;\n    }\n\n    existingGroup = createGroupItem(item.type, item.category, item.stuffData, item.extra);\n\n    existingGroup.push(item);\n\n    if(unseen)\n    {\n        existingGroup.hasUnseenItems = true;\n\n        set.unshift(existingGroup);\n    }\n    else\n    {\n        set.push(existingGroup);\n    }\n\n    return existingGroup;\n}\n\nexport const addFurnitureItem = (set: GroupItem[], item: FurnitureItem, unseen: boolean) =>\n{\n    if(!item.isGroupable)\n    {\n        addSingleFurnitureItem(set, item, unseen);\n    }\n    else\n    {\n        addGroupableFurnitureItem(set, item, unseen);\n    }\n}\n\nexport const mergeFurniFragments = (fragment: Map<number, FurnitureListItemParser>, totalFragments: number, fragmentNumber: number, fragments: Map<number, FurnitureListItemParser>[]) =>\n{\n    if(totalFragments === 1) return fragment;\n\n    fragments[fragmentNumber] = fragment;\n\n    for(const frag of fragments)\n    {\n        if(!frag) return null;\n    }\n\n    const merged: Map<number, FurnitureListItemParser> = new Map();\n\n    for(const frag of fragments)\n    {\n        for(const [ key, value ] of frag) merged.set(key, value);\n\n        frag.clear();\n    }\n\n    fragments = null;\n\n    return merged;\n}\n\nexport const getAllItemIds = (groupItems: GroupItem[]) =>\n{\n    const itemIds: number[] = [];\n\n    for(const groupItem of groupItems)\n    {\n        let totalCount = groupItem.getTotalCount();\n\n        if(groupItem.category === FurniCategory.POST_IT) totalCount = 1;\n\n        let i = 0;\n\n        while(i < totalCount)\n        {\n            itemIds.push(groupItem.getItemByIndex(i).id);\n\n            i++;\n        }\n    }\n\n    return itemIds;\n}\n"]},"metadata":{},"sourceType":"module"}