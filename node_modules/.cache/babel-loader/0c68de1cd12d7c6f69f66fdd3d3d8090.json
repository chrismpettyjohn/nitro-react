{"ast":null,"code":"import { Texture } from '@pixi/core';\nimport { Graphics } from '@pixi/graphics';\nimport { Matrix, Point, Rectangle } from '@pixi/math';\nimport { TextureUtils } from '../../../../../room/utils/TextureUtils';\nimport { Vector3d } from '../../../../../room/utils/Vector3d';\nimport { PlaneDrawingData } from './PlaneDrawingData';\nimport { RoomPlaneBitmapMask } from './RoomPlaneBitmapMask';\nimport { RoomPlaneRectangleMask } from './RoomPlaneRectangleMask';\nimport { RoomVisualization } from './RoomVisualization';\nimport { PlaneBitmapData } from './utils/PlaneBitmapData';\nimport { Randomizer } from './utils/Randomizer';\nexport class RoomPlane {\n  constructor(origin, location, leftSide, rightSide, type, usesMask, secondaryNormals, randomSeed) {\n    let textureOffsetX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let textureOffsetY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let textureMaxX = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    let textureMaxY = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;\n    this._disposed = void 0;\n    this._randomSeed = void 0;\n    this._origin = void 0;\n    this._location = void 0;\n    this._leftSide = void 0;\n    this._rightSide = void 0;\n    this._normal = void 0;\n    this._secondaryNormals = void 0;\n    this._geometryUpdateId = void 0;\n    this._type = void 0;\n    this._isVisible = void 0;\n    this._bitmapTexture = void 0;\n    this._bitmapData = void 0;\n    this._hasTexture = void 0;\n    this._offset = void 0;\n    this._relativeDepth = void 0;\n    this._color = void 0;\n    this._rasterizer = void 0;\n    this._maskManager = null;\n    this._id = void 0;\n    this._uniqueId = void 0;\n    this._textureOffsetX = void 0;\n    this._textureOffsetY = void 0;\n    this._textureMaxX = void 0;\n    this._textureMaxY = void 0;\n    this._textures = void 0;\n    this._activeTexture = void 0;\n    this._useMask = void 0;\n    this._bitmapMasks = void 0;\n    this._rectangleMasks = void 0;\n    this._maskChanged = void 0;\n    this._maskBitmapData = void 0;\n    this._bitmapMasksOld = void 0;\n    this._rectangleMasksOld = void 0;\n    this._cornerA = void 0;\n    this._cornerB = void 0;\n    this._cornerC = void 0;\n    this._cornerD = void 0;\n    this._width = 0;\n    this._height = 0;\n    this._canBeVisible = void 0;\n    this._secondaryNormals = [];\n    this._bitmapMasks = [];\n    this._rectangleMasks = [];\n    this._bitmapMasksOld = [];\n    this._rectangleMasksOld = [];\n    this._randomSeed = randomSeed;\n    this._bitmapData = null;\n    this._maskBitmapData = null;\n    this._maskChanged = false;\n    this._activeTexture = null;\n    this._origin = new Vector3d();\n\n    this._origin.assign(origin);\n\n    this._location = new Vector3d();\n\n    this._location.assign(location);\n\n    this._leftSide = new Vector3d();\n\n    this._leftSide.assign(leftSide);\n\n    this._rightSide = new Vector3d();\n\n    this._rightSide.assign(rightSide);\n\n    this._normal = Vector3d.crossProduct(this._leftSide, this._rightSide);\n\n    if (this._normal.length > 0) {\n      this._normal.multiply(1 / this._normal.length);\n    }\n\n    if (secondaryNormals != null) {\n      for (const entry of secondaryNormals) {\n        if (!entry) continue;\n        const vector = new Vector3d();\n        vector.assign(entry);\n\n        this._secondaryNormals.push(vector);\n      }\n    }\n\n    this._disposed = false;\n    this._isVisible = false;\n    this._id = null;\n    this._hasTexture = true;\n    this._geometryUpdateId = -1;\n    this._offset = new Point();\n    this._relativeDepth = 0;\n    this._type = type;\n    this._color = 0;\n    this._rasterizer = null;\n    this._canBeVisible = true;\n    this._textures = new Map();\n    this._cornerA = new Vector3d();\n    this._cornerB = new Vector3d();\n    this._cornerC = new Vector3d();\n    this._cornerD = new Vector3d();\n    this._width = 0;\n    this._height = 0;\n    this._textureOffsetX = textureOffsetX;\n    this._textureOffsetY = textureOffsetY;\n    this._textureMaxX = textureMaxX;\n    this._textureMaxY = textureMaxY;\n    this._useMask = usesMask;\n    this._uniqueId = ++RoomPlane._uniqueIdCounter;\n  }\n\n  static blend(k, _arg_2) {\n    return 0; //return Canvas.colorize(_arg_2, (k | 0xFF000000)) & 0xFFFFFF;\n  }\n\n  set canBeVisible(k) {\n    if (k !== this._canBeVisible) {\n      if (!this._canBeVisible) this.resetTextureCache();\n      this._canBeVisible = k;\n    }\n  }\n\n  get canBeVisible() {\n    return this._canBeVisible;\n  }\n\n  get bitmapData() {\n    if (!this.visible || !this._bitmapData) return null;\n    let texture = RoomVisualization.getTextureCache(this._bitmapData);\n\n    if (!texture) {\n      texture = TextureUtils.generateTexture(this._bitmapData, new Rectangle(0, 0, this._width, this._height));\n      RoomVisualization.addTextureCache(this._bitmapData, texture);\n    }\n\n    return texture;\n  }\n\n  get visible() {\n    return this._isVisible && this._canBeVisible;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get relativeDepth() {\n    return this._relativeDepth;\n  }\n\n  get color() {\n    return this._color;\n  }\n\n  set color(k) {\n    this._color = k;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get leftSide() {\n    return this._leftSide;\n  }\n\n  get rightSide() {\n    return this._rightSide;\n  }\n\n  get location() {\n    return this._location;\n  }\n\n  get normal() {\n    return this._normal;\n  }\n\n  get hasTexture() {\n    return this._hasTexture;\n  }\n\n  set hasTexture(k) {\n    this._hasTexture = k;\n  }\n\n  set rasterizer(k) {\n    this._rasterizer = k;\n  }\n\n  set maskManager(k) {\n    this._maskManager = k;\n  }\n\n  set id(k) {\n    if (k === this._id) return;\n    this.resetTextureCache();\n    this._id = k;\n  }\n\n  get uniqueId() {\n    return this._uniqueId;\n  }\n\n  dispose() {\n    if (this._bitmapData) {\n      this._bitmapData.destroy();\n\n      this._bitmapData = null;\n    }\n\n    if (this._textures) {\n      for (const bitmap of this._textures.values()) {\n        if (!bitmap) continue;\n        if (bitmap.bitmap) bitmap.bitmap.destroy();\n        bitmap.dispose();\n      }\n\n      this._textures = null;\n    }\n\n    this._activeTexture = null;\n    this._location = null;\n    this._origin = null;\n    this._leftSide = null;\n    this._rightSide = null;\n    this._normal = null;\n    this._rasterizer = null;\n    this._cornerA = null;\n    this._cornerB = null;\n    this._cornerC = null;\n    this._cornerD = null;\n    this._bitmapMasks = null;\n    this._rectangleMasks = null;\n\n    if (this._maskBitmapData) {\n      this._maskBitmapData.destroy();\n\n      this._maskBitmapData = null;\n    }\n\n    this._disposed = true;\n  }\n\n  copyBitmapData(k) {\n    if (!this.visible || !this._bitmapData || !k) return null;\n    if (this._bitmapData.width !== k.width || this._bitmapData.height !== k.height) return null; //k.copyPixels(this._bitmapData, this._bitmapData.rect, RoomPlane.ZERO_POINT);\n\n    return k;\n  }\n\n  cacheTexture(k, _arg_2) {\n    const existing = this._textures.get(k);\n\n    if (existing) {\n      this._textures.delete(k);\n\n      existing.dispose();\n    }\n\n    this._activeTexture = _arg_2;\n\n    this._textures.set(k, _arg_2);\n\n    return true;\n  }\n\n  resetTextureCache() {\n    let k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (this._textures && this._textures.size) {\n      for (const bitmap of this._textures.values()) {\n        if (!bitmap) continue;\n        bitmap.dispose();\n      }\n\n      this._textures.clear();\n    }\n\n    this._activeTexture = null;\n  }\n\n  getTextureIdentifier(k) {\n    if (this._rasterizer) return this._rasterizer.getTextureIdentifier(k, this.normal);\n    return k.toString();\n  }\n\n  needsNewTexture(k, _arg_2) {\n    if (!k) return false;\n    let planeBitmap = this._activeTexture;\n\n    if (!planeBitmap) {\n      planeBitmap = this._textures.get(this.getTextureIdentifier(k.scale));\n    }\n\n    this.updateMaskChangeStatus();\n    if (this._canBeVisible && (!planeBitmap || planeBitmap.timeStamp >= 0 && _arg_2 > planeBitmap.timeStamp || this._maskChanged)) return true;\n    return false;\n  }\n\n  getTexture(k, _arg_2) {\n    if (!k) return null;\n    let _local_3 = null;\n\n    if (this.needsNewTexture(k, _arg_2)) {\n      const _local_4 = this.getTextureIdentifier(k.scale);\n\n      const _local_5 = this._leftSide.length * k.scale;\n\n      const _local_6 = this._rightSide.length * k.scale;\n\n      const _local_7 = k.getCoordinatePosition(this._normal);\n\n      if (this._activeTexture) {\n        _local_3 = this._activeTexture;\n      } else {\n        _local_3 = this._textures.get(_local_4);\n      }\n\n      let _local_8 = null;\n      if (_local_3) _local_8 = _local_3.bitmap;\n\n      if (this._rasterizer) {\n        _local_3 = this._rasterizer.render(_local_8, this._id, _local_5, _local_6, k.scale, _local_7, this._hasTexture, this._textureOffsetX, this._textureOffsetY, this._textureMaxX, this._textureMaxY, _arg_2);\n\n        if (_local_3) {\n          if (_local_8 && _local_3.bitmap !== _local_8) _local_8.destroy();\n        }\n      } else {\n        const _local_9 = new Graphics();\n\n        _local_9.beginFill(0xFFFFFF);\n\n        _local_9.drawRect(0, 0, _local_5, _local_6);\n\n        _local_9.endFill();\n\n        _local_3 = new PlaneBitmapData(_local_9, -1);\n      }\n\n      if (_local_3) {\n        this.updateMask(_local_3.bitmap, k);\n        this.cacheTexture(_local_4, _local_3);\n      }\n    } else {\n      if (this._activeTexture) {\n        _local_3 = this._activeTexture;\n      } else {\n        _local_3 = this._textures.get(this.getTextureIdentifier(k.scale));\n      }\n    }\n\n    if (_local_3) {\n      this._activeTexture = _local_3;\n      return _local_3.bitmap;\n    }\n\n    return null;\n  }\n\n  resolveMasks(k) {\n    if (!this._useMask) return null;\n\n    const _local_5 = new PlaneDrawingData();\n\n    const index = 0;\n\n    while (index < this._bitmapMasks.length) {\n      const mask = this._bitmapMasks[index];\n\n      if (mask) {\n        const planeMask = this._maskManager.getMask(mask.type);\n\n        if (planeMask) {\n          const assetName = planeMask.getAssetName(k.scale);\n\n          if (assetName) {\n            const position = k.getCoordinatePosition(this._normal);\n            const asset = planeMask.getGraphicAsset(k.scale, position);\n\n            if (asset) {\n              const _local_3 = this._maskBitmapData.width * (1 - mask.leftSideLoc / this._leftSide.length);\n\n              const _local_4 = this._maskBitmapData.height * (1 - mask.rightSideLoc / this._rightSide.length);\n\n              const _local_11 = new Point(_local_3 + asset.offsetX, _local_4 + asset.offsetY);\n\n              _local_5.addMask(assetName, _local_11, asset.flipH, asset.flipV);\n            }\n          }\n        }\n      }\n    }\n\n    return _local_5;\n  }\n\n  screenWidth(k) {\n    const _local_2 = k.getScreenPoint(new Vector3d(0, 0, 0));\n\n    const _local_3 = k.getScreenPoint(new Vector3d(0, 1, 0));\n\n    return Math.round(this._leftSide.length * Math.abs(_local_2.x - _local_3.x));\n  }\n\n  getDrawingDatas(geometry) {\n    const drawingDatas = [];\n\n    if (this._isVisible) {\n      const maskData = this.resolveMasks(geometry);\n\n      const layers = this._rasterizer.getLayers(this._id);\n\n      let i = 0;\n\n      while (i < layers.length) {\n        const layer = layers[i];\n\n        if (layer) {\n          if (this._hasTexture && layer.getMaterial()) {\n            const normal = geometry.getCoordinatePosition(this._normal);\n            const cm = layer.getMaterial().getMaterialCellMatrix(normal); //const data      = new PlaneDrawingData(maskData, blend(this._color, layer.getColor()), cm.isBottomAligned());\n\n            const data = new PlaneDrawingData(maskData, this._color, cm.isBottomAligned());\n            Randomizer.setSeed(this._randomSeed);\n\n            for (const column of cm.getColumns(this.screenWidth(geometry))) {\n              const assetNames = [];\n\n              for (const cell of column.getCells()) {\n                const name = cell.getAssetName(normal);\n                if (name) assetNames.push(name);\n              }\n\n              if (assetNames.length > 0) {\n                if (!column.isRepeated()) assetNames.push('');\n                data.addAssetColumn(assetNames);\n              }\n            }\n\n            if (data.assetNameColumns.length > 0) drawingDatas.push(data);\n          } else {\n            //data = new PlaneDrawingData(maskData, blend(this._color, layer.getColor()));\n            const data = new PlaneDrawingData(maskData, this._color);\n            drawingDatas.push(data);\n          }\n        }\n\n        i++;\n      }\n\n      if (!drawingDatas.length) drawingDatas.push(new PlaneDrawingData(maskData, this._color));\n    }\n\n    return drawingDatas;\n  } // private _Str_25956(k:PlaneBitmapData): void\n  // {\n  // }\n\n\n  update(geometry, timeSinceStartMs) {\n    if (!geometry || this._disposed) return false;\n    let geometryChanged = false;\n    if (this._geometryUpdateId != geometry.updateId) geometryChanged = true;\n\n    if (!geometryChanged || !this._canBeVisible) {\n      if (!this.visible) return false;\n    }\n\n    if (geometryChanged) {\n      this._activeTexture = null;\n      let cosAngle = 0;\n      cosAngle = Vector3d.cosAngle(geometry.directionAxis, this.normal);\n\n      if (cosAngle > -0.001) {\n        if (this._isVisible) {\n          this._isVisible = false;\n          return true;\n        }\n\n        return false;\n      }\n\n      let i = 0;\n\n      while (i < this._secondaryNormals.length) {\n        cosAngle = Vector3d.cosAngle(geometry.directionAxis, this._secondaryNormals[i]);\n\n        if (cosAngle > -0.001) {\n          if (this._isVisible) {\n            this._isVisible = false;\n            return true;\n          }\n\n          return false;\n        }\n\n        i++;\n      }\n\n      this.updateCorners(geometry);\n      const originPos = geometry.getScreenPosition(this._origin);\n      const originZ = originPos.z;\n      let relativeDepth = Math.max(this._cornerA.z, this._cornerB.z, this._cornerC.z, this._cornerD.z) - originZ;\n\n      if (this._type === RoomPlane.TYPE_FLOOR) {\n        relativeDepth = relativeDepth - (this._location.z + Math.min(0, this._leftSide.z, this._rightSide.z)) * 8;\n      }\n\n      if (this._type === RoomPlane.TYPE_LANDSCAPE) {\n        relativeDepth = relativeDepth + 0.02;\n      }\n\n      this._relativeDepth = relativeDepth;\n      this._isVisible = true;\n      this._geometryUpdateId = geometry.updateId;\n    }\n\n    if (geometryChanged || this.needsNewTexture(geometry, timeSinceStartMs)) {\n      if (!this._bitmapData || this._width !== this._bitmapData.width || this._height !== this._bitmapData.height) {\n        if (this._bitmapData) {\n          this._bitmapData.destroy();\n\n          this._bitmapData = null;\n          if (this._width < 1 || this._height < 1) return true;\n        } else {\n          if (this._width < 1 || this._height < 1) return false;\n        }\n\n        const graphic = new Graphics();\n        graphic.beginFill(0xFFFFFF, 0);\n        graphic.drawRect(0, 0, this._width, this._height);\n        graphic.endFill();\n        this._bitmapData = graphic;\n        if (!this._bitmapData) return false;\n      } else {//this._bitmapData.lock();\n        //this._bitmapData.fillRect(this._bitmapData.rect, 0xFFFFFF);\n      }\n\n      Randomizer.setSeed(this._randomSeed);\n      const texture = this.getTexture(geometry, timeSinceStartMs);\n\n      if (texture) {\n        this.renderTexture(geometry, texture);\n      } else {\n        this.dispose();\n        return false;\n      }\n\n      return texture !== null || geometryChanged;\n    }\n\n    return false;\n  }\n\n  updateCorners(k) {\n    this._cornerA.assign(k.getScreenPosition(this._location));\n\n    this._cornerB.assign(k.getScreenPosition(Vector3d.sum(this._location, this._rightSide)));\n\n    this._cornerC.assign(k.getScreenPosition(Vector3d.sum(Vector3d.sum(this._location, this._leftSide), this._rightSide)));\n\n    this._cornerD.assign(k.getScreenPosition(Vector3d.sum(this._location, this._leftSide)));\n\n    this._offset = k.getScreenPoint(this._origin);\n    this._cornerA.x = Math.round(this._cornerA.x);\n    this._cornerA.y = Math.round(this._cornerA.y);\n    this._cornerB.x = Math.round(this._cornerB.x);\n    this._cornerB.y = Math.round(this._cornerB.y);\n    this._cornerC.x = Math.round(this._cornerC.x);\n    this._cornerC.y = Math.round(this._cornerC.y);\n    this._cornerD.x = Math.round(this._cornerD.x);\n    this._cornerD.y = Math.round(this._cornerD.y);\n    this._offset.x = Math.round(this._offset.x);\n    this._offset.y = Math.round(this._offset.y);\n\n    const _local_2 = Math.min(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x);\n\n    let _local_3 = Math.max(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x);\n\n    const _local_4 = Math.min(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y);\n\n    let _local_5 = Math.max(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y);\n\n    _local_3 = _local_3 - _local_2;\n    this._offset.x = this._offset.x - _local_2;\n    this._cornerA.x = this._cornerA.x - _local_2;\n    this._cornerB.x = this._cornerB.x - _local_2;\n    this._cornerC.x = this._cornerC.x - _local_2;\n    this._cornerD.x = this._cornerD.x - _local_2;\n    _local_5 = _local_5 - _local_4;\n    this._offset.y = this._offset.y - _local_4;\n    this._cornerA.y = this._cornerA.y - _local_4;\n    this._cornerB.y = this._cornerB.y - _local_4;\n    this._cornerC.y = this._cornerC.y - _local_4;\n    this._cornerD.y = this._cornerD.y - _local_4;\n    this._width = _local_3;\n    this._height = _local_5;\n  }\n\n  renderTexture(k, _arg_2) {\n    if (this._cornerA == null || this._cornerB == null || this._cornerC == null || this._cornerD == null || _arg_2 == null || this._bitmapData == null) {\n      return;\n    }\n\n    let _local_3 = this._cornerD.x - this._cornerC.x;\n\n    let _local_4 = this._cornerD.y - this._cornerC.y;\n\n    let _local_5 = this._cornerB.x - this._cornerC.x;\n\n    let _local_6 = this._cornerB.y - this._cornerC.y;\n\n    if (this._type == RoomPlane.TYPE_WALL || this._type == RoomPlane.TYPE_LANDSCAPE) {\n      if (Math.abs(_local_5 - _arg_2.width) <= 1) {\n        _local_5 = _arg_2.width;\n      }\n\n      if (Math.abs(_local_6 - _arg_2.width) <= 1) {\n        _local_6 = _arg_2.width;\n      }\n\n      if (Math.abs(_local_3 - _arg_2.height) <= 1) {\n        _local_3 = _arg_2.height;\n      }\n\n      if (Math.abs(_local_4 - _arg_2.height) <= 1) {\n        _local_4 = _arg_2.height;\n      }\n    }\n\n    const _local_7 = _local_5 / _arg_2.width;\n\n    const _local_8 = _local_6 / _arg_2.width;\n\n    const _local_9 = _local_3 / _arg_2.height;\n\n    const _local_10 = _local_4 / _arg_2.height;\n\n    const _local_11 = new Matrix();\n\n    _local_11.a = _local_7;\n    _local_11.b = _local_8;\n    _local_11.c = _local_9;\n    _local_11.d = _local_10;\n\n    _local_11.translate(this._cornerC.x, this._cornerC.y);\n\n    this.draw(_arg_2, _local_11);\n  }\n\n  draw(k, matrix) {\n    const clone = k.clone();\n    clone.transform.setFromMatrix(matrix);\n    this._bitmapData = clone;\n  }\n\n  resetBitmapMasks() {\n    if (this._disposed || !this._useMask || !this._bitmapMasks.length) return;\n    this._maskChanged = true;\n    this._bitmapMasks = [];\n  }\n\n  addBitmapMask(k, _arg_2, _arg_3) {\n    if (!this._useMask) return false;\n    let _local_5 = 0;\n\n    while (_local_5 < this._bitmapMasks.length) {\n      const mask = this._bitmapMasks[_local_5];\n\n      if (mask) {\n        if (mask.type === k && mask.leftSideLoc === _arg_2 && mask.rightSideLoc === _arg_3) return false;\n      }\n\n      _local_5++;\n    }\n\n    const mask = new RoomPlaneBitmapMask(k, _arg_2, _arg_3);\n\n    this._bitmapMasks.push(mask);\n\n    this._maskChanged = true;\n    return true;\n  }\n\n  resetRectangleMasks() {\n    if (!this._useMask || !this._rectangleMasks.length) return;\n    this._maskChanged = true;\n    this._rectangleMasks = [];\n  }\n\n  addRectangleMask(k, _arg_2, _arg_3, _arg_4) {\n    if (this._useMask) {\n      for (const mask of this._rectangleMasks) {\n        if (!mask) continue;\n        if (mask.leftSideLoc === k && mask.rightSideLoc === _arg_2 && mask.leftSideLength === _arg_3 && mask.rightSideLength === _arg_4) return false;\n      }\n\n      const _local_5 = new RoomPlaneRectangleMask(k, _arg_2, _arg_3, _arg_4);\n\n      this._rectangleMasks.push(_local_5);\n\n      this._maskChanged = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  updateMaskChangeStatus() {\n    if (!this._maskChanged) return;\n    let _local_3 = true;\n\n    let _local_6;\n\n    if (this._bitmapMasks.length === this._bitmapMasksOld.length) {\n      for (const mask of this._bitmapMasks) {\n        if (!mask) continue;\n        _local_6 = false;\n\n        for (const plane of this._bitmapMasksOld) {\n          if (!plane) continue;\n\n          if (plane.type === mask.type && plane.leftSideLoc === mask.leftSideLoc && plane.rightSideLoc === mask.rightSideLoc) {\n            _local_6 = true;\n            break;\n          }\n        }\n\n        if (!_local_6) {\n          _local_3 = false;\n          break;\n        }\n      }\n    } else {\n      _local_3 = false;\n    }\n\n    if (this._rectangleMasks.length > this._rectangleMasksOld.length) _local_3 = false;\n    if (_local_3) this._maskChanged = false;\n  }\n\n  updateMask(texture, geometry) {\n    if (!texture || !geometry) return;\n    if (!this._useMask || !this._bitmapMasks.length && !this._rectangleMasks.length && !this._maskChanged || !this._maskManager) return;\n    const width = texture.width;\n    const height = texture.height;\n    this.updateMaskChangeStatus();\n\n    if (!this._maskBitmapData || this._maskBitmapData.width !== width || this._maskBitmapData.height !== height) {\n      if (this._maskBitmapData) {\n        this._maskBitmapData.destroy();\n\n        this._maskBitmapData = null;\n      }\n\n      const graphic = new Graphics();\n      graphic.beginFill(0xFFFFFF, 0).drawRect(0, 0, width, height).endFill();\n      this._maskBitmapData = graphic;\n      this._maskChanged = true;\n    }\n\n    if (this._maskChanged) {\n      this._bitmapMasksOld = [];\n      this._rectangleMasksOld = [];\n\n      if (this._maskBitmapData) {\n        this._maskBitmapData.beginFill(0xFFFFFF, 0).drawRect(0, 0, width, height).endFill();\n      }\n\n      this.resetTextureCache(texture);\n      const normal = geometry.getCoordinatePosition(this._normal);\n      let type = null;\n      let posX = 0;\n      let posY = 0;\n      let i = 0;\n\n      while (i < this._bitmapMasks.length) {\n        const mask = this._bitmapMasks[i];\n\n        if (mask) {\n          type = mask.type;\n          posX = this._maskBitmapData.width - this._maskBitmapData.width * mask.leftSideLoc / this._leftSide.length;\n          posY = this._maskBitmapData.height - this._maskBitmapData.height * mask.rightSideLoc / this._rightSide.length;\n\n          this._maskManager.updateMask(this._maskBitmapData, type, geometry.scale, normal, posX, posY);\n\n          this._bitmapMasksOld.push(new RoomPlaneBitmapMask(type, mask.leftSideLoc, mask.rightSideLoc));\n        }\n\n        i++;\n      }\n\n      i = 0;\n\n      while (i < this._rectangleMasks.length) {\n        const rectMask = this._rectangleMasks[i];\n\n        if (rectMask) {\n          posX = this._maskBitmapData.width - this._maskBitmapData.width * rectMask.leftSideLoc / this._leftSide.length;\n          posY = this._maskBitmapData.height - this._maskBitmapData.height * rectMask.rightSideLoc / this._rightSide.length;\n          const wd = this._maskBitmapData.width * rectMask.leftSideLength / this._leftSide.length;\n          const ht = this._maskBitmapData.height * rectMask.rightSideLength / this._rightSide.length;\n\n          this._maskBitmapData.beginFill(0xFF0000).drawRect(posX - wd, posY - ht, wd, ht).endFill();\n\n          this._rectangleMasksOld.push(new RoomPlaneRectangleMask(rectMask.leftSideLength, rectMask.rightSideLoc, rectMask.leftSideLength, rectMask.rightSideLength));\n        }\n\n        i++;\n      }\n\n      this._maskChanged = false;\n    }\n\n    this.combineTextureMask(texture, this._maskBitmapData);\n  }\n\n  combineTextureMask(texture, mask) {\n    if (!texture || !mask) return;\n    const maskCanvas = TextureUtils.generateCanvas(mask);\n    const textureCanvas = TextureUtils.generateCanvas(texture);\n    const textureCtx = textureCanvas.getContext('2d');\n    textureCtx.drawImage(maskCanvas, 0, 0);\n    const textureImageData = textureCtx.getImageData(0, 0, textureCanvas.width, textureCanvas.height);\n    const data = textureImageData.data;\n\n    for (let i = 0; i < data.length; i += 4) {\n      const red = data[i];\n      const green = data[i + 1];\n      const blue = data[i + 2];\n      const alpha = data[i + 3];\n      if (!red && !green && !blue) data[i + 3] = 0;\n    }\n\n    textureCtx.putImageData(textureImageData, 0, 0);\n    const newTexture = Texture.from(textureCanvas);\n    if (!newTexture) return;\n    texture.clear().beginTextureFill({\n      texture: newTexture\n    }).drawRect(0, 0, newTexture.width, newTexture.height).endFill();\n  }\n\n}\nRoomPlane.ZERO_POINT = new Point(0, 0);\nRoomPlane.TYPE_UNDEFINED = 0;\nRoomPlane.TYPE_WALL = 1;\nRoomPlane.TYPE_FLOOR = 2;\nRoomPlane.TYPE_LANDSCAPE = 3;\nRoomPlane._uniqueIdCounter = 1;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/RoomPlane.ts"],"names":["Texture","Graphics","Matrix","Point","Rectangle","TextureUtils","Vector3d","PlaneDrawingData","RoomPlaneBitmapMask","RoomPlaneRectangleMask","RoomVisualization","PlaneBitmapData","Randomizer","RoomPlane","constructor","origin","location","leftSide","rightSide","type","usesMask","secondaryNormals","randomSeed","textureOffsetX","textureOffsetY","textureMaxX","textureMaxY","_disposed","_randomSeed","_origin","_location","_leftSide","_rightSide","_normal","_secondaryNormals","_geometryUpdateId","_type","_isVisible","_bitmapTexture","_bitmapData","_hasTexture","_offset","_relativeDepth","_color","_rasterizer","_maskManager","_id","_uniqueId","_textureOffsetX","_textureOffsetY","_textureMaxX","_textureMaxY","_textures","_activeTexture","_useMask","_bitmapMasks","_rectangleMasks","_maskChanged","_maskBitmapData","_bitmapMasksOld","_rectangleMasksOld","_cornerA","_cornerB","_cornerC","_cornerD","_width","_height","_canBeVisible","assign","crossProduct","length","multiply","entry","vector","push","Map","_uniqueIdCounter","blend","k","_arg_2","canBeVisible","resetTextureCache","bitmapData","visible","texture","getTextureCache","generateTexture","addTextureCache","offset","relativeDepth","color","normal","hasTexture","rasterizer","maskManager","id","uniqueId","dispose","destroy","bitmap","values","copyBitmapData","width","height","cacheTexture","existing","get","delete","set","size","clear","getTextureIdentifier","toString","needsNewTexture","planeBitmap","scale","updateMaskChangeStatus","timeStamp","getTexture","_local_3","_local_4","_local_5","_local_6","_local_7","getCoordinatePosition","_local_8","render","_local_9","beginFill","drawRect","endFill","updateMask","resolveMasks","index","mask","planeMask","getMask","assetName","getAssetName","position","asset","getGraphicAsset","leftSideLoc","rightSideLoc","_local_11","offsetX","offsetY","addMask","flipH","flipV","screenWidth","_local_2","getScreenPoint","Math","round","abs","x","getDrawingDatas","geometry","drawingDatas","maskData","layers","getLayers","i","layer","getMaterial","cm","getMaterialCellMatrix","data","isBottomAligned","setSeed","column","getColumns","assetNames","cell","getCells","name","isRepeated","addAssetColumn","assetNameColumns","update","timeSinceStartMs","geometryChanged","updateId","cosAngle","directionAxis","updateCorners","originPos","getScreenPosition","originZ","z","max","TYPE_FLOOR","min","TYPE_LANDSCAPE","graphic","renderTexture","sum","y","TYPE_WALL","_local_10","a","b","c","d","translate","draw","matrix","clone","transform","setFromMatrix","resetBitmapMasks","addBitmapMask","_arg_3","resetRectangleMasks","addRectangleMask","_arg_4","leftSideLength","rightSideLength","plane","posX","posY","rectMask","wd","ht","combineTextureMask","maskCanvas","generateCanvas","textureCanvas","textureCtx","getContext","drawImage","textureImageData","getImageData","red","green","blue","alpha","putImageData","newTexture","from","beginTextureFill","ZERO_POINT","TYPE_UNDEFINED"],"mappings":"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","sourcesContent":["import { RenderTexture, Resource, Texture } from '@pixi/core';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport { Matrix, Point, Rectangle } from '@pixi/math';\r\nimport { NitroRenderTexture } from '../../../../../core';\r\nimport { IRoomPlane } from '../../../../../room/object/visualization/IRoomPlane';\r\nimport { IRoomGeometry } from '../../../../../room/utils/IRoomGeometry';\r\nimport { IVector3D } from '../../../../../room/utils/IVector3D';\r\nimport { TextureUtils } from '../../../../../room/utils/TextureUtils';\r\nimport { Vector3d } from '../../../../../room/utils/Vector3d';\r\nimport { PlaneMaskManager } from './mask/PlaneMaskManager';\r\nimport { PlaneDrawingData } from './PlaneDrawingData';\r\nimport { PlaneVisualizationLayer } from './rasterizer/basic/PlaneVisualizationLayer';\r\nimport { IPlaneRasterizer } from './rasterizer/IPlaneRasterizer';\r\nimport { RoomPlaneBitmapMask } from './RoomPlaneBitmapMask';\r\nimport { RoomPlaneRectangleMask } from './RoomPlaneRectangleMask';\r\nimport { RoomVisualization } from './RoomVisualization';\r\nimport { PlaneBitmapData } from './utils/PlaneBitmapData';\r\nimport { Randomizer } from './utils/Randomizer';\r\n\r\nexport class RoomPlane implements IRoomPlane\r\n{\r\n    private static ZERO_POINT: Point = new Point(0, 0);\r\n    public static TYPE_UNDEFINED: number = 0;\r\n    public static TYPE_WALL: number = 1;\r\n    public static TYPE_FLOOR: number = 2;\r\n    public static TYPE_LANDSCAPE: number = 3;\r\n    private static _uniqueIdCounter: number = 1;\r\n\r\n    private _disposed: boolean;\r\n    private _randomSeed: number;\r\n    private _origin: Vector3d;\r\n    private _location: Vector3d;\r\n    private _leftSide: Vector3d;\r\n    private _rightSide: Vector3d;\r\n    private _normal: Vector3d;\r\n    private _secondaryNormals: Vector3d[];\r\n    private _geometryUpdateId: number;\r\n    private _type: number;\r\n    private _isVisible: boolean;\r\n    private _bitmapTexture: NitroRenderTexture;\r\n    private _bitmapData: Graphics;\r\n    private _hasTexture: boolean;\r\n    private _offset: Point;\r\n    private _relativeDepth: number;\r\n    private _color: number;\r\n    private _rasterizer: IPlaneRasterizer;\r\n    private _maskManager: PlaneMaskManager = null;\r\n    private _id: string;\r\n    private _uniqueId: number;\r\n    private _textureOffsetX: number;\r\n    private _textureOffsetY: number;\r\n    private _textureMaxX: number;\r\n    private _textureMaxY: number;\r\n    private _textures: Map<string, PlaneBitmapData>;\r\n    private _activeTexture: PlaneBitmapData;\r\n    private _useMask: boolean;\r\n    private _bitmapMasks: RoomPlaneBitmapMask[];\r\n    private _rectangleMasks: RoomPlaneRectangleMask[];\r\n    private _maskChanged: boolean;\r\n    private _maskBitmapData: Graphics;\r\n    private _bitmapMasksOld: RoomPlaneBitmapMask[];\r\n    private _rectangleMasksOld: RoomPlaneRectangleMask[];\r\n    private _cornerA:Vector3d;\r\n    private _cornerB:Vector3d;\r\n    private _cornerC:Vector3d;\r\n    private _cornerD:Vector3d;\r\n    private _width: number = 0;\r\n    private _height: number = 0;\r\n    private _canBeVisible: boolean;\r\n\r\n    constructor(origin: IVector3D, location: IVector3D, leftSide: IVector3D, rightSide: IVector3D, type: number, usesMask: boolean, secondaryNormals: IVector3D[], randomSeed: number, textureOffsetX: number=0, textureOffsetY: number=0, textureMaxX: number=0, textureMaxY: number=0)\r\n    {\r\n        this._secondaryNormals = [];\r\n        this._bitmapMasks = [];\r\n        this._rectangleMasks = [];\r\n        this._bitmapMasksOld = [];\r\n        this._rectangleMasksOld = [];\r\n        this._randomSeed = randomSeed;\r\n        this._bitmapData = null;\r\n        this._maskBitmapData = null;\r\n        this._maskChanged = false;\r\n        this._activeTexture = null;\r\n        this._origin = new Vector3d();\r\n        this._origin.assign(origin);\r\n        this._location = new Vector3d();\r\n        this._location.assign(location);\r\n        this._leftSide = new Vector3d();\r\n        this._leftSide.assign(leftSide);\r\n        this._rightSide = new Vector3d();\r\n        this._rightSide.assign(rightSide);\r\n        this._normal = Vector3d.crossProduct(this._leftSide, this._rightSide);\r\n\r\n        if(this._normal.length > 0)\r\n        {\r\n            this._normal.multiply((1 / this._normal.length));\r\n        }\r\n\r\n        if(secondaryNormals != null)\r\n        {\r\n            for(const entry of secondaryNormals)\r\n            {\r\n                if(!entry) continue;\r\n\r\n                const vector = new Vector3d();\r\n\r\n                vector.assign(entry);\r\n\r\n                this._secondaryNormals.push(vector);\r\n            }\r\n        }\r\n        this._disposed = false;\r\n        this._isVisible = false;\r\n        this._id = null;\r\n        this._hasTexture = true;\r\n        this._geometryUpdateId = -1;\r\n        this._offset = new Point();\r\n        this._relativeDepth = 0;\r\n        this._type = type;\r\n        this._color = 0;\r\n        this._rasterizer = null;\r\n        this._canBeVisible = true;\r\n        this._textures = new Map();\r\n        this._cornerA = new Vector3d();\r\n        this._cornerB = new Vector3d();\r\n        this._cornerC = new Vector3d();\r\n        this._cornerD = new Vector3d();\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._textureOffsetX = textureOffsetX;\r\n        this._textureOffsetY = textureOffsetY;\r\n        this._textureMaxX = textureMaxX;\r\n        this._textureMaxY = textureMaxY;\r\n        this._useMask = usesMask;\r\n        this._uniqueId = ++RoomPlane._uniqueIdCounter;\r\n    }\r\n\r\n    private static blend(k: number, _arg_2: number): number\r\n    {\r\n        return 0;\r\n        //return Canvas.colorize(_arg_2, (k | 0xFF000000)) & 0xFFFFFF;\r\n    }\r\n\r\n    public set canBeVisible(k: boolean)\r\n    {\r\n        if(k !== this._canBeVisible)\r\n        {\r\n            if(!this._canBeVisible) this.resetTextureCache();\r\n\r\n            this._canBeVisible = k;\r\n        }\r\n    }\r\n\r\n    public get canBeVisible(): boolean\r\n    {\r\n        return this._canBeVisible;\r\n    }\r\n\r\n    public get bitmapData(): Texture<Resource>\r\n    {\r\n        if(!this.visible || !this._bitmapData) return null;\r\n\r\n        let texture: RenderTexture = RoomVisualization.getTextureCache(this._bitmapData);\r\n\r\n        if(!texture)\r\n        {\r\n            texture = TextureUtils.generateTexture(this._bitmapData, new Rectangle(0, 0, this._width, this._height));\r\n\r\n            RoomVisualization.addTextureCache(this._bitmapData, texture);\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    public get visible(): boolean\r\n    {\r\n        return (this._isVisible && this._canBeVisible);\r\n    }\r\n\r\n    public get offset(): Point\r\n    {\r\n        return this._offset;\r\n    }\r\n\r\n    public get relativeDepth(): number\r\n    {\r\n        return this._relativeDepth;\r\n    }\r\n\r\n    public get color(): number\r\n    {\r\n        return this._color;\r\n    }\r\n\r\n    public set color(k: number)\r\n    {\r\n        this._color = k;\r\n    }\r\n\r\n    public get type(): number\r\n    {\r\n        return this._type;\r\n    }\r\n\r\n    public get leftSide(): IVector3D\r\n    {\r\n        return this._leftSide;\r\n    }\r\n\r\n    public get rightSide(): IVector3D\r\n    {\r\n        return this._rightSide;\r\n    }\r\n\r\n    public get location(): IVector3D\r\n    {\r\n        return this._location;\r\n    }\r\n\r\n    public get normal(): IVector3D\r\n    {\r\n        return this._normal;\r\n    }\r\n\r\n    public get hasTexture(): boolean\r\n    {\r\n        return this._hasTexture;\r\n    }\r\n\r\n    public set hasTexture(k: boolean)\r\n    {\r\n        this._hasTexture = k;\r\n    }\r\n\r\n    public set rasterizer(k:IPlaneRasterizer)\r\n    {\r\n        this._rasterizer = k;\r\n    }\r\n\r\n    public set maskManager(k: PlaneMaskManager)\r\n    {\r\n        this._maskManager = k;\r\n    }\r\n\r\n    public set id(k: string)\r\n    {\r\n        if(k === this._id) return;\r\n\r\n        this.resetTextureCache();\r\n        this._id = k;\r\n    }\r\n\r\n    public get uniqueId(): number\r\n    {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._bitmapData)\r\n        {\r\n            this._bitmapData.destroy();\r\n\r\n            this._bitmapData = null;\r\n        }\r\n\r\n        if(this._textures)\r\n        {\r\n            for(const bitmap of this._textures.values())\r\n            {\r\n                if(!bitmap) continue;\r\n\r\n                if(bitmap.bitmap) bitmap.bitmap.destroy();\r\n\r\n                bitmap.dispose();\r\n            }\r\n\r\n            this._textures = null;\r\n        }\r\n\r\n        this._activeTexture = null;\r\n        this._location = null;\r\n        this._origin = null;\r\n        this._leftSide = null;\r\n        this._rightSide = null;\r\n        this._normal = null;\r\n        this._rasterizer = null;\r\n        this._cornerA = null;\r\n        this._cornerB = null;\r\n        this._cornerC = null;\r\n        this._cornerD = null;\r\n        this._bitmapMasks = null;\r\n        this._rectangleMasks = null;\r\n\r\n        if(this._maskBitmapData)\r\n        {\r\n            this._maskBitmapData.destroy();\r\n\r\n            this._maskBitmapData = null;\r\n        }\r\n\r\n        this._disposed = true;\r\n    }\r\n\r\n    public copyBitmapData(k: Texture<Resource>): Texture<Resource>\r\n    {\r\n        if(!this.visible || !this._bitmapData || !k) return null;\r\n\r\n        if((this._bitmapData.width !== k.width) || (this._bitmapData.height !== k.height)) return null;\r\n\r\n        //k.copyPixels(this._bitmapData, this._bitmapData.rect, RoomPlane.ZERO_POINT);\r\n        return k;\r\n    }\r\n\r\n    private cacheTexture(k: string, _arg_2: PlaneBitmapData): boolean\r\n    {\r\n        const existing = this._textures.get(k);\r\n\r\n        if(existing)\r\n        {\r\n            this._textures.delete(k);\r\n\r\n            existing.dispose();\r\n        }\r\n\r\n        this._activeTexture = _arg_2;\r\n        this._textures.set(k, _arg_2);\r\n\r\n        return true;\r\n    }\r\n\r\n    private resetTextureCache(k: Graphics = null): void\r\n    {\r\n        if(this._textures && this._textures.size)\r\n        {\r\n            for(const bitmap of this._textures.values())\r\n            {\r\n                if(!bitmap) continue;\r\n\r\n                bitmap.dispose();\r\n            }\r\n\r\n            this._textures.clear();\r\n        }\r\n\r\n        this._activeTexture = null;\r\n    }\r\n\r\n    private getTextureIdentifier(k: number): string\r\n    {\r\n        if(this._rasterizer) return this._rasterizer.getTextureIdentifier(k, this.normal);\r\n\r\n        return k.toString();\r\n    }\r\n\r\n    private needsNewTexture(k: IRoomGeometry, _arg_2: number): boolean\r\n    {\r\n        if(!k) return false;\r\n\r\n        let planeBitmap = this._activeTexture;\r\n\r\n        if(!planeBitmap)\r\n        {\r\n            planeBitmap = this._textures.get(this.getTextureIdentifier(k.scale));\r\n        }\r\n\r\n        this.updateMaskChangeStatus();\r\n\r\n        if(this._canBeVisible && ((!planeBitmap || ((planeBitmap.timeStamp >= 0) && (_arg_2 > planeBitmap.timeStamp))) || this._maskChanged)) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    private getTexture(k: IRoomGeometry, _arg_2: number): Graphics\r\n    {\r\n        if(!k) return null;\r\n\r\n        let _local_3: PlaneBitmapData = null;\r\n\r\n        if(this.needsNewTexture(k, _arg_2))\r\n        {\r\n            const _local_4 = this.getTextureIdentifier(k.scale);\r\n            const _local_5 = (this._leftSide.length * k.scale);\r\n            const _local_6 = (this._rightSide.length * k.scale);\r\n            const _local_7 = k.getCoordinatePosition(this._normal);\r\n\r\n            if(this._activeTexture)\r\n            {\r\n                _local_3 = this._activeTexture;\r\n            }\r\n            else\r\n            {\r\n                _local_3 = this._textures.get(_local_4);\r\n            }\r\n\r\n            let _local_8: Graphics = null;\r\n\r\n            if(_local_3) _local_8 = _local_3.bitmap;\r\n\r\n            if(this._rasterizer)\r\n            {\r\n                _local_3 = this._rasterizer.render(_local_8, this._id, _local_5, _local_6, k.scale, _local_7, this._hasTexture, this._textureOffsetX, this._textureOffsetY, this._textureMaxX, this._textureMaxY, _arg_2);\r\n\r\n                if(_local_3)\r\n                {\r\n                    if(_local_8 && (_local_3.bitmap !== _local_8)) _local_8.destroy();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                const _local_9 = new Graphics();\r\n\r\n                _local_9.beginFill(0xFFFFFF);\r\n                _local_9.drawRect(0, 0, _local_5, _local_6);\r\n                _local_9.endFill();\r\n\r\n                _local_3 = new PlaneBitmapData(_local_9, -1);\r\n            }\r\n\r\n            if(_local_3)\r\n            {\r\n                this.updateMask(_local_3.bitmap, k);\r\n                this.cacheTexture(_local_4, _local_3);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if(this._activeTexture)\r\n            {\r\n                _local_3 = this._activeTexture;\r\n            }\r\n            else\r\n            {\r\n                _local_3 = this._textures.get(this.getTextureIdentifier(k.scale));\r\n            }\r\n        }\r\n\r\n        if(_local_3)\r\n        {\r\n            this._activeTexture = _local_3;\r\n\r\n            return _local_3.bitmap;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private resolveMasks(k: IRoomGeometry): PlaneDrawingData\r\n    {\r\n        if(!this._useMask) return null;\r\n\r\n        const _local_5 = new PlaneDrawingData();\r\n\r\n        const index = 0;\r\n\r\n        while(index < this._bitmapMasks.length)\r\n        {\r\n            const mask = this._bitmapMasks[index];\r\n\r\n            if(mask)\r\n            {\r\n                const planeMask = this._maskManager.getMask(mask.type);\r\n\r\n                if(planeMask)\r\n                {\r\n                    const assetName = planeMask.getAssetName(k.scale);\r\n\r\n                    if(assetName)\r\n                    {\r\n                        const position = k.getCoordinatePosition(this._normal);\r\n                        const asset = planeMask.getGraphicAsset(k.scale, position);\r\n\r\n                        if(asset)\r\n                        {\r\n                            const _local_3 = (this._maskBitmapData.width * (1 - (mask.leftSideLoc / this._leftSide.length)));\r\n                            const _local_4 = (this._maskBitmapData.height * (1 - (mask.rightSideLoc / this._rightSide.length)));\r\n                            const _local_11 = new Point((_local_3 + asset.offsetX), (_local_4 + asset.offsetY));\r\n\r\n                            _local_5.addMask(assetName, _local_11, asset.flipH, asset.flipV);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return _local_5;\r\n    }\r\n\r\n    private screenWidth(k: IRoomGeometry): number\r\n    {\r\n        const _local_2 = k.getScreenPoint(new Vector3d(0, 0, 0));\r\n        const _local_3 = k.getScreenPoint(new Vector3d(0, 1, 0));\r\n\r\n        return Math.round((this._leftSide.length * Math.abs((_local_2.x - _local_3.x))));\r\n    }\r\n\r\n    public getDrawingDatas(geometry:IRoomGeometry): PlaneDrawingData[]\r\n    {\r\n        const drawingDatas: PlaneDrawingData[] = [];\r\n\r\n        if(this._isVisible)\r\n        {\r\n            const maskData = this.resolveMasks(geometry);\r\n            const layers = this._rasterizer.getLayers(this._id);\r\n\r\n            let i = 0;\r\n\r\n            while(i < layers.length)\r\n            {\r\n                const layer = (layers[i] as PlaneVisualizationLayer);\r\n\r\n                if(layer)\r\n                {\r\n                    if(this._hasTexture && layer.getMaterial())\r\n                    {\r\n                        const normal = geometry.getCoordinatePosition(this._normal);\r\n                        const cm = layer.getMaterial().getMaterialCellMatrix(normal);\r\n                        //const data      = new PlaneDrawingData(maskData, blend(this._color, layer.getColor()), cm.isBottomAligned());\r\n                        const data = new PlaneDrawingData(maskData, this._color, cm.isBottomAligned());\r\n\r\n                        Randomizer.setSeed(this._randomSeed);\r\n\r\n                        for(const column of cm.getColumns(this.screenWidth(geometry)))\r\n                        {\r\n                            const assetNames: string[] = [];\r\n\r\n                            for(const cell of column.getCells())\r\n                            {\r\n                                const name = cell.getAssetName(normal);\r\n\r\n                                if(name) assetNames.push(name);\r\n                            }\r\n\r\n                            if(assetNames.length > 0)\r\n                            {\r\n                                if(!column.isRepeated()) assetNames.push('');\r\n\r\n                                data.addAssetColumn(assetNames);\r\n                            }\r\n                        }\r\n\r\n                        if(data.assetNameColumns.length > 0) drawingDatas.push(data);\r\n                    }\r\n                    else\r\n                    {\r\n                        //data = new PlaneDrawingData(maskData, blend(this._color, layer.getColor()));\r\n                        const data = new PlaneDrawingData(maskData, this._color);\r\n\r\n                        drawingDatas.push(data);\r\n                    }\r\n                }\r\n\r\n                i++;\r\n            }\r\n\r\n            if(!drawingDatas.length) drawingDatas.push(new PlaneDrawingData(maskData, this._color));\r\n        }\r\n\r\n        return drawingDatas;\r\n    }\r\n\r\n    // private _Str_25956(k:PlaneBitmapData): void\r\n    // {\r\n    // }\r\n\r\n    public update(geometry: IRoomGeometry, timeSinceStartMs: number): boolean\r\n    {\r\n        if(!geometry || this._disposed) return false;\r\n\r\n        let geometryChanged = false;\r\n\r\n        if(this._geometryUpdateId != geometry.updateId) geometryChanged = true;\r\n\r\n        if(!geometryChanged || !this._canBeVisible)\r\n        {\r\n            if(!this.visible) return false;\r\n        }\r\n\r\n        if(geometryChanged)\r\n        {\r\n            this._activeTexture = null;\r\n\r\n            let cosAngle = 0;\r\n\r\n            cosAngle = Vector3d.cosAngle(geometry.directionAxis, this.normal);\r\n\r\n            if(cosAngle > -0.001)\r\n            {\r\n                if(this._isVisible)\r\n                {\r\n                    this._isVisible = false;\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            let i = 0;\r\n\r\n            while(i < this._secondaryNormals.length)\r\n            {\r\n                cosAngle = Vector3d.cosAngle(geometry.directionAxis, this._secondaryNormals[i]);\r\n\r\n                if(cosAngle > -0.001)\r\n                {\r\n                    if(this._isVisible)\r\n                    {\r\n                        this._isVisible = false;\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                i++;\r\n            }\r\n\r\n            this.updateCorners(geometry);\r\n\r\n            const originPos = geometry.getScreenPosition(this._origin);\r\n            const originZ = originPos.z;\r\n\r\n            let relativeDepth = (Math.max(this._cornerA.z, this._cornerB.z, this._cornerC.z, this._cornerD.z) - originZ);\r\n\r\n            if(this._type === RoomPlane.TYPE_FLOOR)\r\n            {\r\n                relativeDepth = (relativeDepth - ((this._location.z + Math.min(0, this._leftSide.z, this._rightSide.z)) * 8));\r\n            }\r\n\r\n            if(this._type === RoomPlane.TYPE_LANDSCAPE)\r\n            {\r\n                relativeDepth = (relativeDepth + 0.02);\r\n            }\r\n\r\n            this._relativeDepth = relativeDepth;\r\n            this._isVisible = true;\r\n            this._geometryUpdateId = geometry.updateId;\r\n        }\r\n\r\n        if(geometryChanged || this.needsNewTexture(geometry, timeSinceStartMs))\r\n        {\r\n            if(!this._bitmapData || (this._width !== this._bitmapData.width) || (this._height !== this._bitmapData.height))\r\n            {\r\n                if(this._bitmapData)\r\n                {\r\n                    this._bitmapData.destroy();\r\n\r\n                    this._bitmapData = null;\r\n\r\n                    if((this._width < 1) || (this._height < 1)) return true;\r\n                }\r\n                else\r\n                {\r\n                    if((this._width < 1) || (this._height < 1)) return false;\r\n                }\r\n\r\n                const graphic = new Graphics();\r\n\r\n                graphic.beginFill(0xFFFFFF, 0);\r\n                graphic.drawRect(0, 0, this._width, this._height);\r\n                graphic.endFill();\r\n\r\n                this._bitmapData = graphic;\r\n\r\n                if(!this._bitmapData) return false;\r\n            }\r\n            else\r\n            {\r\n                //this._bitmapData.lock();\r\n                //this._bitmapData.fillRect(this._bitmapData.rect, 0xFFFFFF);\r\n            }\r\n\r\n            Randomizer.setSeed(this._randomSeed);\r\n\r\n            const texture = this.getTexture(geometry, timeSinceStartMs);\r\n\r\n            if(texture)\r\n            {\r\n                this.renderTexture(geometry, texture);\r\n            }\r\n            else\r\n            {\r\n                this.dispose();\r\n\r\n                return false;\r\n            }\r\n\r\n            return ((texture !== null) || geometryChanged);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private updateCorners(k: IRoomGeometry): void\r\n    {\r\n        this._cornerA.assign(k.getScreenPosition(this._location));\r\n        this._cornerB.assign(k.getScreenPosition(Vector3d.sum(this._location, this._rightSide)));\r\n        this._cornerC.assign(k.getScreenPosition(Vector3d.sum(Vector3d.sum(this._location, this._leftSide), this._rightSide)));\r\n        this._cornerD.assign(k.getScreenPosition(Vector3d.sum(this._location, this._leftSide)));\r\n        this._offset = k.getScreenPoint(this._origin);\r\n        this._cornerA.x = Math.round(this._cornerA.x);\r\n        this._cornerA.y = Math.round(this._cornerA.y);\r\n        this._cornerB.x = Math.round(this._cornerB.x);\r\n        this._cornerB.y = Math.round(this._cornerB.y);\r\n        this._cornerC.x = Math.round(this._cornerC.x);\r\n        this._cornerC.y = Math.round(this._cornerC.y);\r\n        this._cornerD.x = Math.round(this._cornerD.x);\r\n        this._cornerD.y = Math.round(this._cornerD.y);\r\n        this._offset.x = Math.round(this._offset.x);\r\n        this._offset.y = Math.round(this._offset.y);\r\n        const _local_2: number = Math.min(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x);\r\n        let _local_3: number = Math.max(this._cornerA.x, this._cornerB.x, this._cornerC.x, this._cornerD.x);\r\n        const _local_4: number = Math.min(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y);\r\n        let _local_5: number = Math.max(this._cornerA.y, this._cornerB.y, this._cornerC.y, this._cornerD.y);\r\n        _local_3 = (_local_3 - _local_2);\r\n        this._offset.x = (this._offset.x - _local_2);\r\n        this._cornerA.x = (this._cornerA.x - _local_2);\r\n        this._cornerB.x = (this._cornerB.x - _local_2);\r\n        this._cornerC.x = (this._cornerC.x - _local_2);\r\n        this._cornerD.x = (this._cornerD.x - _local_2);\r\n        _local_5 = (_local_5 - _local_4);\r\n        this._offset.y = (this._offset.y - _local_4);\r\n        this._cornerA.y = (this._cornerA.y - _local_4);\r\n        this._cornerB.y = (this._cornerB.y - _local_4);\r\n        this._cornerC.y = (this._cornerC.y - _local_4);\r\n        this._cornerD.y = (this._cornerD.y - _local_4);\r\n        this._width = _local_3;\r\n        this._height = _local_5;\r\n    }\r\n\r\n    private renderTexture(k: IRoomGeometry, _arg_2: Graphics): void\r\n    {\r\n        if(((((((this._cornerA == null) || (this._cornerB == null)) || (this._cornerC == null)) || (this._cornerD == null)) || (_arg_2 == null)) || (this._bitmapData == null)))\r\n        {\r\n            return;\r\n        }\r\n        let _local_3: number = (this._cornerD.x - this._cornerC.x);\r\n        let _local_4: number = (this._cornerD.y - this._cornerC.y);\r\n        let _local_5: number = (this._cornerB.x - this._cornerC.x);\r\n        let _local_6: number = (this._cornerB.y - this._cornerC.y);\r\n        if(((this._type == RoomPlane.TYPE_WALL) || (this._type == RoomPlane.TYPE_LANDSCAPE)))\r\n        {\r\n            if(Math.abs((_local_5 - _arg_2.width)) <= 1)\r\n            {\r\n                _local_5 = _arg_2.width;\r\n            }\r\n            if(Math.abs((_local_6 - _arg_2.width)) <= 1)\r\n            {\r\n                _local_6 = _arg_2.width;\r\n            }\r\n            if(Math.abs((_local_3 - _arg_2.height)) <= 1)\r\n            {\r\n                _local_3 = _arg_2.height;\r\n            }\r\n            if(Math.abs((_local_4 - _arg_2.height)) <= 1)\r\n            {\r\n                _local_4 = _arg_2.height;\r\n            }\r\n        }\r\n        const _local_7: number = (_local_5 / _arg_2.width);\r\n        const _local_8: number = (_local_6 / _arg_2.width);\r\n        const _local_9: number = (_local_3 / _arg_2.height);\r\n        const _local_10: number = (_local_4 / _arg_2.height);\r\n        const _local_11 = new Matrix();\r\n        _local_11.a = _local_7;\r\n        _local_11.b = _local_8;\r\n        _local_11.c = _local_9;\r\n        _local_11.d = _local_10;\r\n        _local_11.translate(this._cornerC.x, this._cornerC.y);\r\n\r\n        this.draw(_arg_2, _local_11);\r\n    }\r\n\r\n    private draw(k: Graphics, matrix: Matrix): void\r\n    {\r\n        const clone = k.clone();\r\n\r\n        clone.transform.setFromMatrix(matrix);\r\n\r\n        this._bitmapData = clone;\r\n    }\r\n\r\n    public resetBitmapMasks(): void\r\n    {\r\n        if(this._disposed || !this._useMask || !this._bitmapMasks.length) return;\r\n\r\n        this._maskChanged = true;\r\n        this._bitmapMasks = [];\r\n    }\r\n\r\n    public addBitmapMask(k: string, _arg_2: number, _arg_3: number): boolean\r\n    {\r\n        if(!this._useMask) return false;\r\n\r\n        let _local_5 = 0;\r\n\r\n        while(_local_5 < this._bitmapMasks.length)\r\n        {\r\n            const mask = this._bitmapMasks[_local_5];\r\n\r\n            if(mask)\r\n            {\r\n                if((((mask.type === k) && (mask.leftSideLoc === _arg_2)) && (mask.rightSideLoc === _arg_3))) return false;\r\n            }\r\n\r\n            _local_5++;\r\n        }\r\n\r\n        const mask = new RoomPlaneBitmapMask(k, _arg_2, _arg_3);\r\n\r\n        this._bitmapMasks.push(mask);\r\n        this._maskChanged = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    public resetRectangleMasks(): void\r\n    {\r\n        if(!this._useMask || !this._rectangleMasks.length) return;\r\n\r\n        this._maskChanged = true;\r\n        this._rectangleMasks = [];\r\n    }\r\n\r\n    public addRectangleMask(k: number, _arg_2: number, _arg_3: number, _arg_4: number): boolean\r\n    {\r\n        if(this._useMask)\r\n        {\r\n            for(const mask of this._rectangleMasks)\r\n            {\r\n                if(!mask) continue;\r\n\r\n                if((((mask.leftSideLoc === k) && (mask.rightSideLoc === _arg_2)) && (mask.leftSideLength === _arg_3)) && (mask.rightSideLength === _arg_4)) return false;\r\n            }\r\n\r\n            const _local_5 = new RoomPlaneRectangleMask(k, _arg_2, _arg_3, _arg_4);\r\n\r\n            this._rectangleMasks.push(_local_5);\r\n            this._maskChanged = true;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private updateMaskChangeStatus(): void\r\n    {\r\n        if(!this._maskChanged) return;\r\n\r\n        let _local_3 = true;\r\n        let _local_6: boolean;\r\n\r\n        if(this._bitmapMasks.length === this._bitmapMasksOld.length)\r\n        {\r\n            for(const mask of this._bitmapMasks)\r\n            {\r\n                if(!mask) continue;\r\n\r\n                _local_6 = false;\r\n\r\n                for(const plane of this._bitmapMasksOld)\r\n                {\r\n                    if(!plane) continue;\r\n\r\n                    if(((plane.type === mask.type) && (plane.leftSideLoc === mask.leftSideLoc)) && (plane.rightSideLoc === mask.rightSideLoc))\r\n                    {\r\n                        _local_6 = true;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if(!_local_6)\r\n                {\r\n                    _local_3 = false;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            _local_3 = false;\r\n        }\r\n\r\n        if(this._rectangleMasks.length > this._rectangleMasksOld.length) _local_3 = false;\r\n\r\n        if(_local_3) this._maskChanged = false;\r\n    }\r\n\r\n    private updateMask(texture: Graphics, geometry: IRoomGeometry): void\r\n    {\r\n        if(!texture || !geometry) return;\r\n\r\n        if(((!this._useMask) || ((!this._bitmapMasks.length && !this._rectangleMasks.length) && !this._maskChanged)) || !this._maskManager) return;\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n\r\n        this.updateMaskChangeStatus();\r\n\r\n        if(!this._maskBitmapData || (this._maskBitmapData.width !== width) || (this._maskBitmapData.height !== height))\r\n        {\r\n            if(this._maskBitmapData)\r\n            {\r\n                this._maskBitmapData.destroy();\r\n                this._maskBitmapData = null;\r\n            }\r\n\r\n            const graphic = new Graphics();\r\n\r\n            graphic\r\n                .beginFill(0xFFFFFF, 0)\r\n                .drawRect(0, 0, width, height)\r\n                .endFill();\r\n\r\n            this._maskBitmapData = graphic;\r\n            this._maskChanged = true;\r\n        }\r\n\r\n        if(this._maskChanged)\r\n        {\r\n            this._bitmapMasksOld = [];\r\n            this._rectangleMasksOld = [];\r\n\r\n            if(this._maskBitmapData)\r\n            {\r\n                this._maskBitmapData\r\n                    .beginFill(0xFFFFFF, 0)\r\n                    .drawRect(0, 0, width, height)\r\n                    .endFill();\r\n            }\r\n\r\n            this.resetTextureCache(texture);\r\n\r\n            const normal = geometry.getCoordinatePosition(this._normal);\r\n\r\n            let type: string = null;\r\n            let posX = 0;\r\n            let posY = 0;\r\n            let i = 0;\r\n\r\n            while(i < this._bitmapMasks.length)\r\n            {\r\n                const mask = this._bitmapMasks[i];\r\n\r\n                if(mask)\r\n                {\r\n                    type = mask.type;\r\n                    posX = (this._maskBitmapData.width - ((this._maskBitmapData.width * mask.leftSideLoc) / this._leftSide.length));\r\n                    posY = (this._maskBitmapData.height - ((this._maskBitmapData.height * mask.rightSideLoc) / this._rightSide.length));\r\n\r\n                    this._maskManager.updateMask(this._maskBitmapData, type, geometry.scale, normal, posX, posY);\r\n                    this._bitmapMasksOld.push(new RoomPlaneBitmapMask(type, mask.leftSideLoc, mask.rightSideLoc));\r\n                }\r\n\r\n                i++;\r\n            }\r\n\r\n            i = 0;\r\n\r\n            while(i < this._rectangleMasks.length)\r\n            {\r\n                const rectMask = this._rectangleMasks[i];\r\n\r\n                if(rectMask)\r\n                {\r\n                    posX = (this._maskBitmapData.width - ((this._maskBitmapData.width * rectMask.leftSideLoc) / this._leftSide.length));\r\n                    posY = (this._maskBitmapData.height - ((this._maskBitmapData.height * rectMask.rightSideLoc) / this._rightSide.length));\r\n\r\n                    const wd = ((this._maskBitmapData.width * rectMask.leftSideLength) / this._leftSide.length);\r\n                    const ht = ((this._maskBitmapData.height * rectMask.rightSideLength) / this._rightSide.length);\r\n\r\n                    this._maskBitmapData\r\n                        .beginFill(0xFF0000)\r\n                        .drawRect((posX - wd), (posY - ht), wd, ht)\r\n                        .endFill();\r\n\r\n                    this._rectangleMasksOld.push(new RoomPlaneRectangleMask(rectMask.leftSideLength, rectMask.rightSideLoc, rectMask.leftSideLength, rectMask.rightSideLength));\r\n                }\r\n\r\n                i++;\r\n            }\r\n\r\n            this._maskChanged = false;\r\n        }\r\n\r\n        this.combineTextureMask(texture, this._maskBitmapData);\r\n    }\r\n\r\n    private combineTextureMask(texture: Graphics, mask: Graphics): void\r\n    {\r\n        if(!texture || !mask) return;\r\n\r\n        const maskCanvas = TextureUtils.generateCanvas(mask);\r\n        const textureCanvas = TextureUtils.generateCanvas(texture);\r\n        const textureCtx = textureCanvas.getContext('2d');\r\n\r\n        textureCtx.drawImage(maskCanvas, 0, 0);\r\n\r\n        const textureImageData = textureCtx.getImageData(0, 0, textureCanvas.width, textureCanvas.height);\r\n        const data = textureImageData.data;\r\n\r\n        for(let i = 0; i < data.length; i += 4)\r\n        {\r\n            const red = data[ i ];\r\n            const green = data[ i + 1 ];\r\n            const blue = data[ i + 2 ];\r\n            const alpha = data[ i + 3 ];\r\n\r\n            if(!red && !green && !blue) data[ i + 3 ] = 0;\r\n        }\r\n\r\n        textureCtx.putImageData(textureImageData, 0, 0);\r\n\r\n        const newTexture = Texture.from(textureCanvas);\r\n\r\n        if(!newTexture) return;\r\n\r\n        texture\r\n            .clear()\r\n            .beginTextureFill({ texture: newTexture })\r\n            .drawRect(0, 0, newTexture.width, newTexture.height)\r\n            .endFill();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}