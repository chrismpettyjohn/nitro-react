{"ast":null,"code":"import { Rectangle } from '@pixi/math';\nimport { AdvancedMap } from '../../../../../core/utils/AdvancedMap';\nimport { AlphaTolerance } from '../../../../../room/object/enum/AlphaTolerance';\nimport { RoomObjectSpriteType } from '../../../../../room/object/enum/RoomObjectSpriteType';\nimport { RoomObjectSpriteVisualization } from '../../../../../room/object/visualization/RoomObjectSpriteVisualization';\nimport { Vector3d } from '../../../../../room/utils/Vector3d';\nimport { RoomObjectVariable } from '../../RoomObjectVariable';\nimport { RoomPlaneBitmapMaskData } from '../../RoomPlaneBitmapMaskData';\nimport { RoomPlaneBitmapMaskParser } from '../../RoomPlaneBitmapMaskParser';\nimport { RoomPlaneData } from '../../RoomPlaneData';\nimport { RoomPlaneParser } from '../../RoomPlaneParser';\nimport { RoomPlane } from './RoomPlane';\nimport { RoomVisualizationData } from './RoomVisualizationData';\nexport class RoomVisualization extends RoomObjectSpriteVisualization {\n  constructor() {\n    super();\n    this._data = void 0;\n    this._roomPlaneParser = void 0;\n    this._roomPlaneBitmapMaskParser = void 0;\n    this._geometryUpdateId = void 0;\n    this._boundingRectangle = void 0;\n    this._directionX = void 0;\n    this._directionY = void 0;\n    this._directionZ = void 0;\n    this._floorThickness = void 0;\n    this._wallThickness = void 0;\n    this._holeUpdateTime = void 0;\n    this._planes = void 0;\n    this._visiblePlanes = void 0;\n    this._visiblePlaneSpriteNumbers = void 0;\n    this._roomScale = void 0;\n    this._lastUpdateTime = void 0;\n    this._updateIntervalTime = void 0;\n    this._wallType = void 0;\n    this._floorType = void 0;\n    this._landscapeType = void 0;\n    this._colorBackgroundOnly = void 0;\n    this._color = void 0;\n    this._redColor = void 0;\n    this._greenColor = void 0;\n    this._blueColor = void 0;\n    this._typeVisibility = void 0;\n    this._assetUpdateCounter = void 0;\n    this._maskData = void 0;\n    this._isPlaneSet = void 0;\n    this._data = null;\n    this._roomPlaneParser = new RoomPlaneParser();\n    this._roomPlaneBitmapMaskParser = new RoomPlaneBitmapMaskParser();\n    this._geometryUpdateId = -1;\n    this._directionX = 0;\n    this._directionY = 0;\n    this._directionZ = 0;\n    this._floorThickness = 1;\n    this._wallThickness = 1;\n    this._holeUpdateTime = NaN;\n    this._planes = [];\n    this._visiblePlanes = [];\n    this._visiblePlaneSpriteNumbers = [];\n    this._roomScale = 0;\n    this._lastUpdateTime = -1000;\n    this._updateIntervalTime = 250;\n    this._wallType = null;\n    this._floorType = null;\n    this._landscapeType = null;\n    this._colorBackgroundOnly = true;\n    this._color = 0xFFFFFF;\n    this._redColor = 0xFF;\n    this._greenColor = 0xFF;\n    this._blueColor = 0xFF;\n    this._typeVisibility = [];\n    this._assetUpdateCounter = 0;\n    this._maskData = null;\n    this._isPlaneSet = false;\n    this._typeVisibility[RoomPlane.TYPE_UNDEFINED] = false;\n    this._typeVisibility[RoomPlane.TYPE_FLOOR] = true;\n    this._typeVisibility[RoomPlane.TYPE_WALL] = true;\n    this._typeVisibility[RoomPlane.TYPE_LANDSCAPE] = true;\n  }\n\n  static getTextureCache(key) {\n    const existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\n    if (!existing) return null;\n    return existing.getValue(key);\n  }\n\n  static addTextureCache(key, value) {\n    if (!RoomVisualization.LAST_VISUALIZATION) return;\n    let existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\n\n    if (!existing) {\n      existing = new AdvancedMap();\n      RoomVisualization.RENDER_TEXTURE_CACHE.set(RoomVisualization.LAST_VISUALIZATION, existing);\n    }\n\n    existing.add(key, value);\n  }\n\n  initialize(data) {\n    if (!(data instanceof RoomVisualizationData)) return false;\n    this._data = data;\n    super.initialize(data);\n\n    this._data.setGraphicAssetCollection(this.asset);\n\n    return true;\n  }\n\n  dispose() {\n    super.dispose();\n    this.clearPlanes();\n    this._planes = null;\n    this._visiblePlanes = null;\n    this._visiblePlaneSpriteNumbers = null;\n\n    if (this._roomPlaneParser) {\n      this._roomPlaneParser.dispose();\n\n      this._roomPlaneParser = null;\n    }\n\n    if (this._roomPlaneBitmapMaskParser) {\n      this._roomPlaneBitmapMaskParser.dispose();\n\n      this._roomPlaneBitmapMaskParser = null;\n    }\n\n    if (this._data) {\n      this._data.clearCache();\n\n      this._data = null;\n    }\n\n    const existingTextureCache = RoomVisualization.RENDER_TEXTURE_CACHE.get(this);\n\n    if (existingTextureCache) {\n      for (const texture of existingTextureCache.getValues()) {\n        texture.destroy(true);\n      }\n\n      existingTextureCache.dispose();\n      RoomVisualization.RENDER_TEXTURE_CACHE.delete(this);\n    }\n  }\n\n  reset() {\n    super.reset();\n    this._floorType = null;\n    this._wallType = null;\n    this._landscapeType = null;\n    this._maskData = null;\n    this._geometryUpdateId = -1;\n    this._roomScale = 0;\n  }\n\n  update(geometry, time, update, skipUpdate) {\n    if (!this.object || !geometry) return;\n    RoomVisualization.LAST_VISUALIZATION = this;\n    let removeCount = 0;\n    const existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\n    if (existing) removeCount = existing.length;\n    const geometryUpdate = this.updateGeometry(geometry);\n    const objectModel = this.object.model;\n    let needsUpdate = false;\n    if (this.updateThickness(objectModel)) needsUpdate = true;\n    if (this.updateHole(objectModel)) needsUpdate = true;\n\n    if (this.initializeRoomPlanes()) {\n      if (existing && removeCount) {\n        setTimeout(() => {\n          while (removeCount) {\n            const texture = existing.getWithIndex(0);\n\n            if (texture) {\n              texture.destroy(true);\n              existing.remove(existing.getKey(0));\n            }\n\n            removeCount--;\n          }\n        }, 0);\n      }\n    }\n\n    needsUpdate = this.updateMasks(objectModel);\n    if (time < this._lastUpdateTime + this._updateIntervalTime && !geometryUpdate && !needsUpdate) return;\n    if (this.updatePlaneTexturesAndVisibilities(objectModel)) needsUpdate = true;\n    if (this.updatePlanes(geometry, geometryUpdate, time)) needsUpdate = true;\n\n    if (needsUpdate) {\n      let index = 0;\n\n      while (index < this._visiblePlanes.length) {\n        const spriteIndex = this._visiblePlaneSpriteNumbers[index];\n        const sprite = this.getSprite(spriteIndex);\n        const plane = this._visiblePlanes[index];\n\n        if (sprite && plane && plane.type !== RoomPlane.TYPE_LANDSCAPE) {\n          if (this._colorBackgroundOnly) {\n            let _local_14 = plane.color;\n\n            const _local_15 = (_local_14 & 0xFF) * this._redColor / 0xFF;\n\n            const _local_16 = (_local_14 >> 8 & 0xFF) * this._greenColor / 0xFF;\n\n            const _local_17 = (_local_14 >> 16 & 0xFF) * this._blueColor / 0xFF;\n\n            const _local_18 = _local_14 >> 24;\n\n            _local_14 = (_local_18 << 24) + (_local_17 << 16) + (_local_16 << 8) + _local_15;\n            sprite.color = _local_14;\n          } else {\n            sprite.color = plane.color;\n          }\n        }\n\n        index++;\n      }\n\n      this.updateSpriteCounter++;\n    }\n\n    this.updateModelCounter = objectModel.updateCounter;\n    this._lastUpdateTime = time;\n  }\n\n  updateGeometry(k) {\n    if (!k) return false;\n    if (this._geometryUpdateId === k.updateId) return false;\n    this._geometryUpdateId = k.updateId;\n    this._boundingRectangle = null;\n    const direction = k.direction;\n\n    if (direction && (direction.x !== this._directionX || direction.y !== this._directionY || direction.z !== this._directionZ || k.scale !== this._roomScale)) {\n      this._directionX = direction.x;\n      this._directionY = direction.y;\n      this._directionZ = direction.z;\n      this._roomScale = k.scale;\n      return true;\n    }\n\n    return false;\n  }\n\n  updateThickness(k) {\n    if (this.updateModelCounter === k.updateCounter) return false;\n    const floorThickness = k.getValue(RoomObjectVariable.ROOM_FLOOR_THICKNESS);\n    const wallThickness = k.getValue(RoomObjectVariable.ROOM_WALL_THICKNESS);\n\n    if (!isNaN(floorThickness) && !isNaN(wallThickness) && (floorThickness !== this._floorThickness || wallThickness !== this._wallThickness)) {\n      this._floorThickness = floorThickness;\n      this._wallThickness = wallThickness;\n      this.clearPlanes();\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHole(k) {\n    if (this.updateModelCounter === k.updateCounter) return false;\n    const holeUpdate = k.getValue(RoomObjectVariable.ROOM_FLOOR_HOLE_UPDATE_TIME);\n\n    if (!isNaN(holeUpdate) && holeUpdate !== this._holeUpdateTime) {\n      this._holeUpdateTime = holeUpdate;\n      this.clearPlanes();\n      return true;\n    }\n\n    return false;\n  }\n\n  updateMasks(k) {\n    if (this.updateModelCounter === k.updateCounter) return false;\n    let didUpdate = false;\n    const planeMask = k.getValue(RoomObjectVariable.ROOM_PLANE_MASK_XML);\n\n    if (planeMask !== this._maskData) {\n      this.updatePlaneMasks(planeMask);\n      this._maskData = planeMask;\n      didUpdate = true;\n    }\n\n    const backgroundColor = k.getValue(RoomObjectVariable.ROOM_BACKGROUND_COLOR);\n\n    if (backgroundColor !== this._color) {\n      this._color = backgroundColor;\n      this._redColor = this._color & 0xFF;\n      this._greenColor = this._color >> 8 & 0xFF;\n      this._blueColor = this._color >> 16 & 0xFF;\n      didUpdate = true;\n    }\n\n    const backgroundOnly = k.getValue(RoomObjectVariable.ROOM_COLORIZE_BG_ONLY) || false;\n\n    if (backgroundOnly !== this._colorBackgroundOnly) {\n      this._colorBackgroundOnly = backgroundOnly;\n      didUpdate = true;\n    }\n\n    return didUpdate;\n  }\n\n  updatePlaneTexturesAndVisibilities(model) {\n    if (this.updateModelCounter === model.updateCounter) return false;\n    const floorType = model.getValue(RoomObjectVariable.ROOM_FLOOR_TYPE);\n    const wallType = model.getValue(RoomObjectVariable.ROOM_WALL_TYPE);\n    const landscapeType = model.getValue(RoomObjectVariable.ROOM_LANDSCAPE_TYPE);\n    this.updatePlaneTypes(floorType, wallType, landscapeType);\n    const floorVisibility = model.getValue(RoomObjectVariable.ROOM_FLOOR_VISIBILITY) === 1;\n    const wallVisibility = model.getValue(RoomObjectVariable.ROOM_WALL_VISIBILITY) === 1;\n    const landscapeVisibility = model.getValue(RoomObjectVariable.ROOM_LANDSCAPE_VISIBILITY) === 1;\n    this.updatePlaneVisibility(floorVisibility, wallVisibility, landscapeVisibility);\n    return true;\n  }\n\n  clearPlanes() {\n    if (this._planes) {\n      while (this._planes.length) {\n        const plane = this._planes[0];\n        if (plane) plane.dispose();\n\n        this._planes.pop();\n      }\n\n      this._planes = [];\n      this._planes = [];\n    }\n\n    this._isPlaneSet = false;\n    this._assetUpdateCounter = this._assetUpdateCounter + 1;\n    this.reset();\n  }\n\n  initializeRoomPlanes() {\n    if (!this.object || this._isPlaneSet) return false;\n    if (!isNaN(this._floorThickness)) this._roomPlaneParser.floorThicknessMultiplier = this._floorThickness;\n    if (!isNaN(this._wallThickness)) this._roomPlaneParser.wallThicknessMultiplier = this._wallThickness;\n    const mapData = this.object.model.getValue(RoomObjectVariable.ROOM_MAP_DATA);\n    if (!this._roomPlaneParser.initializeFromMapData(mapData)) return;\n\n    const _local_3 = this.getLandscapeWidth();\n\n    const _local_4 = this.getLandscapeHeight();\n\n    let _local_5 = 0;\n    let randomSeed = this.object.model.getValue(RoomObjectVariable.ROOM_RANDOM_SEED);\n    let index = 0;\n\n    while (index < this._roomPlaneParser.planeCount) {\n      const location = this._roomPlaneParser.getPlaneLocation(index);\n\n      const leftSide = this._roomPlaneParser.getPlaneLeftSide(index);\n\n      const rightSide = this._roomPlaneParser.getPlaneRightSide(index);\n\n      const secondaryNormals = this._roomPlaneParser.getPlaneSecondaryNormals(index);\n\n      const planeType = this._roomPlaneParser.getPlaneType(index);\n\n      let plane = null;\n\n      if (location && leftSide && rightSide) {\n        const _local_14 = Vector3d.crossProduct(leftSide, rightSide);\n\n        randomSeed = randomSeed * 7613 + 517;\n        plane = null;\n\n        if (planeType === RoomPlaneData.PLANE_FLOOR) {\n          const _local_15 = location.x + leftSide.x + 0.5;\n\n          const _local_16 = location.y + rightSide.y + 0.5;\n\n          const textureOffsetX = Math.trunc(_local_15) - _local_15;\n\n          const textureOffsetY = Math.trunc(_local_16) - _local_16;\n\n          plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_FLOOR, true, secondaryNormals, randomSeed, -textureOffsetX, -textureOffsetY);\n\n          if (_local_14.z !== 0) {\n            plane.color = RoomVisualization.FLOOR_COLOR;\n          } else {\n            plane.color = _local_14.x !== 0 ? RoomVisualization.FLOOR_COLOR_RIGHT : RoomVisualization.FLOOR_COLOR_LEFT;\n          }\n\n          if (this._data) plane.rasterizer = this._data.floorRasterizer;\n        } else if (planeType === RoomPlaneData.PLANE_WALL) {\n          plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_WALL, true, secondaryNormals, randomSeed);\n\n          if (leftSide.length < 1 || rightSide.length < 1) {\n            plane.hasTexture = false;\n          }\n\n          if (_local_14.x === 0 && _local_14.y === 0) {\n            plane.color = RoomVisualization.WALL_COLOR_BORDER;\n          } else {\n            if (_local_14.y > 0) {\n              plane.color = RoomVisualization.WALL_COLOR_TOP;\n            } else {\n              if (_local_14.y === 0) {\n                plane.color = RoomVisualization.WALL_COLOR_SIDE;\n              } else {\n                plane.color = RoomVisualization.WALL_COLOR_BOTTOM;\n              }\n            }\n          }\n\n          if (this._data) plane.rasterizer = this._data.wallRasterizer;\n        } else if (planeType === RoomPlaneData.PLANE_LANDSCAPE) {\n          plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_LANDSCAPE, true, secondaryNormals, randomSeed, _local_5, 0, _local_3, _local_4);\n\n          if (_local_14.y > 0) {\n            plane.color = RoomVisualization.LANDSCAPE_COLOR_TOP;\n          } else {\n            if (_local_14.y == 0) {\n              plane.color = RoomVisualization.LANDSCAPE_COLOR_SIDE;\n            } else {\n              plane.color = RoomVisualization.LANDSCAPE_COLOR_BOTTOM;\n            }\n          }\n\n          if (this._data) plane.rasterizer = this._data.landscapeRasterizer;\n          _local_5 = _local_5 + leftSide.length;\n        } else if (planeType == RoomPlaneData.PLANE_BILLBOARD) {\n          plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_WALL, true, secondaryNormals, randomSeed);\n\n          if (leftSide.length < 1 || rightSide.length < 1) {\n            plane.hasTexture = false;\n          }\n\n          if (_local_14.x == 0 && _local_14.y == 0) {\n            plane.color = RoomVisualization.WALL_COLOR_BORDER;\n          } else {\n            if (_local_14.y > 0) {\n              plane.color = RoomVisualization.WALL_COLOR_TOP;\n            } else {\n              if (_local_14.y == 0) {\n                plane.color = RoomVisualization.WALL_COLOR_SIDE;\n              } else {\n                plane.color = RoomVisualization.WALL_COLOR_BOTTOM;\n              }\n            }\n          } // if (this._Str_594 != null)\n          // {\n          //     _local_13.rasterizer = this._Str_594._Str_23913;\n          // }\n\n        }\n\n        if (plane) {\n          plane.maskManager = this._data.maskManager;\n          let _local_19 = 0;\n\n          while (_local_19 < this._roomPlaneParser.getPlaneMaskCount(index)) {\n            const _local_20 = this._roomPlaneParser.getPlaneMaskLeftSideLoc(index, _local_19);\n\n            const _local_21 = this._roomPlaneParser.getPlaneMaskRightSideLoc(index, _local_19);\n\n            const _local_22 = this._roomPlaneParser.getPlaneMaskLeftSideLength(index, _local_19);\n\n            const _local_23 = this._roomPlaneParser.getPlaneMaskRightSideLength(index, _local_19);\n\n            plane.addRectangleMask(_local_20, _local_21, _local_22, _local_23);\n            _local_19++;\n          }\n\n          this._planes.push(plane);\n        }\n      } else {\n        return;\n      }\n\n      index++;\n    }\n\n    this._isPlaneSet = true;\n    this.defineSprites();\n    return true;\n  }\n\n  defineSprites() {\n    this.createSprites(this._planes.length);\n    let planeIndex = 0;\n\n    while (planeIndex < this._planes.length) {\n      const plane = this._planes[planeIndex];\n      const sprite = this.getSprite(planeIndex);\n\n      if (plane && sprite && plane.leftSide && plane.rightSide) {\n        if (plane.type === RoomPlane.TYPE_WALL && (plane.leftSide.length < 1 || plane.rightSide.length < 1)) {\n          sprite.alphaTolerance = AlphaTolerance.MATCH_NOTHING;\n        } else {\n          sprite.alphaTolerance = AlphaTolerance.MATCH_OPAQUE_PIXELS;\n        }\n\n        if (plane.type === RoomPlane.TYPE_WALL) {\n          sprite.tag = 'plane.wall@' + (planeIndex + 1);\n        } else if (plane.type === RoomPlane.TYPE_FLOOR) {\n          sprite.tag = 'plane.floor@' + (planeIndex + 1);\n        } else {\n          sprite.tag = 'plane@' + (planeIndex + 1);\n        }\n\n        sprite.spriteType = RoomObjectSpriteType.ROOM_PLANE;\n      }\n\n      planeIndex++;\n    }\n  }\n\n  getLandscapeWidth() {\n    let length = 0;\n    let index = 0;\n\n    while (index < this._roomPlaneParser.planeCount) {\n      const type = this._roomPlaneParser.getPlaneType(index);\n\n      if (type === RoomPlaneData.PLANE_LANDSCAPE) {\n        const vector = this._roomPlaneParser.getPlaneLeftSide(index);\n\n        length += vector.length;\n      }\n\n      index++;\n    }\n\n    return length;\n  }\n\n  getLandscapeHeight() {\n    let length = 0;\n    let index = 0;\n\n    while (index < this._roomPlaneParser.planeCount) {\n      const type = this._roomPlaneParser.getPlaneType(index);\n\n      if (type === RoomPlaneData.PLANE_LANDSCAPE) {\n        const vector = this._roomPlaneParser.getPlaneRightSide(index);\n\n        if (vector.length > length) length = vector.length;\n      }\n\n      index++;\n    }\n\n    if (length > 5) length = 5;\n    return length;\n  }\n\n  updatePlaneTypes(floorType, wallType, landscapeType) {\n    if (floorType !== this._floorType) this._floorType = floorType;else floorType = null;\n    if (wallType !== this._wallType) this._wallType = wallType;else wallType = null;\n    if (landscapeType !== this._landscapeType) this._landscapeType = landscapeType;else landscapeType = null;\n    if (!floorType && !wallType && !landscapeType) return false;\n    let index = 0;\n\n    while (index < this._planes.length) {\n      const plane = this._planes[index];\n\n      if (plane) {\n        if (plane.type === RoomPlane.TYPE_FLOOR && floorType) {\n          plane.id = floorType;\n        } else if (plane.type === RoomPlane.TYPE_WALL && wallType) {\n          plane.id = wallType;\n        } else if (plane.type === RoomPlane.TYPE_LANDSCAPE && landscapeType) {\n          plane.id = landscapeType;\n        }\n      }\n\n      index++;\n    }\n\n    return true;\n  }\n\n  updatePlaneVisibility(k, _arg_2, _arg_3) {\n    if (k === this._typeVisibility[RoomPlane.TYPE_FLOOR] && _arg_2 === this._typeVisibility[RoomPlane.TYPE_WALL] && _arg_3 === this._typeVisibility[RoomPlane.TYPE_LANDSCAPE]) return;\n    this._typeVisibility[RoomPlane.TYPE_FLOOR] = k;\n    this._typeVisibility[RoomPlane.TYPE_WALL] = _arg_2;\n    this._typeVisibility[RoomPlane.TYPE_LANDSCAPE] = _arg_3;\n    this._visiblePlanes = [];\n    this._visiblePlaneSpriteNumbers = [];\n  }\n\n  updatePlanes(k, _arg_2, _arg_3) {\n    if (!k || !this.object) return;\n    this._assetUpdateCounter++;\n\n    if (_arg_2) {\n      this._visiblePlanes = [];\n      this._visiblePlaneSpriteNumbers = [];\n    }\n\n    const _local_8 = this._visiblePlanes.length > 0;\n\n    let _local_6 = this._visiblePlanes;\n    if (!this._visiblePlanes.length) _local_6 = this._planes;\n    let depth = 0;\n    let updated = false;\n    let index = 0;\n\n    while (index < _local_6.length) {\n      let _local_10 = index;\n      if (_local_8) _local_10 = this._visiblePlaneSpriteNumbers[index];\n\n      const _local_11 = this.getSprite(_local_10);\n\n      if (_local_11) {\n        const _local_12 = _local_6[index];\n\n        if (_local_12) {\n          _local_11.id = _local_12.uniqueId;\n\n          if (_local_12.update(k, _arg_3)) {\n            if (_local_12.visible) {\n              depth = _local_12.relativeDepth + this.floorRelativeDepth + _local_10 / 1000;\n\n              if (_local_12.type !== RoomPlane.TYPE_FLOOR) {\n                depth = _local_12.relativeDepth + this.wallRelativeDepth + _local_10 / 1000;\n\n                if (_local_12.leftSide.length < 1 || _local_12.rightSide.length < 1) {\n                  depth = depth + RoomVisualization.ROOM_DEPTH_OFFSET * 0.5;\n                }\n              }\n\n              const _local_14 = 'plane ' + _local_10 + ' ' + k.scale;\n\n              this.updateSprite(_local_11, _local_12, _local_14, depth);\n            }\n\n            updated = true;\n          }\n\n          if (_local_11.visible != (_local_12.visible && this._typeVisibility[_local_12.type])) {\n            _local_11.visible = !_local_11.visible;\n            updated = true;\n          }\n\n          if (_local_11.visible) {\n            if (!_local_8) {\n              this._visiblePlanes.push(_local_12);\n\n              this._visiblePlaneSpriteNumbers.push(index);\n            }\n          }\n        } else {\n          _local_11.id = 0;\n\n          if (_local_11.visible) {\n            _local_11.visible = false;\n            updated = true;\n          }\n        }\n      }\n\n      index++;\n    }\n\n    return updated;\n  }\n\n  updatePlaneMasks(k) {\n    if (!k) return;\n\n    this._roomPlaneBitmapMaskParser.initialize(k);\n\n    const _local_4 = [];\n    const _local_5 = [];\n    let _local_6 = false;\n    let index = 0;\n\n    while (index < this._planes.length) {\n      const plane = this._planes[index];\n\n      if (plane) {\n        plane.resetBitmapMasks();\n        if (plane.type === RoomPlane.TYPE_LANDSCAPE) _local_4.push(index);\n      }\n\n      index++;\n    }\n\n    for (const mask of this._roomPlaneBitmapMaskParser.masks.values()) {\n      const maskType = this._roomPlaneBitmapMaskParser.getMaskType(mask);\n\n      const maskLocation = this._roomPlaneBitmapMaskParser.getMaskLocation(mask);\n\n      const maskCategory = this._roomPlaneBitmapMaskParser.getMaskCategory(mask);\n\n      if (maskLocation) {\n        let i = 0;\n\n        while (i < this._planes.length) {\n          const plane = this._planes[i];\n\n          if (plane.type === RoomPlane.TYPE_WALL || plane.type === RoomPlane.TYPE_LANDSCAPE) {\n            if (plane && plane.location && plane.normal) {\n              const _local_14 = Vector3d.dif(maskLocation, plane.location);\n\n              const _local_15 = Math.abs(Vector3d.scalarProjection(_local_14, plane.normal));\n\n              if (_local_15 < 0.01) {\n                if (plane.leftSide && plane.rightSide) {\n                  const _local_16 = Vector3d.scalarProjection(_local_14, plane.leftSide);\n\n                  const _local_17 = Vector3d.scalarProjection(_local_14, plane.rightSide);\n\n                  if (plane.type === RoomPlane.TYPE_WALL || plane.type === RoomPlane.TYPE_LANDSCAPE && maskCategory === RoomPlaneBitmapMaskData.HOLE) {\n                    plane.addBitmapMask(maskType, _local_16, _local_17);\n                  } else {\n                    if (plane.type === RoomPlane.TYPE_LANDSCAPE) {\n                      if (!plane.canBeVisible) _local_6 = true;\n                      plane.canBeVisible = true;\n\n                      _local_5.push(i);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          i++;\n        }\n      }\n    }\n\n    index = 0;\n\n    while (index < _local_4.length) {\n      const planeIndex = _local_4[index];\n\n      if (_local_5.indexOf(planeIndex) < 0) {\n        const plane = this._planes[planeIndex];\n        plane.canBeVisible = false;\n        _local_6 = true;\n      }\n\n      index++;\n    }\n\n    if (_local_6) {\n      this._visiblePlanes = [];\n      this._visiblePlaneSpriteNumbers = [];\n    }\n  }\n\n  updateSprite(k, _arg_2, _arg_3, _arg_4) {\n    const offset = _arg_2.offset;\n    k.offsetX = -offset.x;\n    k.offsetY = -offset.y;\n    k.relativeDepth = _arg_4;\n    k.color = _arg_2.color;\n    k.texture = this.getPlaneBitmap(_arg_2, _arg_3);\n    k.name = _arg_3 + '_' + this._assetUpdateCounter;\n  }\n\n  getPlaneBitmap(k, _arg_2) {\n    return k.bitmapData;\n  }\n\n  getBoundingRectangle() {\n    if (!this._boundingRectangle) this._boundingRectangle = super.getBoundingRectangle();\n    return new Rectangle(this._boundingRectangle.x, this._boundingRectangle.y, this._boundingRectangle.width, this._boundingRectangle.height);\n  }\n\n  get planes() {\n    const planes = [];\n\n    for (const plane of this._visiblePlanes) planes.push(plane);\n\n    return planes;\n  }\n\n  get floorRelativeDepth() {\n    return RoomVisualization.ROOM_DEPTH_OFFSET + 0.1;\n  }\n\n  get wallRelativeDepth() {\n    return RoomVisualization.ROOM_DEPTH_OFFSET + 0.5;\n  }\n\n}\nRoomVisualization.LAST_VISUALIZATION = null;\nRoomVisualization.RENDER_TEXTURE_CACHE = new Map();\nRoomVisualization.FLOOR_COLOR = 0xFFFFFF;\nRoomVisualization.FLOOR_COLOR_LEFT = 0xDDDDDD;\nRoomVisualization.FLOOR_COLOR_RIGHT = 0xBBBBBB;\nRoomVisualization.WALL_COLOR_TOP = 0xFFFFFF;\nRoomVisualization.WALL_COLOR_SIDE = 0xCCCCCC;\nRoomVisualization.WALL_COLOR_BOTTOM = 0x999999;\nRoomVisualization.WALL_COLOR_BORDER = 0x999999;\nRoomVisualization.LANDSCAPE_COLOR_TOP = 0xFFFFFF;\nRoomVisualization.LANDSCAPE_COLOR_SIDE = 0xCCCCCC;\nRoomVisualization.LANDSCAPE_COLOR_BOTTOM = 0x999999;\nRoomVisualization.ROOM_DEPTH_OFFSET = 1000;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/RoomVisualization.ts"],"names":["Rectangle","AdvancedMap","AlphaTolerance","RoomObjectSpriteType","RoomObjectSpriteVisualization","Vector3d","RoomObjectVariable","RoomPlaneBitmapMaskData","RoomPlaneBitmapMaskParser","RoomPlaneData","RoomPlaneParser","RoomPlane","RoomVisualizationData","RoomVisualization","constructor","_data","_roomPlaneParser","_roomPlaneBitmapMaskParser","_geometryUpdateId","_boundingRectangle","_directionX","_directionY","_directionZ","_floorThickness","_wallThickness","_holeUpdateTime","_planes","_visiblePlanes","_visiblePlaneSpriteNumbers","_roomScale","_lastUpdateTime","_updateIntervalTime","_wallType","_floorType","_landscapeType","_colorBackgroundOnly","_color","_redColor","_greenColor","_blueColor","_typeVisibility","_assetUpdateCounter","_maskData","_isPlaneSet","NaN","TYPE_UNDEFINED","TYPE_FLOOR","TYPE_WALL","TYPE_LANDSCAPE","getTextureCache","key","existing","RENDER_TEXTURE_CACHE","get","LAST_VISUALIZATION","getValue","addTextureCache","value","set","add","initialize","data","setGraphicAssetCollection","asset","dispose","clearPlanes","clearCache","existingTextureCache","texture","getValues","destroy","delete","reset","update","geometry","time","skipUpdate","object","removeCount","length","geometryUpdate","updateGeometry","objectModel","model","needsUpdate","updateThickness","updateHole","initializeRoomPlanes","setTimeout","getWithIndex","remove","getKey","updateMasks","updatePlaneTexturesAndVisibilities","updatePlanes","index","spriteIndex","sprite","getSprite","plane","type","_local_14","color","_local_15","_local_16","_local_17","_local_18","updateSpriteCounter","updateModelCounter","updateCounter","k","updateId","direction","x","y","z","scale","floorThickness","ROOM_FLOOR_THICKNESS","wallThickness","ROOM_WALL_THICKNESS","isNaN","holeUpdate","ROOM_FLOOR_HOLE_UPDATE_TIME","didUpdate","planeMask","ROOM_PLANE_MASK_XML","updatePlaneMasks","backgroundColor","ROOM_BACKGROUND_COLOR","backgroundOnly","ROOM_COLORIZE_BG_ONLY","floorType","ROOM_FLOOR_TYPE","wallType","ROOM_WALL_TYPE","landscapeType","ROOM_LANDSCAPE_TYPE","updatePlaneTypes","floorVisibility","ROOM_FLOOR_VISIBILITY","wallVisibility","ROOM_WALL_VISIBILITY","landscapeVisibility","ROOM_LANDSCAPE_VISIBILITY","updatePlaneVisibility","pop","floorThicknessMultiplier","wallThicknessMultiplier","mapData","ROOM_MAP_DATA","initializeFromMapData","_local_3","getLandscapeWidth","_local_4","getLandscapeHeight","_local_5","randomSeed","ROOM_RANDOM_SEED","planeCount","location","getPlaneLocation","leftSide","getPlaneLeftSide","rightSide","getPlaneRightSide","secondaryNormals","getPlaneSecondaryNormals","planeType","getPlaneType","crossProduct","PLANE_FLOOR","textureOffsetX","Math","trunc","textureOffsetY","getLocation","FLOOR_COLOR","FLOOR_COLOR_RIGHT","FLOOR_COLOR_LEFT","rasterizer","floorRasterizer","PLANE_WALL","hasTexture","WALL_COLOR_BORDER","WALL_COLOR_TOP","WALL_COLOR_SIDE","WALL_COLOR_BOTTOM","wallRasterizer","PLANE_LANDSCAPE","LANDSCAPE_COLOR_TOP","LANDSCAPE_COLOR_SIDE","LANDSCAPE_COLOR_BOTTOM","landscapeRasterizer","PLANE_BILLBOARD","maskManager","_local_19","getPlaneMaskCount","_local_20","getPlaneMaskLeftSideLoc","_local_21","getPlaneMaskRightSideLoc","_local_22","getPlaneMaskLeftSideLength","_local_23","getPlaneMaskRightSideLength","addRectangleMask","push","defineSprites","createSprites","planeIndex","alphaTolerance","MATCH_NOTHING","MATCH_OPAQUE_PIXELS","tag","spriteType","ROOM_PLANE","vector","id","_arg_2","_arg_3","_local_8","_local_6","depth","updated","_local_10","_local_11","_local_12","uniqueId","visible","relativeDepth","floorRelativeDepth","wallRelativeDepth","ROOM_DEPTH_OFFSET","updateSprite","resetBitmapMasks","mask","masks","values","maskType","getMaskType","maskLocation","getMaskLocation","maskCategory","getMaskCategory","i","normal","dif","abs","scalarProjection","HOLE","addBitmapMask","canBeVisible","indexOf","_arg_4","offset","offsetX","offsetY","getPlaneBitmap","name","bitmapData","getBoundingRectangle","width","height","planes","Map"],"mappings":"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","sourcesContent":["import { RenderTexture, Resource, Texture } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\nimport { AdvancedMap } from '../../../../../core/utils/AdvancedMap';\r\nimport { AlphaTolerance } from '../../../../../room/object/enum/AlphaTolerance';\r\nimport { RoomObjectSpriteType } from '../../../../../room/object/enum/RoomObjectSpriteType';\r\nimport { IRoomObjectModel } from '../../../../../room/object/IRoomObjectModel';\r\nimport { IPlaneVisualization } from '../../../../../room/object/visualization/IPlaneVisualization';\r\nimport { IRoomObjectSprite } from '../../../../../room/object/visualization/IRoomObjectSprite';\r\nimport { IObjectVisualizationData } from '../../../../../room/object/visualization/IRoomObjectVisualizationData';\r\nimport { IRoomPlane } from '../../../../../room/object/visualization/IRoomPlane';\r\nimport { RoomObjectSpriteVisualization } from '../../../../../room/object/visualization/RoomObjectSpriteVisualization';\r\nimport { IRoomGeometry } from '../../../../../room/utils/IRoomGeometry';\r\nimport { Vector3d } from '../../../../../room/utils/Vector3d';\r\nimport { RoomMapData } from '../../RoomMapData';\r\nimport { RoomMapMaskData } from '../../RoomMapMaskData';\r\nimport { RoomObjectVariable } from '../../RoomObjectVariable';\r\nimport { RoomPlaneBitmapMaskData } from '../../RoomPlaneBitmapMaskData';\r\nimport { RoomPlaneBitmapMaskParser } from '../../RoomPlaneBitmapMaskParser';\r\nimport { RoomPlaneData } from '../../RoomPlaneData';\r\nimport { RoomPlaneParser } from '../../RoomPlaneParser';\r\nimport { RoomPlane } from './RoomPlane';\r\nimport { RoomVisualizationData } from './RoomVisualizationData';\r\n\r\nexport class RoomVisualization extends RoomObjectSpriteVisualization implements IPlaneVisualization\r\n{\r\n    public static LAST_VISUALIZATION: RoomVisualization = null;\r\n\r\n    public static RENDER_TEXTURE_CACHE: Map<RoomVisualization, AdvancedMap<any, RenderTexture>> = new Map();\r\n\r\n    public static FLOOR_COLOR: number = 0xFFFFFF;\r\n    public static FLOOR_COLOR_LEFT: number = 0xDDDDDD;\r\n    public static FLOOR_COLOR_RIGHT: number = 0xBBBBBB;\r\n    private static WALL_COLOR_TOP: number = 0xFFFFFF;\r\n    private static WALL_COLOR_SIDE: number = 0xCCCCCC;\r\n    private static WALL_COLOR_BOTTOM: number = 0x999999;\r\n    private static WALL_COLOR_BORDER: number = 0x999999;\r\n    public static LANDSCAPE_COLOR_TOP: number = 0xFFFFFF;\r\n    public static LANDSCAPE_COLOR_SIDE: number = 0xCCCCCC;\r\n    public static LANDSCAPE_COLOR_BOTTOM: number = 0x999999;\r\n    private static ROOM_DEPTH_OFFSET: number = 1000;\r\n\r\n    protected _data: RoomVisualizationData;\r\n\r\n    private _roomPlaneParser: RoomPlaneParser;\r\n    private _roomPlaneBitmapMaskParser: RoomPlaneBitmapMaskParser;\r\n\r\n    private _geometryUpdateId: number;\r\n    private _boundingRectangle: Rectangle;\r\n    private _directionX: number;\r\n    private _directionY: number;\r\n    private _directionZ: number;\r\n    private _floorThickness: number;\r\n    private _wallThickness: number;\r\n    private _holeUpdateTime: number;\r\n    private _planes: RoomPlane[];\r\n    private _visiblePlanes: RoomPlane[];\r\n    private _visiblePlaneSpriteNumbers: number[];\r\n    private _roomScale: number;\r\n    private _lastUpdateTime: number;\r\n    private _updateIntervalTime: number;\r\n    private _wallType: string;\r\n    private _floorType: string;\r\n    private _landscapeType: string;\r\n    private _colorBackgroundOnly: boolean;\r\n    private _color: number;\r\n    private _redColor: number;\r\n    private _greenColor: number;\r\n    private _blueColor: number;\r\n    private _typeVisibility: boolean[];\r\n    private _assetUpdateCounter: number;\r\n    private _maskData: RoomMapMaskData;\r\n    private _isPlaneSet: boolean;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._data = null;\r\n\r\n        this._roomPlaneParser = new RoomPlaneParser();\r\n        this._roomPlaneBitmapMaskParser = new RoomPlaneBitmapMaskParser();\r\n\r\n        this._geometryUpdateId = -1;\r\n        this._directionX = 0;\r\n        this._directionY = 0;\r\n        this._directionZ = 0;\r\n        this._floorThickness = 1;\r\n        this._wallThickness = 1;\r\n        this._holeUpdateTime = NaN;\r\n        this._planes = [];\r\n        this._visiblePlanes = [];\r\n        this._visiblePlaneSpriteNumbers = [];\r\n        this._roomScale = 0;\r\n        this._lastUpdateTime = -1000;\r\n        this._updateIntervalTime = 250;\r\n        this._wallType = null;\r\n        this._floorType = null;\r\n        this._landscapeType = null;\r\n        this._colorBackgroundOnly = true;\r\n        this._color = 0xFFFFFF;\r\n        this._redColor = 0xFF;\r\n        this._greenColor = 0xFF;\r\n        this._blueColor = 0xFF;\r\n        this._typeVisibility = [];\r\n        this._assetUpdateCounter = 0;\r\n        this._maskData = null;\r\n        this._isPlaneSet = false;\r\n\r\n        this._typeVisibility[RoomPlane.TYPE_UNDEFINED] = false;\r\n        this._typeVisibility[RoomPlane.TYPE_FLOOR] = true;\r\n        this._typeVisibility[RoomPlane.TYPE_WALL] = true;\r\n        this._typeVisibility[RoomPlane.TYPE_LANDSCAPE] = true;\r\n    }\r\n\r\n    public static getTextureCache(key: any): RenderTexture\r\n    {\r\n        const existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\r\n\r\n        if(!existing) return null;\r\n\r\n        return existing.getValue(key);\r\n    }\r\n\r\n    public static addTextureCache(key: any, value: RenderTexture): void\r\n    {\r\n        if(!RoomVisualization.LAST_VISUALIZATION) return;\r\n\r\n        let existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\r\n\r\n        if(!existing)\r\n        {\r\n            existing = new AdvancedMap();\r\n\r\n            RoomVisualization.RENDER_TEXTURE_CACHE.set(RoomVisualization.LAST_VISUALIZATION, existing);\r\n        }\r\n\r\n        existing.add(key, value);\r\n    }\r\n\r\n    public initialize(data: IObjectVisualizationData): boolean\r\n    {\r\n        if(!(data instanceof RoomVisualizationData)) return false;\r\n\r\n        this._data = data;\r\n\r\n        super.initialize(data);\r\n\r\n        this._data.setGraphicAssetCollection(this.asset);\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        super.dispose();\r\n\r\n        this.clearPlanes();\r\n\r\n        this._planes = null;\r\n        this._visiblePlanes = null;\r\n        this._visiblePlaneSpriteNumbers = null;\r\n\r\n        if(this._roomPlaneParser)\r\n        {\r\n            this._roomPlaneParser.dispose();\r\n\r\n            this._roomPlaneParser = null;\r\n        }\r\n\r\n        if(this._roomPlaneBitmapMaskParser)\r\n        {\r\n            this._roomPlaneBitmapMaskParser.dispose();\r\n\r\n            this._roomPlaneBitmapMaskParser = null;\r\n        }\r\n\r\n        if(this._data)\r\n        {\r\n            this._data.clearCache();\r\n\r\n            this._data = null;\r\n        }\r\n\r\n        const existingTextureCache = RoomVisualization.RENDER_TEXTURE_CACHE.get(this);\r\n\r\n        if(existingTextureCache)\r\n        {\r\n            for(const texture of existingTextureCache.getValues())\r\n            {\r\n                texture.destroy(true);\r\n            }\r\n\r\n            existingTextureCache.dispose();\r\n\r\n            RoomVisualization.RENDER_TEXTURE_CACHE.delete(this);\r\n        }\r\n    }\r\n\r\n    protected reset(): void\r\n    {\r\n        super.reset();\r\n\r\n        this._floorType = null;\r\n        this._wallType = null;\r\n        this._landscapeType = null;\r\n        this._maskData = null;\r\n        this._geometryUpdateId = -1;\r\n        this._roomScale = 0;\r\n    }\r\n\r\n    public update(geometry: IRoomGeometry, time: number, update: boolean, skipUpdate: boolean): void\r\n    {\r\n        if(!this.object || !geometry) return;\r\n\r\n        RoomVisualization.LAST_VISUALIZATION = this;\r\n\r\n        let removeCount = 0;\r\n\r\n        const existing = RoomVisualization.RENDER_TEXTURE_CACHE.get(RoomVisualization.LAST_VISUALIZATION);\r\n\r\n        if(existing) removeCount = existing.length;\r\n\r\n        const geometryUpdate = this.updateGeometry(geometry);\r\n        const objectModel = this.object.model;\r\n\r\n        let needsUpdate = false;\r\n\r\n        if(this.updateThickness(objectModel)) needsUpdate = true;\r\n\r\n        if(this.updateHole(objectModel)) needsUpdate = true;\r\n\r\n        if(this.initializeRoomPlanes())\r\n        {\r\n            if(existing && removeCount)\r\n            {\r\n                setTimeout(() =>\r\n                {\r\n                    while(removeCount)\r\n                    {\r\n                        const texture = existing.getWithIndex(0);\r\n\r\n                        if(texture)\r\n                        {\r\n                            texture.destroy(true);\r\n\r\n                            existing.remove(existing.getKey(0));\r\n                        }\r\n\r\n                        removeCount--;\r\n                    }\r\n                }, 0);\r\n            }\r\n        }\r\n\r\n        needsUpdate = this.updateMasks(objectModel);\r\n\r\n        if(((time < (this._lastUpdateTime + this._updateIntervalTime)) && (!geometryUpdate)) && (!needsUpdate)) return;\r\n\r\n        if(this.updatePlaneTexturesAndVisibilities(objectModel)) needsUpdate = true;\r\n\r\n        if(this.updatePlanes(geometry, geometryUpdate, time)) needsUpdate = true;\r\n\r\n        if(needsUpdate)\r\n        {\r\n            let index = 0;\r\n\r\n            while(index < this._visiblePlanes.length)\r\n            {\r\n                const spriteIndex = this._visiblePlaneSpriteNumbers[index];\r\n                const sprite = this.getSprite(spriteIndex);\r\n                const plane = this._visiblePlanes[index];\r\n\r\n                if(sprite && plane && (plane.type !== RoomPlane.TYPE_LANDSCAPE))\r\n                {\r\n                    if(this._colorBackgroundOnly)\r\n                    {\r\n                        let _local_14 = plane.color;\r\n\r\n                        const _local_15 = (((_local_14 & 0xFF) * this._redColor) / 0xFF);\r\n                        const _local_16 = ((((_local_14 >> 8) & 0xFF) * this._greenColor) / 0xFF);\r\n                        const _local_17 = ((((_local_14 >> 16) & 0xFF) * this._blueColor) / 0xFF);\r\n                        const _local_18 = (_local_14 >> 24);\r\n\r\n                        _local_14 = ((((_local_18 << 24) + (_local_17 << 16)) + (_local_16 << 8)) + _local_15);\r\n\r\n                        sprite.color = _local_14;\r\n                    }\r\n                    else\r\n                    {\r\n                        sprite.color = plane.color;\r\n                    }\r\n                }\r\n\r\n                index++;\r\n            }\r\n\r\n            this.updateSpriteCounter++;\r\n        }\r\n\r\n        this.updateModelCounter = objectModel.updateCounter;\r\n        this._lastUpdateTime = time;\r\n    }\r\n\r\n    private updateGeometry(k: IRoomGeometry): boolean\r\n    {\r\n        if(!k) return false;\r\n\r\n        if(this._geometryUpdateId === k.updateId) return false;\r\n\r\n        this._geometryUpdateId = k.updateId;\r\n        this._boundingRectangle = null;\r\n\r\n        const direction = k.direction;\r\n\r\n        if(direction && ((direction.x !== this._directionX) || (direction.y !== this._directionY) || (direction.z !== this._directionZ) || (k.scale !== this._roomScale)))\r\n        {\r\n            this._directionX = direction.x;\r\n            this._directionY = direction.y;\r\n            this._directionZ = direction.z;\r\n            this._roomScale = k.scale;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private updateThickness(k: IRoomObjectModel): boolean\r\n    {\r\n        if(this.updateModelCounter === k.updateCounter) return false;\r\n\r\n        const floorThickness = k.getValue<number>(RoomObjectVariable.ROOM_FLOOR_THICKNESS);\r\n        const wallThickness = k.getValue<number>(RoomObjectVariable.ROOM_WALL_THICKNESS);\r\n\r\n        if((!isNaN(floorThickness) && !isNaN(wallThickness)) && ((floorThickness !== this._floorThickness) || (wallThickness !== this._wallThickness)))\r\n        {\r\n            this._floorThickness = floorThickness;\r\n            this._wallThickness = wallThickness;\r\n\r\n            this.clearPlanes();\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private updateHole(k: IRoomObjectModel): boolean\r\n    {\r\n        if(this.updateModelCounter === k.updateCounter) return false;\r\n\r\n        const holeUpdate = k.getValue<number>(RoomObjectVariable.ROOM_FLOOR_HOLE_UPDATE_TIME);\r\n\r\n        if(!isNaN(holeUpdate) && (holeUpdate !== this._holeUpdateTime))\r\n        {\r\n            this._holeUpdateTime = holeUpdate;\r\n\r\n            this.clearPlanes();\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private updateMasks(k: IRoomObjectModel): boolean\r\n    {\r\n        if(this.updateModelCounter === k.updateCounter) return false;\r\n\r\n        let didUpdate = false;\r\n\r\n        const planeMask = k.getValue<RoomMapMaskData>(RoomObjectVariable.ROOM_PLANE_MASK_XML);\r\n\r\n        if(planeMask !== this._maskData)\r\n        {\r\n            this.updatePlaneMasks(planeMask);\r\n\r\n            this._maskData = planeMask;\r\n\r\n            didUpdate = true;\r\n        }\r\n\r\n        const backgroundColor = k.getValue<number>(RoomObjectVariable.ROOM_BACKGROUND_COLOR);\r\n\r\n        if(backgroundColor !== this._color)\r\n        {\r\n            this._color = backgroundColor;\r\n            this._redColor = (this._color & 0xFF);\r\n            this._greenColor = ((this._color >> 8) & 0xFF);\r\n            this._blueColor = ((this._color >> 16) & 0xFF);\r\n\r\n            didUpdate = true;\r\n        }\r\n\r\n        const backgroundOnly = (k.getValue<boolean>(RoomObjectVariable.ROOM_COLORIZE_BG_ONLY) || false);\r\n\r\n        if(backgroundOnly !== this._colorBackgroundOnly)\r\n        {\r\n            this._colorBackgroundOnly = backgroundOnly;\r\n\r\n            didUpdate = true;\r\n        }\r\n\r\n        return didUpdate;\r\n    }\r\n\r\n    private updatePlaneTexturesAndVisibilities(model: IRoomObjectModel): boolean\r\n    {\r\n        if(this.updateModelCounter === model.updateCounter) return false;\r\n\r\n        const floorType = model.getValue<string>(RoomObjectVariable.ROOM_FLOOR_TYPE);\r\n        const wallType = model.getValue<string>(RoomObjectVariable.ROOM_WALL_TYPE);\r\n        const landscapeType = model.getValue<string>(RoomObjectVariable.ROOM_LANDSCAPE_TYPE);\r\n\r\n        this.updatePlaneTypes(floorType, wallType, landscapeType);\r\n\r\n        const floorVisibility = (model.getValue<number>(RoomObjectVariable.ROOM_FLOOR_VISIBILITY) === 1);\r\n        const wallVisibility = (model.getValue<number>(RoomObjectVariable.ROOM_WALL_VISIBILITY) === 1);\r\n        const landscapeVisibility = (model.getValue<number>(RoomObjectVariable.ROOM_LANDSCAPE_VISIBILITY) === 1);\r\n\r\n        this.updatePlaneVisibility(floorVisibility, wallVisibility, landscapeVisibility);\r\n\r\n        return true;\r\n    }\r\n\r\n    private clearPlanes(): void\r\n    {\r\n        if(this._planes)\r\n        {\r\n            while(this._planes.length)\r\n            {\r\n                const plane = this._planes[0];\r\n\r\n                if(plane) plane.dispose();\r\n\r\n                this._planes.pop();\r\n            }\r\n\r\n            this._planes = [];\r\n            this._planes = [];\r\n        }\r\n\r\n        this._isPlaneSet = false;\r\n        this._assetUpdateCounter = (this._assetUpdateCounter + 1);\r\n\r\n        this.reset();\r\n    }\r\n\r\n    protected initializeRoomPlanes(): boolean\r\n    {\r\n        if(!this.object || this._isPlaneSet) return false;\r\n\r\n        if(!isNaN(this._floorThickness)) this._roomPlaneParser.floorThicknessMultiplier = this._floorThickness;\r\n        if(!isNaN(this._wallThickness)) this._roomPlaneParser.wallThicknessMultiplier = this._wallThickness;\r\n\r\n        const mapData = this.object.model.getValue<RoomMapData>(RoomObjectVariable.ROOM_MAP_DATA);\r\n\r\n        if(!this._roomPlaneParser.initializeFromMapData(mapData)) return;\r\n\r\n        const _local_3 = this.getLandscapeWidth();\r\n        const _local_4 = this.getLandscapeHeight();\r\n\r\n        let _local_5 = 0;\r\n        let randomSeed = this.object.model.getValue<number>(RoomObjectVariable.ROOM_RANDOM_SEED);\r\n        let index = 0;\r\n\r\n        while(index < this._roomPlaneParser.planeCount)\r\n        {\r\n            const location = this._roomPlaneParser.getPlaneLocation(index);\r\n            const leftSide = this._roomPlaneParser.getPlaneLeftSide(index);\r\n            const rightSide = this._roomPlaneParser.getPlaneRightSide(index);\r\n            const secondaryNormals = this._roomPlaneParser.getPlaneSecondaryNormals(index);\r\n            const planeType = this._roomPlaneParser.getPlaneType(index);\r\n\r\n            let plane: RoomPlane = null;\r\n\r\n            if(location && leftSide && rightSide)\r\n            {\r\n                const _local_14 = Vector3d.crossProduct(leftSide, rightSide);\r\n\r\n                randomSeed = ((randomSeed * 7613) + 517);\r\n                plane = null;\r\n\r\n                if(planeType === RoomPlaneData.PLANE_FLOOR)\r\n                {\r\n                    const _local_15 = ((location.x + leftSide.x) + 0.5);\r\n                    const _local_16 = ((location.y + rightSide.y) + 0.5);\r\n                    const textureOffsetX = (Math.trunc(_local_15) - _local_15);\r\n                    const textureOffsetY = (Math.trunc(_local_16) - _local_16);\r\n\r\n                    plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_FLOOR, true, secondaryNormals, randomSeed, -(textureOffsetX), -(textureOffsetY));\r\n\r\n                    if(_local_14.z !== 0)\r\n                    {\r\n                        plane.color = RoomVisualization.FLOOR_COLOR;\r\n                    }\r\n                    else\r\n                    {\r\n                        plane.color = ((_local_14.x !== 0) ? RoomVisualization.FLOOR_COLOR_RIGHT : RoomVisualization.FLOOR_COLOR_LEFT);\r\n                    }\r\n\r\n                    if(this._data) plane.rasterizer = this._data.floorRasterizer;\r\n                }\r\n\r\n                else if(planeType === RoomPlaneData.PLANE_WALL)\r\n                {\r\n                    plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_WALL, true, secondaryNormals, randomSeed);\r\n\r\n                    if((leftSide.length < 1) || (rightSide.length < 1))\r\n                    {\r\n                        plane.hasTexture = false;\r\n                    }\r\n\r\n                    if((_local_14.x === 0) && (_local_14.y === 0))\r\n                    {\r\n                        plane.color = RoomVisualization.WALL_COLOR_BORDER;\r\n                    }\r\n                    else\r\n                    {\r\n                        if(_local_14.y > 0)\r\n                        {\r\n                            plane.color = RoomVisualization.WALL_COLOR_TOP;\r\n                        }\r\n                        else\r\n                        {\r\n                            if(_local_14.y === 0)\r\n                            {\r\n                                plane.color = RoomVisualization.WALL_COLOR_SIDE;\r\n                            }\r\n                            else\r\n                            {\r\n                                plane.color = RoomVisualization.WALL_COLOR_BOTTOM;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(this._data) plane.rasterizer = this._data.wallRasterizer;\r\n                }\r\n\r\n                else if(planeType === RoomPlaneData.PLANE_LANDSCAPE)\r\n                {\r\n                    plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_LANDSCAPE, true, secondaryNormals, randomSeed, _local_5, 0, _local_3, _local_4);\r\n\r\n                    if(_local_14.y > 0)\r\n                    {\r\n                        plane.color = RoomVisualization.LANDSCAPE_COLOR_TOP;\r\n                    }\r\n                    else\r\n                    {\r\n                        if(_local_14.y == 0)\r\n                        {\r\n                            plane.color = RoomVisualization.LANDSCAPE_COLOR_SIDE;\r\n                        }\r\n                        else\r\n                        {\r\n                            plane.color = RoomVisualization.LANDSCAPE_COLOR_BOTTOM;\r\n                        }\r\n                    }\r\n\r\n                    if(this._data) plane.rasterizer = this._data.landscapeRasterizer;\r\n\r\n                    _local_5 = (_local_5 + leftSide.length);\r\n                }\r\n\r\n                else if(planeType == RoomPlaneData.PLANE_BILLBOARD)\r\n                {\r\n                    plane = new RoomPlane(this.object.getLocation(), location, leftSide, rightSide, RoomPlane.TYPE_WALL, true, secondaryNormals, randomSeed);\r\n                    if(((leftSide.length < 1) || (rightSide.length < 1)))\r\n                    {\r\n                        plane.hasTexture = false;\r\n                    }\r\n                    if(((_local_14.x == 0) && (_local_14.y == 0)))\r\n                    {\r\n                        plane.color = RoomVisualization.WALL_COLOR_BORDER;\r\n                    }\r\n                    else\r\n                    {\r\n                        if(_local_14.y > 0)\r\n                        {\r\n                            plane.color = RoomVisualization.WALL_COLOR_TOP;\r\n                        }\r\n                        else\r\n                        {\r\n                            if(_local_14.y == 0)\r\n                            {\r\n                                plane.color = RoomVisualization.WALL_COLOR_SIDE;\r\n                            }\r\n                            else\r\n                            {\r\n                                plane.color = RoomVisualization.WALL_COLOR_BOTTOM;\r\n                            }\r\n                        }\r\n                    }\r\n                    // if (this._Str_594 != null)\r\n                    // {\r\n                    //     _local_13.rasterizer = this._Str_594._Str_23913;\r\n                    // }\r\n                }\r\n\r\n\r\n                if(plane)\r\n                {\r\n                    plane.maskManager = this._data.maskManager;\r\n\r\n                    let _local_19 = 0;\r\n\r\n                    while(_local_19 < this._roomPlaneParser.getPlaneMaskCount(index))\r\n                    {\r\n                        const _local_20 = this._roomPlaneParser.getPlaneMaskLeftSideLoc(index, _local_19);\r\n                        const _local_21 = this._roomPlaneParser.getPlaneMaskRightSideLoc(index, _local_19);\r\n                        const _local_22 = this._roomPlaneParser.getPlaneMaskLeftSideLength(index, _local_19);\r\n                        const _local_23 = this._roomPlaneParser.getPlaneMaskRightSideLength(index, _local_19);\r\n\r\n                        plane.addRectangleMask(_local_20, _local_21, _local_22, _local_23);\r\n\r\n                        _local_19++;\r\n                    }\r\n\r\n                    this._planes.push(plane);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                return;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        this._isPlaneSet = true;\r\n        this.defineSprites();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected defineSprites(): void\r\n    {\r\n        this.createSprites(this._planes.length);\r\n\r\n        let planeIndex = 0;\r\n\r\n        while(planeIndex < this._planes.length)\r\n        {\r\n            const plane = this._planes[planeIndex];\r\n            const sprite = this.getSprite(planeIndex);\r\n\r\n            if(plane && sprite && plane.leftSide && plane.rightSide)\r\n            {\r\n                if((plane.type === RoomPlane.TYPE_WALL) && ((plane.leftSide.length < 1) || (plane.rightSide.length < 1)))\r\n                {\r\n                    sprite.alphaTolerance = AlphaTolerance.MATCH_NOTHING;\r\n                }\r\n                else\r\n                {\r\n                    sprite.alphaTolerance = AlphaTolerance.MATCH_OPAQUE_PIXELS;\r\n                }\r\n\r\n                if(plane.type === RoomPlane.TYPE_WALL)\r\n                {\r\n                    sprite.tag = 'plane.wall@' + (planeIndex + 1);\r\n                }\r\n\r\n                else if(plane.type === RoomPlane.TYPE_FLOOR)\r\n                {\r\n                    sprite.tag = 'plane.floor@' + (planeIndex + 1);\r\n                }\r\n\r\n                else\r\n                {\r\n                    sprite.tag = 'plane@' + (planeIndex + 1);\r\n                }\r\n\r\n                sprite.spriteType = RoomObjectSpriteType.ROOM_PLANE;\r\n            }\r\n\r\n            planeIndex++;\r\n        }\r\n    }\r\n\r\n    private getLandscapeWidth(): number\r\n    {\r\n        let length = 0;\r\n        let index = 0;\r\n\r\n        while(index < this._roomPlaneParser.planeCount)\r\n        {\r\n            const type = this._roomPlaneParser.getPlaneType(index);\r\n\r\n            if(type === RoomPlaneData.PLANE_LANDSCAPE)\r\n            {\r\n                const vector = this._roomPlaneParser.getPlaneLeftSide(index);\r\n\r\n                length += vector.length;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        return length;\r\n    }\r\n\r\n    private getLandscapeHeight(): number\r\n    {\r\n        let length = 0;\r\n        let index = 0;\r\n\r\n        while(index < this._roomPlaneParser.planeCount)\r\n        {\r\n            const type = this._roomPlaneParser.getPlaneType(index);\r\n\r\n            if(type === RoomPlaneData.PLANE_LANDSCAPE)\r\n            {\r\n                const vector = this._roomPlaneParser.getPlaneRightSide(index);\r\n\r\n                if(vector.length > length) length = vector.length;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        if(length > 5) length = 5;\r\n\r\n        return length;\r\n    }\r\n\r\n    protected updatePlaneTypes(floorType: string, wallType: string, landscapeType: string): boolean\r\n    {\r\n        if(floorType !== this._floorType) this._floorType = floorType;\r\n        else floorType = null;\r\n\r\n        if(wallType !== this._wallType) this._wallType = wallType;\r\n        else wallType = null;\r\n\r\n        if(landscapeType !== this._landscapeType) this._landscapeType = landscapeType;\r\n        else landscapeType = null;\r\n\r\n        if(!floorType && !wallType && !landscapeType) return false;\r\n\r\n        let index = 0;\r\n\r\n        while(index < this._planes.length)\r\n        {\r\n            const plane = this._planes[index];\r\n\r\n            if(plane)\r\n            {\r\n                if((plane.type === RoomPlane.TYPE_FLOOR) && floorType)\r\n                {\r\n                    plane.id = floorType;\r\n                }\r\n\r\n                else if((plane.type === RoomPlane.TYPE_WALL) && wallType)\r\n                {\r\n                    plane.id = wallType;\r\n                }\r\n\r\n                else if((plane.type === RoomPlane.TYPE_LANDSCAPE) && landscapeType)\r\n                {\r\n                    plane.id = landscapeType;\r\n                }\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private updatePlaneVisibility(k: boolean, _arg_2: boolean, _arg_3: boolean): void\r\n    {\r\n        if((k === this._typeVisibility[RoomPlane.TYPE_FLOOR]) && (_arg_2 === this._typeVisibility[RoomPlane.TYPE_WALL]) && (_arg_3 === this._typeVisibility[RoomPlane.TYPE_LANDSCAPE])) return;\r\n\r\n        this._typeVisibility[RoomPlane.TYPE_FLOOR] = k;\r\n        this._typeVisibility[RoomPlane.TYPE_WALL] = _arg_2;\r\n        this._typeVisibility[RoomPlane.TYPE_LANDSCAPE] = _arg_3;\r\n\r\n        this._visiblePlanes = [];\r\n        this._visiblePlaneSpriteNumbers = [];\r\n    }\r\n\r\n    protected updatePlanes(k: IRoomGeometry, _arg_2: boolean, _arg_3: number): boolean\r\n    {\r\n        if(!k || !this.object) return;\r\n\r\n        this._assetUpdateCounter++;\r\n\r\n        if(_arg_2)\r\n        {\r\n            this._visiblePlanes = [];\r\n            this._visiblePlaneSpriteNumbers = [];\r\n        }\r\n\r\n        const _local_8 = (this._visiblePlanes.length > 0);\r\n\r\n        let _local_6 = this._visiblePlanes;\r\n\r\n        if(!this._visiblePlanes.length) _local_6 = this._planes;\r\n\r\n        let depth = 0;\r\n        let updated = false;\r\n        let index = 0;\r\n\r\n        while(index < _local_6.length)\r\n        {\r\n            let _local_10 = index;\r\n\r\n            if(_local_8) _local_10 = this._visiblePlaneSpriteNumbers[index];\r\n\r\n            const _local_11 = this.getSprite(_local_10);\r\n\r\n            if(_local_11)\r\n            {\r\n                const _local_12 = _local_6[index];\r\n\r\n                if(_local_12)\r\n                {\r\n                    _local_11.id = _local_12.uniqueId;\r\n\r\n                    if(_local_12.update(k, _arg_3))\r\n                    {\r\n                        if(_local_12.visible)\r\n                        {\r\n                            depth = ((_local_12.relativeDepth + this.floorRelativeDepth) + (_local_10 / 1000));\r\n\r\n                            if(_local_12.type !== RoomPlane.TYPE_FLOOR)\r\n                            {\r\n                                depth = ((_local_12.relativeDepth + this.wallRelativeDepth) + (_local_10 / 1000));\r\n\r\n                                if((_local_12.leftSide.length < 1) || (_local_12.rightSide.length < 1))\r\n                                {\r\n                                    depth = (depth + (RoomVisualization.ROOM_DEPTH_OFFSET * 0.5));\r\n                                }\r\n                            }\r\n\r\n                            const _local_14 = ((('plane ' + _local_10) + ' ') + k.scale);\r\n\r\n                            this.updateSprite(_local_11, _local_12, _local_14, depth);\r\n                        }\r\n                        updated = true;\r\n                    }\r\n                    if(_local_11.visible != ((_local_12.visible) && (this._typeVisibility[_local_12.type])))\r\n                    {\r\n                        _local_11.visible = (!(_local_11.visible));\r\n                        updated = true;\r\n                    }\r\n                    if(_local_11.visible)\r\n                    {\r\n                        if(!_local_8)\r\n                        {\r\n                            this._visiblePlanes.push(_local_12);\r\n                            this._visiblePlaneSpriteNumbers.push(index);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    _local_11.id = 0;\r\n                    if(_local_11.visible)\r\n                    {\r\n                        _local_11.visible = false;\r\n                        updated = true;\r\n                    }\r\n                }\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return updated;\r\n    }\r\n\r\n    protected updatePlaneMasks(k: RoomMapMaskData): void\r\n    {\r\n        if(!k) return;\r\n\r\n        this._roomPlaneBitmapMaskParser.initialize(k);\r\n\r\n        const _local_4: number[] = [];\r\n        const _local_5: number[] = [];\r\n\r\n        let _local_6 = false;\r\n        let index = 0;\r\n\r\n        while(index < this._planes.length)\r\n        {\r\n            const plane = this._planes[index];\r\n\r\n            if(plane)\r\n            {\r\n                plane.resetBitmapMasks();\r\n\r\n                if(plane.type === RoomPlane.TYPE_LANDSCAPE) _local_4.push(index);\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        for(const mask of this._roomPlaneBitmapMaskParser.masks.values())\r\n        {\r\n            const maskType = this._roomPlaneBitmapMaskParser.getMaskType(mask);\r\n            const maskLocation = this._roomPlaneBitmapMaskParser.getMaskLocation(mask);\r\n            const maskCategory = this._roomPlaneBitmapMaskParser.getMaskCategory(mask);\r\n\r\n            if(maskLocation)\r\n            {\r\n                let i = 0;\r\n\r\n                while(i < this._planes.length)\r\n                {\r\n                    const plane = this._planes[i];\r\n\r\n                    if((plane.type === RoomPlane.TYPE_WALL) || (plane.type === RoomPlane.TYPE_LANDSCAPE))\r\n                    {\r\n                        if(plane && plane.location && plane.normal)\r\n                        {\r\n                            const _local_14 = Vector3d.dif(maskLocation, plane.location);\r\n                            const _local_15 = Math.abs(Vector3d.scalarProjection(_local_14, plane.normal));\r\n\r\n                            if(_local_15 < 0.01)\r\n                            {\r\n                                if(plane.leftSide && plane.rightSide)\r\n                                {\r\n                                    const _local_16 = Vector3d.scalarProjection(_local_14, plane.leftSide);\r\n                                    const _local_17 = Vector3d.scalarProjection(_local_14, plane.rightSide);\r\n\r\n                                    if((plane.type === RoomPlane.TYPE_WALL) || ((plane.type === RoomPlane.TYPE_LANDSCAPE) && (maskCategory === RoomPlaneBitmapMaskData.HOLE)))\r\n                                    {\r\n                                        plane.addBitmapMask(maskType, _local_16, _local_17);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        if(plane.type === RoomPlane.TYPE_LANDSCAPE)\r\n                                        {\r\n                                            if(!plane.canBeVisible) _local_6 = true;\r\n\r\n                                            plane.canBeVisible = true;\r\n\r\n                                            _local_5.push(i);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        index = 0;\r\n\r\n        while(index < _local_4.length)\r\n        {\r\n            const planeIndex = _local_4[index];\r\n\r\n            if(_local_5.indexOf(planeIndex) < 0)\r\n            {\r\n                const plane = this._planes[planeIndex];\r\n\r\n                plane.canBeVisible = false;\r\n                _local_6 = true;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        if(_local_6)\r\n        {\r\n            this._visiblePlanes = [];\r\n            this._visiblePlaneSpriteNumbers = [];\r\n        }\r\n    }\r\n\r\n    private updateSprite(k: IRoomObjectSprite, _arg_2: RoomPlane, _arg_3: string, _arg_4: number): void\r\n    {\r\n        const offset = _arg_2.offset;\r\n\r\n        k.offsetX = -(offset.x);\r\n        k.offsetY = -(offset.y);\r\n        k.relativeDepth = _arg_4;\r\n        k.color = _arg_2.color;\r\n        k.texture = this.getPlaneBitmap(_arg_2, _arg_3);\r\n        k.name = ((_arg_3 + '_') + this._assetUpdateCounter);\r\n    }\r\n\r\n    private getPlaneBitmap(k: RoomPlane, _arg_2: string): Texture<Resource>\r\n    {\r\n        return k.bitmapData;\r\n    }\r\n\r\n    public getBoundingRectangle(): Rectangle\r\n    {\r\n        if(!this._boundingRectangle) this._boundingRectangle = super.getBoundingRectangle();\r\n\r\n        return new Rectangle(this._boundingRectangle.x, this._boundingRectangle.y, this._boundingRectangle.width, this._boundingRectangle.height);\r\n    }\r\n\r\n    public get planes(): IRoomPlane[]\r\n    {\r\n        const planes: IRoomPlane[] = [];\r\n\r\n        for(const plane of this._visiblePlanes) planes.push(plane);\r\n\r\n        return planes;\r\n    }\r\n\r\n    public get floorRelativeDepth(): number\r\n    {\r\n        return RoomVisualization.ROOM_DEPTH_OFFSET + 0.1;\r\n    }\r\n\r\n    public get wallRelativeDepth(): number\r\n    {\r\n        return RoomVisualization.ROOM_DEPTH_OFFSET + 0.5;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}