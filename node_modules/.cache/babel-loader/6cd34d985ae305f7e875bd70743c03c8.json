{"ast":null,"code":"import { Point } from '@pixi/math';\nimport { Rasterizer } from '../../../../../../../room/utils/Rasterizer';\nimport { RoomGeometry } from '../../../../../../../room/utils/RoomGeometry';\nimport { Vector3d } from '../../../../../../../room/utils/Vector3d';\nimport { FloorPlane } from './FloorPlane';\nimport { PlaneMaterial } from './PlaneMaterial';\nimport { PlaneMaterialCell } from './PlaneMaterialCell';\nimport { PlaneMaterialCellColumn } from './PlaneMaterialCellColumn';\nimport { PlaneMaterialCellMatrix } from './PlaneMaterialCellMatrix';\nimport { PlaneTexture } from './PlaneTexture';\nimport { PlaneVisualizationLayer } from './PlaneVisualizationLayer';\nexport class PlaneRasterizer {\n  constructor() {\n    this._assetCollection = void 0;\n    this._materials = void 0;\n    this._textures = void 0;\n    this._planes = void 0;\n    this._geometries = void 0;\n    this._data = void 0;\n    this._assetCollection = null;\n    this._textures = new Map();\n    this._materials = new Map();\n    this._planes = new Map();\n    this._geometries = new Map();\n    this._data = null;\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  get assetCollection() {\n    return this._assetCollection;\n  }\n\n  initializeDimensions(k, _arg_2) {\n    return true;\n  }\n\n  dispose() {\n    if (this._planes) {\n      for (const plane of this._planes.values()) {\n        if (!plane) continue;\n        plane.dispose();\n      }\n\n      this._planes = null;\n    }\n\n    if (this._materials) {\n      this.resetMaterials();\n      this._materials = null;\n    }\n\n    if (this._textures) {\n      this.resetTextures();\n      this._textures = null;\n    }\n\n    if (this._geometries) {\n      for (const geometry of this._geometries.values()) {\n        if (!geometry) continue;\n        geometry.dispose();\n      }\n\n      this._geometries = null;\n    }\n\n    this._data = null;\n    this._assetCollection = null;\n  }\n\n  clearCache() {\n    for (const plane of this._planes.values()) {\n      if (!plane) continue;\n      plane.clearCache();\n    }\n\n    for (const material of this._materials.values()) {\n      if (!material) continue;\n      material.clearCache();\n    }\n  }\n\n  initialize(data) {\n    this._data = data;\n  }\n\n  reinitialize() {\n    this.resetTextures();\n    this.resetMaterials();\n    this.initializeAll();\n  }\n\n  resetMaterials() {\n    for (const material of this._materials.values()) {\n      if (!material) continue;\n      material.dispose();\n    }\n\n    this._materials.clear();\n  }\n\n  resetTextures() {\n    for (const texture of this._textures.values()) {\n      if (!texture) continue;\n      texture.dispose();\n    }\n\n    this._textures.clear();\n  }\n\n  getTexture(textureId) {\n    return this._textures.get(textureId);\n  }\n\n  getMaterial(materialId) {\n    return this._materials.get(materialId);\n  }\n\n  getPlane(planeId) {\n    return this._planes.get(planeId);\n  }\n\n  addPlane(id, plane) {\n    if (!plane) return false;\n\n    const existing = this._planes.get(id);\n\n    if (!existing) {\n      this._planes.set(id, plane);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  initializeAssetCollection(collection) {\n    if (!this._data) return;\n    this._assetCollection = collection;\n    this.initializeAll();\n  }\n\n  initializeAll() {\n    if (!this._data) return;\n    this.initializeTexturesAndMaterials();\n    this.initializePlanes();\n  }\n\n  initializeTexturesAndMaterials() {\n    if (this._data.textures && this._data.textures.length) this.parseTextures(this._data.textures, this.assetCollection);\n    if (this._data.materials && this._data.materials.length) this.parsePlaneMaterials(this._data.materials);\n  }\n\n  initializePlanes() {}\n\n  parseTextures(textures, collection) {\n    if (!textures || !collection) return;\n\n    if (textures.length) {\n      for (const texture of textures) {\n        if (!texture) continue;\n        const id = texture.id;\n\n        if (!this._textures.get(id)) {\n          const plane = new PlaneTexture();\n\n          if (texture.bitmaps && texture.bitmaps.length) {\n            for (const bitmap of texture.bitmaps) {\n              if (!bitmap) continue;\n              const assetName = bitmap.assetName;\n              let normalMinX = PlaneTexture.MIN_NORMAL_COORDINATE_VALUE;\n              let normalMaxX = PlaneTexture.MAX_NORMAL_COORDINATE_VALUE;\n              let normalMinY = PlaneTexture.MIN_NORMAL_COORDINATE_VALUE;\n              let normalMaxY = PlaneTexture.MAX_NORMAL_COORDINATE_VALUE;\n              if (bitmap.normalMinX !== undefined) normalMinX = bitmap.normalMinX;\n              if (bitmap.normalMaxX !== undefined) normalMaxX = bitmap.normalMaxX;\n              if (bitmap.normalMinY !== undefined) normalMinY = bitmap.normalMinY;\n              if (bitmap.normalMaxY !== undefined) normalMaxY = bitmap.normalMaxY;\n              const asset = collection.getAsset(assetName);\n\n              if (asset) {\n                const texture = asset.texture;\n\n                if (texture) {\n                  let newTexture = texture;\n\n                  if (asset.flipH) {\n                    newTexture = Rasterizer.getFlipHBitmapData(texture);\n                  }\n\n                  plane.addBitmap(newTexture, normalMinX, normalMaxX, normalMinY, normalMaxY, assetName);\n                }\n              }\n            }\n          }\n\n          this._textures.set(id, plane);\n        }\n      }\n    }\n  }\n\n  parsePlaneMaterials(materials) {\n    if (!materials || !materials.length) return;\n\n    for (const material of materials) {\n      if (!material) continue;\n      const id = material.id;\n      const newMaterial = new PlaneMaterial();\n\n      if (material.matrices && material.matrices.length) {\n        for (const matrix of material.matrices) {\n          if (!matrix) continue;\n          let repeatMode = matrix.repeatMode;\n          let align = matrix.align;\n          const normalMinX = PlaneMaterialCellMatrix.MIN_NORMAL_COORDINATE_VALUE;\n          const normalMaxX = PlaneMaterialCellMatrix.MAX_NORMAL_COORDINATE_VALUE;\n          const normalMinY = PlaneMaterialCellMatrix.MIN_NORMAL_COORDINATE_VALUE;\n          const normalMaxY = PlaneMaterialCellMatrix.MAX_NORMAL_COORDINATE_VALUE;\n\n          switch (repeatMode) {\n            case 'borders':\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_BORDERS;\n              break;\n\n            case 'center':\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_CENTER;\n              break;\n\n            case 'first':\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_FIRST;\n              break;\n\n            case 'last':\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_LAST;\n              break;\n\n            case 'random':\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_RANDOM;\n              break;\n\n            default:\n              repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_DEFAULT;\n              break;\n          }\n\n          switch (align) {\n            case 'top':\n              align = PlaneMaterialCellMatrix.ALIGN_TOP;\n              break;\n\n            case 'bottom':\n              align = PlaneMaterialCellMatrix.ALIGN_BOTTOM;\n              break;\n\n            default:\n              align = PlaneMaterialCellMatrix.ALIGN_DEFAULT;\n              break;\n          }\n\n          if (matrix.columns && matrix.columns.length) {\n            const cellMatrix = newMaterial.addMaterialCellMatrix(matrix.columns.length, repeatMode, align, normalMinX, normalMaxX, normalMinY, normalMaxY);\n            let index = 0;\n\n            while (index < matrix.columns.length) {\n              const column = matrix.columns[index];\n              if (column) this.parsePlaneMaterialCellColumn(column, cellMatrix, index);\n              index++;\n            }\n          }\n        }\n      }\n\n      this._materials.set(id, newMaterial);\n    }\n  }\n\n  parsePlaneMaterialCellColumn(column, cellMatrix, index) {\n    if (!column || !cellMatrix) return;\n    let repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_ALL;\n    const width = column.width;\n    const cells = this.parsePlaneMaterialCells(column);\n\n    switch (column.repeatMode) {\n      case 'borders':\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_BORDERS;\n        break;\n\n      case 'center':\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_CENTER;\n        break;\n\n      case 'first':\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_FIRST;\n        break;\n\n      case 'last':\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_LAST;\n        break;\n\n      case 'none':\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_NONE;\n        break;\n\n      default:\n        repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_ALL;\n        break;\n    }\n\n    cellMatrix.createColumn(index, width, cells, repeatMode);\n  }\n\n  parsePlaneMaterialCells(column) {\n    if (!column || !column.cells || !column.cells.length) return null;\n    const cells = [];\n    let index = 0;\n\n    while (index < column.cells.length) {\n      const cell = column.cells[index];\n\n      if (cell) {\n        const textureId = cell.textureId;\n        let assetNames = null;\n        let offsetPoints = null;\n        let graphics = null;\n        let limit = 0;\n\n        if (cell.extras && cell.extras.length) {\n          const extra = cell.extras[0];\n          const types = extra.types;\n          const offsets = extra.offsets;\n\n          if (types && offsets) {\n            if (types.length && offsets.length) {\n              const type = types[0];\n              const offset = offsets[0];\n              assetNames = this.parseExtraItemTypes(type);\n              offsetPoints = this.parseExtraItemOffsets(offset);\n              limit = offsetPoints.length;\n              if (extra.limitMax) limit = extra.limitMax;\n            }\n          }\n        }\n\n        if (assetNames && assetNames.length) {\n          graphics = [];\n\n          for (const assetName of assetNames) {\n            if (!assetName) continue;\n\n            const asset = this._assetCollection.getAsset(assetName);\n\n            if (!asset) continue;\n            graphics.push(asset);\n          }\n        }\n\n        const texture = this.getTexture(textureId);\n        const newCell = new PlaneMaterialCell(texture, graphics, offsetPoints, limit);\n        cells.push(newCell);\n      }\n\n      index++;\n    }\n\n    if (!cells || !cells.length) return null;\n    return cells;\n  }\n\n  parseExtraItemTypes(k) {\n    const assetNames = [];\n\n    if (k && k.types && k.types.length) {\n      let index = 0;\n\n      while (index < k.types.length) {\n        const type = k.types[index];\n        const assetName = type.assetName;\n        if (assetName) assetNames.push(assetName);\n        index++;\n      }\n    }\n\n    return assetNames;\n  }\n\n  parseExtraItemOffsets(k) {\n    const offsets = [];\n\n    if (k && k.offsets && k.offsets.length) {\n      let index = 0;\n\n      while (index < k.offsets.length) {\n        const offset = k.offsets[index];\n        const x = offset.x;\n        const y = offset.y;\n        offsets.push(new Point(x, y));\n        index++;\n      }\n    }\n\n    return offsets;\n  }\n\n  getGeometry(size, horizontalAngle, verticalAngle) {\n    horizontalAngle = Math.abs(horizontalAngle);\n    if (horizontalAngle > 90) horizontalAngle = 90;\n    verticalAngle = Math.abs(verticalAngle);\n    if (verticalAngle > 90) verticalAngle = 90;\n    const identifier = `${size}_${Math.round(horizontalAngle)}_${Math.round(verticalAngle)}`;\n\n    let geometry = this._geometries.get(identifier);\n\n    if (geometry) return geometry;\n    geometry = new RoomGeometry(size, new Vector3d(horizontalAngle, verticalAngle), new Vector3d(-10, 0, 0));\n\n    this._geometries.set(identifier, geometry);\n\n    return geometry;\n  }\n\n  parseVisualizations(plane, visualizations) {\n    if (!plane || !visualizations) return;\n\n    if (visualizations && visualizations.length) {\n      for (const visualization of visualizations) {\n        if (!visualization) continue;\n        const size = visualization.size;\n        let horizontalAngle = FloorPlane.HORIZONTAL_ANGLE_DEFAULT;\n        let verticalAngle = FloorPlane.VERTICAL_ANGLE_DEFAULT;\n        if (visualization.horizontalAngle) horizontalAngle = visualization.horizontalAngle;\n        if (visualization.verticalAngle) verticalAngle = visualization.verticalAngle;\n        const layers = visualization.layers;\n        const planeVisualization = plane.createPlaneVisualization(size, layers && layers.length || 0, this.getGeometry(size, horizontalAngle, verticalAngle));\n\n        if (planeVisualization && layers && layers.length) {\n          let layerId = 0;\n\n          while (layerId < layers.length) {\n            const layer = layers[layerId];\n\n            if (layer) {\n              let material = null;\n              let align = PlaneVisualizationLayer.ALIGN_DEFAULT;\n              let color = FloorPlane.DEFAULT_COLOR;\n              let offset = PlaneVisualizationLayer.DEFAULT_OFFSET;\n              if (layer.materialId) material = this.getMaterial(layer.materialId);\n              if (layer.color) color = layer.color;\n              if (layer.offset) offset = layer.offset;\n\n              if (layer.align) {\n                if (layer.align === 'bottom') align = PlaneVisualizationLayer.ALIGN_BOTTOM;else if (layer.align == 'top') align = PlaneVisualizationLayer.ALIGN_TOP;\n              }\n\n              planeVisualization.setLayer(layerId, material, color, align, offset);\n            }\n\n            layerId++;\n          }\n        }\n      }\n    }\n  }\n\n  render(canvas, id, width, height, size, normal, useTexture) {\n    let offsetX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let offsetY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let maxX = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let maxY = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    let timeSinceStartMs = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;\n    return null;\n  }\n\n  getTextureIdentifier(k, normal) {\n    return k.toString();\n  }\n\n  getLayers(id) {\n    let planes = this.getPlane(id);\n    if (!planes) planes = this.getPlane(PlaneRasterizer.DEFAULT);\n    return planes.getLayers();\n  }\n\n}\nPlaneRasterizer.DEFAULT = 'default';","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/rasterizer/basic/PlaneRasterizer.ts"],"names":["Point","Rasterizer","RoomGeometry","Vector3d","FloorPlane","PlaneMaterial","PlaneMaterialCell","PlaneMaterialCellColumn","PlaneMaterialCellMatrix","PlaneTexture","PlaneVisualizationLayer","PlaneRasterizer","constructor","_assetCollection","_materials","_textures","_planes","_geometries","_data","Map","data","assetCollection","initializeDimensions","k","_arg_2","dispose","plane","values","resetMaterials","resetTextures","geometry","clearCache","material","initialize","reinitialize","initializeAll","clear","texture","getTexture","textureId","get","getMaterial","materialId","getPlane","planeId","addPlane","id","existing","set","initializeAssetCollection","collection","initializeTexturesAndMaterials","initializePlanes","textures","length","parseTextures","materials","parsePlaneMaterials","bitmaps","bitmap","assetName","normalMinX","MIN_NORMAL_COORDINATE_VALUE","normalMaxX","MAX_NORMAL_COORDINATE_VALUE","normalMinY","normalMaxY","undefined","asset","getAsset","newTexture","flipH","getFlipHBitmapData","addBitmap","newMaterial","matrices","matrix","repeatMode","align","REPEAT_MODE_BORDERS","REPEAT_MODE_CENTER","REPEAT_MODE_FIRST","REPEAT_MODE_LAST","REPEAT_MODE_RANDOM","REPEAT_MODE_DEFAULT","ALIGN_TOP","ALIGN_BOTTOM","ALIGN_DEFAULT","columns","cellMatrix","addMaterialCellMatrix","index","column","parsePlaneMaterialCellColumn","REPEAT_MODE_ALL","width","cells","parsePlaneMaterialCells","REPEAT_MODE_NONE","createColumn","cell","assetNames","offsetPoints","graphics","limit","extras","extra","types","offsets","type","offset","parseExtraItemTypes","parseExtraItemOffsets","limitMax","push","newCell","x","y","getGeometry","size","horizontalAngle","verticalAngle","Math","abs","identifier","round","parseVisualizations","visualizations","visualization","HORIZONTAL_ANGLE_DEFAULT","VERTICAL_ANGLE_DEFAULT","layers","planeVisualization","createPlaneVisualization","layerId","layer","color","DEFAULT_COLOR","DEFAULT_OFFSET","setLayer","render","canvas","height","normal","useTexture","offsetX","offsetY","maxX","maxY","timeSinceStartMs","getTextureIdentifier","toString","getLayers","planes","DEFAULT"],"mappings":"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","sourcesContent":["import { Resource, Texture } from '@pixi/core';\r\nimport { Graphics } from '@pixi/graphics';\r\nimport { Point } from '@pixi/math';\r\nimport { IGraphicAsset } from '../../../../../../../room/object/visualization/utils/IGraphicAsset';\r\nimport { IGraphicAssetCollection } from '../../../../../../../room/object/visualization/utils/IGraphicAssetCollection';\r\nimport { IRoomGeometry } from '../../../../../../../room/utils/IRoomGeometry';\r\nimport { IVector3D } from '../../../../../../../room/utils/IVector3D';\r\nimport { Rasterizer } from '../../../../../../../room/utils/Rasterizer';\r\nimport { RoomGeometry } from '../../../../../../../room/utils/RoomGeometry';\r\nimport { Vector3d } from '../../../../../../../room/utils/Vector3d';\r\nimport { PlaneBitmapData } from '../../utils/PlaneBitmapData';\r\nimport { IPlaneRasterizer } from '../IPlaneRasterizer';\r\nimport { FloorPlane } from './FloorPlane';\r\nimport { Plane } from './Plane';\r\nimport { PlaneMaterial } from './PlaneMaterial';\r\nimport { PlaneMaterialCell } from './PlaneMaterialCell';\r\nimport { PlaneMaterialCellColumn } from './PlaneMaterialCellColumn';\r\nimport { PlaneMaterialCellMatrix } from './PlaneMaterialCellMatrix';\r\nimport { PlaneTexture } from './PlaneTexture';\r\nimport { PlaneVisualizationLayer } from './PlaneVisualizationLayer';\r\n\r\nexport class PlaneRasterizer implements IPlaneRasterizer\r\n{\r\n    protected static DEFAULT: string = 'default';\r\n\r\n    private _assetCollection: IGraphicAssetCollection;\r\n    private _materials: Map<string, PlaneMaterial>;\r\n    private _textures: Map<string, PlaneTexture>;\r\n    private _planes: Map<string, Plane>;\r\n    private _geometries: Map<string, RoomGeometry>;\r\n    private _data: any;\r\n\r\n    constructor()\r\n    {\r\n        this._assetCollection = null;\r\n        this._textures = new Map();\r\n        this._materials = new Map();\r\n        this._planes = new Map();\r\n        this._geometries = new Map();\r\n        this._data = null;\r\n    }\r\n\r\n    protected get data(): any\r\n    {\r\n        return this._data;\r\n    }\r\n\r\n    protected get assetCollection(): IGraphicAssetCollection\r\n    {\r\n        return this._assetCollection;\r\n    }\r\n\r\n    public initializeDimensions(k: number, _arg_2: number): boolean\r\n    {\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._planes)\r\n        {\r\n            for(const plane of this._planes.values())\r\n            {\r\n                if(!plane) continue;\r\n\r\n                plane.dispose();\r\n            }\r\n\r\n            this._planes = null;\r\n        }\r\n\r\n        if(this._materials)\r\n        {\r\n            this.resetMaterials();\r\n\r\n            this._materials = null;\r\n        }\r\n\r\n        if(this._textures)\r\n        {\r\n            this.resetTextures();\r\n\r\n            this._textures = null;\r\n        }\r\n\r\n        if(this._geometries)\r\n        {\r\n            for(const geometry of this._geometries.values())\r\n            {\r\n                if(!geometry) continue;\r\n\r\n                geometry.dispose();\r\n            }\r\n\r\n            this._geometries = null;\r\n        }\r\n\r\n        this._data = null;\r\n        this._assetCollection = null;\r\n    }\r\n\r\n    public clearCache(): void\r\n    {\r\n        for(const plane of this._planes.values())\r\n        {\r\n            if(!plane) continue;\r\n\r\n            plane.clearCache();\r\n        }\r\n\r\n        for(const material of this._materials.values())\r\n        {\r\n            if(!material) continue;\r\n\r\n            material.clearCache();\r\n        }\r\n    }\r\n\r\n    public initialize(data: any): void\r\n    {\r\n        this._data = data;\r\n    }\r\n\r\n    public reinitialize(): void\r\n    {\r\n        this.resetTextures();\r\n        this.resetMaterials();\r\n        this.initializeAll();\r\n    }\r\n\r\n    private resetMaterials(): void\r\n    {\r\n        for(const material of this._materials.values())\r\n        {\r\n            if(!material) continue;\r\n\r\n            material.dispose();\r\n        }\r\n\r\n        this._materials.clear();\r\n    }\r\n\r\n    private resetTextures(): void\r\n    {\r\n        for(const texture of this._textures.values())\r\n        {\r\n            if(!texture) continue;\r\n\r\n            texture.dispose();\r\n        }\r\n\r\n        this._textures.clear();\r\n    }\r\n\r\n    protected getTexture(textureId: string): PlaneTexture\r\n    {\r\n        return this._textures.get(textureId);\r\n    }\r\n\r\n    protected getMaterial(materialId: string): PlaneMaterial\r\n    {\r\n        return this._materials.get(materialId);\r\n    }\r\n\r\n    protected getPlane(planeId: string): Plane\r\n    {\r\n        return this._planes.get(planeId);\r\n    }\r\n\r\n    protected addPlane(id: string, plane: Plane): boolean\r\n    {\r\n        if(!plane) return false;\r\n\r\n        const existing = this._planes.get(id);\r\n\r\n        if(!existing)\r\n        {\r\n            this._planes.set(id, plane);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public initializeAssetCollection(collection: IGraphicAssetCollection): void\r\n    {\r\n        if(!this._data) return;\r\n\r\n        this._assetCollection = collection;\r\n\r\n        this.initializeAll();\r\n    }\r\n\r\n    private initializeAll(): void\r\n    {\r\n        if(!this._data) return;\r\n\r\n        this.initializeTexturesAndMaterials();\r\n\r\n        this.initializePlanes();\r\n    }\r\n\r\n    private initializeTexturesAndMaterials(): void\r\n    {\r\n        if(this._data.textures && this._data.textures.length) this.parseTextures(this._data.textures, this.assetCollection);\r\n\r\n        if(this._data.materials && this._data.materials.length) this.parsePlaneMaterials(this._data.materials);\r\n    }\r\n\r\n    protected initializePlanes(): void\r\n    {\r\n    }\r\n\r\n    private parseTextures(textures: any, collection: IGraphicAssetCollection): void\r\n    {\r\n        if(!textures || !collection) return;\r\n\r\n        if(textures.length)\r\n        {\r\n            for(const texture of textures)\r\n            {\r\n                if(!texture) continue;\r\n\r\n                const id = texture.id;\r\n\r\n                if(!this._textures.get(id))\r\n                {\r\n                    const plane = new PlaneTexture();\r\n\r\n                    if(texture.bitmaps && texture.bitmaps.length)\r\n                    {\r\n                        for(const bitmap of texture.bitmaps)\r\n                        {\r\n                            if(!bitmap) continue;\r\n\r\n                            const assetName = bitmap.assetName;\r\n\r\n                            let normalMinX = PlaneTexture.MIN_NORMAL_COORDINATE_VALUE;\r\n                            let normalMaxX = PlaneTexture.MAX_NORMAL_COORDINATE_VALUE;\r\n                            let normalMinY = PlaneTexture.MIN_NORMAL_COORDINATE_VALUE;\r\n                            let normalMaxY = PlaneTexture.MAX_NORMAL_COORDINATE_VALUE;\r\n\r\n                            if(bitmap.normalMinX !== undefined) normalMinX = bitmap.normalMinX;\r\n                            if(bitmap.normalMaxX !== undefined) normalMaxX = bitmap.normalMaxX;\r\n                            if(bitmap.normalMinY !== undefined) normalMinY = bitmap.normalMinY;\r\n                            if(bitmap.normalMaxY !== undefined) normalMaxY = bitmap.normalMaxY;\r\n\r\n                            const asset = collection.getAsset(assetName);\r\n\r\n                            if(asset)\r\n                            {\r\n                                const texture = asset.texture;\r\n\r\n                                if(texture)\r\n                                {\r\n                                    let newTexture: Texture<Resource> = texture;\r\n\r\n                                    if(asset.flipH)\r\n                                    {\r\n                                        newTexture = Rasterizer.getFlipHBitmapData(texture);\r\n                                    }\r\n\r\n                                    plane.addBitmap(newTexture, normalMinX, normalMaxX, normalMinY, normalMaxY, assetName);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this._textures.set(id, plane);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private parsePlaneMaterials(materials: any): void\r\n    {\r\n        if(!materials || !materials.length) return;\r\n\r\n        for(const material of materials)\r\n        {\r\n            if(!material) continue;\r\n\r\n            const id = material.id;\r\n            const newMaterial = new PlaneMaterial();\r\n\r\n            if(material.matrices && material.matrices.length)\r\n            {\r\n                for(const matrix of material.matrices)\r\n                {\r\n                    if(!matrix) continue;\r\n\r\n                    let repeatMode = matrix.repeatMode;\r\n                    let align = matrix.align;\r\n                    const normalMinX = PlaneMaterialCellMatrix.MIN_NORMAL_COORDINATE_VALUE;\r\n                    const normalMaxX = PlaneMaterialCellMatrix.MAX_NORMAL_COORDINATE_VALUE;\r\n                    const normalMinY = PlaneMaterialCellMatrix.MIN_NORMAL_COORDINATE_VALUE;\r\n                    const normalMaxY = PlaneMaterialCellMatrix.MAX_NORMAL_COORDINATE_VALUE;\r\n\r\n                    switch(repeatMode)\r\n                    {\r\n                        case 'borders':\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_BORDERS;\r\n                            break;\r\n                        case 'center':\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_CENTER;\r\n                            break;\r\n                        case 'first':\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_FIRST;\r\n                            break;\r\n                        case 'last':\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_LAST;\r\n                            break;\r\n                        case 'random':\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_RANDOM;\r\n                            break;\r\n                        default:\r\n                            repeatMode = PlaneMaterialCellMatrix.REPEAT_MODE_DEFAULT;\r\n                            break;\r\n                    }\r\n\r\n                    switch(align)\r\n                    {\r\n                        case 'top':\r\n                            align = PlaneMaterialCellMatrix.ALIGN_TOP;\r\n                            break;\r\n                        case 'bottom':\r\n                            align = PlaneMaterialCellMatrix.ALIGN_BOTTOM;\r\n                            break;\r\n                        default:\r\n                            align = PlaneMaterialCellMatrix.ALIGN_DEFAULT;\r\n                            break;\r\n                    }\r\n\r\n                    if(matrix.columns && matrix.columns.length)\r\n                    {\r\n                        const cellMatrix = newMaterial.addMaterialCellMatrix(matrix.columns.length, repeatMode, align, normalMinX, normalMaxX, normalMinY, normalMaxY);\r\n\r\n                        let index = 0;\r\n\r\n                        while(index < matrix.columns.length)\r\n                        {\r\n                            const column = matrix.columns[index];\r\n\r\n                            if(column) this.parsePlaneMaterialCellColumn(column, cellMatrix, index);\r\n\r\n                            index++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._materials.set(id, newMaterial);\r\n        }\r\n    }\r\n\r\n    private parsePlaneMaterialCellColumn(column: { repeatMode: string, width: number }, cellMatrix: PlaneMaterialCellMatrix, index: number): void\r\n    {\r\n        if(!column || !cellMatrix) return;\r\n\r\n        let repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_ALL;\r\n\r\n        const width = column.width;\r\n\r\n        const cells = this.parsePlaneMaterialCells(column);\r\n\r\n        switch(column.repeatMode)\r\n        {\r\n            case 'borders':\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_BORDERS;\r\n                break;\r\n            case 'center':\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_CENTER;\r\n                break;\r\n            case 'first':\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_FIRST;\r\n                break;\r\n            case 'last':\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_LAST;\r\n                break;\r\n            case 'none':\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_NONE;\r\n                break;\r\n            default:\r\n                repeatMode = PlaneMaterialCellColumn.REPEAT_MODE_ALL;\r\n                break;\r\n        }\r\n\r\n        cellMatrix.createColumn(index, width, cells, repeatMode);\r\n    }\r\n\r\n    private parsePlaneMaterialCells(column: any): PlaneMaterialCell[]\r\n    {\r\n        if(!column || !column.cells || !column.cells.length) return null;\r\n\r\n        const cells: PlaneMaterialCell[] = [];\r\n\r\n        let index = 0;\r\n\r\n        while(index < column.cells.length)\r\n        {\r\n            const cell = column.cells[index];\r\n\r\n            if(cell)\r\n            {\r\n                const textureId = cell.textureId;\r\n\r\n                let assetNames: string[] = null;\r\n                let offsetPoints: Point[] = null;\r\n                let graphics: IGraphicAsset[] = null;\r\n                let limit = 0;\r\n\r\n                if(cell.extras && cell.extras.length)\r\n                {\r\n                    const extra = cell.extras[0];\r\n                    const types = extra.types;\r\n                    const offsets = extra.offsets;\r\n\r\n                    if(types && offsets)\r\n                    {\r\n                        if(types.length && offsets.length)\r\n                        {\r\n                            const type = types[0];\r\n                            const offset = offsets[0];\r\n\r\n                            assetNames = this.parseExtraItemTypes(type);\r\n                            offsetPoints = this.parseExtraItemOffsets(offset);\r\n                            limit = offsetPoints.length;\r\n\r\n                            if(extra.limitMax) limit = extra.limitMax;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(assetNames && assetNames.length)\r\n                {\r\n                    graphics = [];\r\n\r\n                    for(const assetName of assetNames)\r\n                    {\r\n                        if(!assetName) continue;\r\n\r\n                        const asset = this._assetCollection.getAsset(assetName);\r\n\r\n                        if(!asset) continue;\r\n\r\n                        graphics.push(asset);\r\n                    }\r\n                }\r\n\r\n                const texture = this.getTexture(textureId);\r\n                const newCell = new PlaneMaterialCell(texture, graphics, offsetPoints, limit);\r\n\r\n                cells.push(newCell);\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        if(!cells || !cells.length) return null;\r\n\r\n        return cells;\r\n    }\r\n\r\n    private parseExtraItemTypes(k: any): string[]\r\n    {\r\n        const assetNames: string[] = [];\r\n\r\n        if(k && k.types && k.types.length)\r\n        {\r\n            let index = 0;\r\n\r\n            while(index < k.types.length)\r\n            {\r\n                const type = k.types[index];\r\n\r\n                const assetName = type.assetName;\r\n\r\n                if(assetName) assetNames.push(assetName);\r\n\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return assetNames;\r\n    }\r\n\r\n    private parseExtraItemOffsets(k: any): Point[]\r\n    {\r\n        const offsets: Point[] = [];\r\n\r\n        if(k && k.offsets && k.offsets.length)\r\n        {\r\n            let index = 0;\r\n\r\n            while(index < k.offsets.length)\r\n            {\r\n                const offset = k.offsets[index];\r\n\r\n                const x = offset.x;\r\n                const y = offset.y;\r\n\r\n                offsets.push(new Point(x, y));\r\n\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return offsets;\r\n    }\r\n\r\n    protected getGeometry(size: number, horizontalAngle: number, verticalAngle: number): IRoomGeometry\r\n    {\r\n        horizontalAngle = Math.abs(horizontalAngle);\r\n        if(horizontalAngle > 90) horizontalAngle = 90;\r\n\r\n        verticalAngle = Math.abs(verticalAngle);\r\n        if(verticalAngle > 90) verticalAngle = 90;\r\n\r\n        const identifier = `${ size }_${ Math.round(horizontalAngle) }_${ Math.round(verticalAngle) }`;\r\n\r\n        let geometry = this._geometries.get(identifier);\r\n\r\n        if(geometry) return geometry;\r\n\r\n        geometry = new RoomGeometry(size, new Vector3d(horizontalAngle, verticalAngle), new Vector3d(-10, 0, 0));\r\n\r\n        this._geometries.set(identifier, geometry);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    protected parseVisualizations(plane: Plane, visualizations: any): void\r\n    {\r\n        if(!plane || !visualizations) return;\r\n\r\n        if(visualizations && visualizations.length)\r\n        {\r\n            for(const visualization of visualizations)\r\n            {\r\n                if(!visualization) continue;\r\n\r\n                const size = visualization.size;\r\n\r\n                let horizontalAngle = FloorPlane.HORIZONTAL_ANGLE_DEFAULT;\r\n                let verticalAngle = FloorPlane.VERTICAL_ANGLE_DEFAULT;\r\n\r\n                if(visualization.horizontalAngle) horizontalAngle = visualization.horizontalAngle;\r\n                if(visualization.verticalAngle) verticalAngle = visualization.verticalAngle;\r\n\r\n                const layers = visualization.layers;\r\n\r\n                const planeVisualization = plane.createPlaneVisualization(size, ((layers && layers.length) || 0), this.getGeometry(size, horizontalAngle, verticalAngle));\r\n\r\n                if(planeVisualization && (layers && layers.length))\r\n                {\r\n                    let layerId = 0;\r\n\r\n                    while(layerId < layers.length)\r\n                    {\r\n                        const layer = layers[layerId];\r\n\r\n                        if(layer)\r\n                        {\r\n                            let material: PlaneMaterial = null;\r\n                            let align: number = PlaneVisualizationLayer.ALIGN_DEFAULT;\r\n                            let color: number = FloorPlane.DEFAULT_COLOR;\r\n                            let offset: number = PlaneVisualizationLayer.DEFAULT_OFFSET;\r\n\r\n                            if(layer.materialId) material = this.getMaterial(layer.materialId);\r\n\r\n                            if(layer.color) color = layer.color;\r\n\r\n                            if(layer.offset) offset = layer.offset;\r\n\r\n                            if(layer.align)\r\n                            {\r\n                                if(layer.align === 'bottom') align = PlaneVisualizationLayer.ALIGN_BOTTOM;\r\n\r\n                                else if(layer.align == 'top') align = PlaneVisualizationLayer.ALIGN_TOP;\r\n                            }\r\n\r\n                            planeVisualization.setLayer(layerId, material, color, align, offset);\r\n                        }\r\n\r\n                        layerId++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public render(canvas: Graphics, id: string, width: number, height: number, size: number, normal: IVector3D, useTexture: boolean, offsetX: number = 0, offsetY: number = 0, maxX: number = 0, maxY: number = 0, timeSinceStartMs: number = 0): PlaneBitmapData\r\n    {\r\n        return null;\r\n    }\r\n\r\n    public getTextureIdentifier(k: number, normal: IVector3D): string\r\n    {\r\n        return k.toString();\r\n    }\r\n\r\n    public getLayers(id: string): PlaneVisualizationLayer[]\r\n    {\r\n        let planes = this.getPlane(id);\r\n\r\n        if(!planes) planes = this.getPlane(PlaneRasterizer.DEFAULT);\r\n\r\n        return planes.getLayers();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}