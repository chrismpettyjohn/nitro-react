{"ast":null,"code":"import { Nitro } from '../../nitro/Nitro';\nimport { Disposable } from '../common/disposable/Disposable';\nimport { NitroLogger } from '../common/logger/NitroLogger';\nexport class EventDispatcher extends Disposable {\n  constructor() {\n    super();\n    this._logger = void 0;\n    this._listeners = void 0;\n    this._logger = new NitroLogger(this.constructor.name);\n    this._listeners = new Map();\n  }\n\n  onDispose() {\n    this.removeAllListeners();\n    super.onDispose();\n  }\n\n  addEventListener(type, callback) {\n    if (!type || !callback) return;\n\n    const existing = this._listeners.get(type);\n\n    if (!existing) {\n      this._listeners.set(type, [callback]);\n\n      return;\n    }\n\n    existing.push(callback);\n  }\n\n  removeEventListener(type, callback) {\n    if (!type || !callback) return;\n\n    const existing = this._listeners.get(type);\n\n    if (!existing || !existing.length) return;\n\n    for (const [i, cb] of existing.entries()) {\n      if (!cb || cb !== callback) continue;\n      existing.splice(i, 1);\n      if (!existing.length) this._listeners.delete(type);\n      return;\n    }\n  }\n\n  dispatchEvent(event) {\n    if (!event) return false;\n    if (Nitro.instance.getConfiguration('system.dispatcher.log')) this._logger.log(`DISPATCHED: ${event.type}`);\n    this.processEvent(event);\n    return true;\n  }\n\n  processEvent(event) {\n    const existing = this._listeners.get(event.type);\n\n    if (!existing || !existing.length) return;\n    const callbacks = [];\n\n    for (const callback of existing) {\n      if (!callback) continue;\n      callbacks.push(callback);\n    }\n\n    while (callbacks.length) {\n      const callback = callbacks.shift();\n\n      try {\n        callback(event);\n      } catch (err) {\n        this._logger.error(err.stack);\n\n        return;\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this._listeners.clear();\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/core/events/EventDispatcher.ts"],"names":["Nitro","Disposable","NitroLogger","EventDispatcher","constructor","_logger","_listeners","name","Map","onDispose","removeAllListeners","addEventListener","type","callback","existing","get","set","push","removeEventListener","length","i","cb","entries","splice","delete","dispatchEvent","event","instance","getConfiguration","log","processEvent","callbacks","shift","err","error","stack","clear"],"mappings":"AAAA,SAASA,KAAT,QAAsB,mBAAtB;AACA,SAASC,UAAT,QAA2B,iCAA3B;AAGA,SAASC,WAAT,QAA4B,8BAA5B;AAIA,OAAO,MAAMC,eAAN,SAA8BF,UAA9B,CACP;AAIIG,EAAAA,WAAW,GACX;AACI;AADJ,SAJQC,OAIR;AAAA,SAHQC,UAGR;AAGI,SAAKD,OAAL,GAAe,IAAIH,WAAJ,CAAgB,KAAKE,WAAL,CAAiBG,IAAjC,CAAf;AACA,SAAKD,UAAL,GAAkB,IAAIE,GAAJ,EAAlB;AACH;;AAESC,EAAAA,SAAS,GACnB;AACI,SAAKC,kBAAL;AAEA,UAAMD,SAAN;AACH;;AAEME,EAAAA,gBAAgB,CAACC,IAAD,EAAeC,QAAf,EACvB;AACI,QAAG,CAACD,IAAD,IAAS,CAACC,QAAb,EAAuB;;AAEvB,UAAMC,QAAQ,GAAG,KAAKR,UAAL,CAAgBS,GAAhB,CAAoBH,IAApB,CAAjB;;AAEA,QAAG,CAACE,QAAJ,EACA;AACI,WAAKR,UAAL,CAAgBU,GAAhB,CAAoBJ,IAApB,EAA0B,CAAEC,QAAF,CAA1B;;AAEA;AACH;;AAEDC,IAAAA,QAAQ,CAACG,IAAT,CAAcJ,QAAd;AACH;;AAEMK,EAAAA,mBAAmB,CAACN,IAAD,EAAeC,QAAf,EAC1B;AACI,QAAG,CAACD,IAAD,IAAS,CAACC,QAAb,EAAuB;;AAEvB,UAAMC,QAAQ,GAAG,KAAKR,UAAL,CAAgBS,GAAhB,CAAoBH,IAApB,CAAjB;;AAEA,QAAG,CAACE,QAAD,IAAa,CAACA,QAAQ,CAACK,MAA1B,EAAkC;;AAElC,SAAI,MAAM,CAAEC,CAAF,EAAKC,EAAL,CAAV,IAAuBP,QAAQ,CAACQ,OAAT,EAAvB,EACA;AACI,UAAG,CAACD,EAAD,IAAQA,EAAE,KAAKR,QAAlB,EAA6B;AAE7BC,MAAAA,QAAQ,CAACS,MAAT,CAAgBH,CAAhB,EAAmB,CAAnB;AAEA,UAAG,CAACN,QAAQ,CAACK,MAAb,EAAqB,KAAKb,UAAL,CAAgBkB,MAAhB,CAAuBZ,IAAvB;AAErB;AACH;AACJ;;AAEMa,EAAAA,aAAa,CAACC,KAAD,EACpB;AACI,QAAG,CAACA,KAAJ,EAAW,OAAO,KAAP;AAEX,QAAG1B,KAAK,CAAC2B,QAAN,CAAeC,gBAAf,CAAyC,uBAAzC,CAAH,EAAsE,KAAKvB,OAAL,CAAawB,GAAb,CAAkB,eAAeH,KAAK,CAACd,IAAM,EAA7C;AAEtE,SAAKkB,YAAL,CAAkBJ,KAAlB;AAEA,WAAO,IAAP;AACH;;AAEOI,EAAAA,YAAY,CAACJ,KAAD,EACpB;AACI,UAAMZ,QAAQ,GAAG,KAAKR,UAAL,CAAgBS,GAAhB,CAAoBW,KAAK,CAACd,IAA1B,CAAjB;;AAEA,QAAG,CAACE,QAAD,IAAa,CAACA,QAAQ,CAACK,MAA1B,EAAkC;AAElC,UAAMY,SAAS,GAAG,EAAlB;;AAEA,SAAI,MAAMlB,QAAV,IAAsBC,QAAtB,EACA;AACI,UAAG,CAACD,QAAJ,EAAc;AAEdkB,MAAAA,SAAS,CAACd,IAAV,CAAeJ,QAAf;AACH;;AAED,WAAMkB,SAAS,CAACZ,MAAhB,EACA;AACI,YAAMN,QAAQ,GAAGkB,SAAS,CAACC,KAAV,EAAjB;;AAEA,UACA;AACInB,QAAAA,QAAQ,CAACa,KAAD,CAAR;AACH,OAHD,CAKA,OAAOO,GAAP,EACA;AACI,aAAK5B,OAAL,CAAa6B,KAAb,CAAmBD,GAAG,CAACE,KAAvB;;AAEA;AACH;AACJ;AACJ;;AAEMzB,EAAAA,kBAAkB,GACzB;AACI,SAAKJ,UAAL,CAAgB8B,KAAhB;AACH;;AAtGL","sourcesContent":["import { Nitro } from '../../nitro/Nitro';\r\nimport { Disposable } from '../common/disposable/Disposable';\r\nimport { IDisposable } from '../common/disposable/IDisposable';\r\nimport { INitroLogger } from '../common/logger/INitroLogger';\r\nimport { NitroLogger } from '../common/logger/NitroLogger';\r\nimport { IEventDispatcher } from './IEventDispatcher';\r\nimport { NitroEvent } from './NitroEvent';\r\n\r\nexport class EventDispatcher extends Disposable implements IEventDispatcher, IDisposable\r\n{\r\n    private _logger: INitroLogger;\r\n    private _listeners: Map<string, Function[]>;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._logger = new NitroLogger(this.constructor.name);\r\n        this._listeners = new Map();\r\n    }\r\n\r\n    protected onDispose(): void\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        super.onDispose();\r\n    }\r\n\r\n    public addEventListener(type: string, callback: Function): void\r\n    {\r\n        if(!type || !callback) return;\r\n\r\n        const existing = this._listeners.get(type);\r\n\r\n        if(!existing)\r\n        {\r\n            this._listeners.set(type, [ callback ]);\r\n\r\n            return;\r\n        }\r\n\r\n        existing.push(callback);\r\n    }\r\n\r\n    public removeEventListener(type: string, callback: any): void\r\n    {\r\n        if(!type || !callback) return;\r\n\r\n        const existing = this._listeners.get(type);\r\n\r\n        if(!existing || !existing.length) return;\r\n\r\n        for(const [ i, cb ] of existing.entries())\r\n        {\r\n            if(!cb || (cb !== callback)) continue;\r\n\r\n            existing.splice(i, 1);\r\n\r\n            if(!existing.length) this._listeners.delete(type);\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    public dispatchEvent(event: NitroEvent): boolean\r\n    {\r\n        if(!event) return false;\r\n\r\n        if(Nitro.instance.getConfiguration<boolean>('system.dispatcher.log')) this._logger.log(`DISPATCHED: ${ event.type }`);\r\n\r\n        this.processEvent(event);\r\n\r\n        return true;\r\n    }\r\n\r\n    private processEvent(event: NitroEvent): void\r\n    {\r\n        const existing = this._listeners.get(event.type);\r\n\r\n        if(!existing || !existing.length) return;\r\n\r\n        const callbacks = [];\r\n\r\n        for(const callback of existing)\r\n        {\r\n            if(!callback) continue;\r\n\r\n            callbacks.push(callback);\r\n        }\r\n\r\n        while(callbacks.length)\r\n        {\r\n            const callback = callbacks.shift();\r\n\r\n            try\r\n            {\r\n                callback(event);\r\n            }\r\n\r\n            catch (err)\r\n            {\r\n                this._logger.error(err.stack);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public removeAllListeners(): void\r\n    {\r\n        this._listeners.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}