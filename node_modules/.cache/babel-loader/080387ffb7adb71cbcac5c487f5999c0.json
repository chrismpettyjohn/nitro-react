{"ast":null,"code":"import { Nitro } from '../../../../../../Nitro';\nimport { PlaneBitmapData } from '../../utils/PlaneBitmapData';\nimport { Randomizer } from '../../utils/Randomizer';\nimport { PlaneRasterizer } from '../basic/PlaneRasterizer';\nimport { PlaneVisualizationLayer } from '../basic/PlaneVisualizationLayer';\nimport { LandscapePlane } from './LandscapePlane';\nexport class LandscapeRasterizer extends PlaneRasterizer {\n  constructor() {\n    super(...arguments);\n    this._landscapeWidth = 0;\n    this._landscapeHeight = 0;\n  }\n\n  initializeDimensions(k, _arg_2) {\n    if (k < 0) k = 0;\n    if (_arg_2 < 0) _arg_2 = 0;\n    this._landscapeWidth = k;\n    this._landscapeHeight = _arg_2;\n    return true;\n  }\n\n  initializePlanes() {\n    if (!this.data) return;\n    const landscapes = this.data.landscapes;\n    if (landscapes && landscapes.length) this.parseLandscapes(landscapes);\n  }\n\n  parseLandscapes(k) {\n    if (!k) return;\n    const randomNumber = Math.trunc(Math.random() * 654321);\n\n    for (const landscapeIndex in k) {\n      const landscape = k[landscapeIndex];\n      if (!landscape) continue;\n      const id = landscape.id;\n      const visualizations = landscape.animatedVisualizations;\n      const plane = new LandscapePlane();\n\n      for (const visualization of visualizations) {\n        if (!visualization) continue;\n        const size = visualization.size;\n        let horizontalAngle = LandscapePlane.HORIZONTAL_ANGLE_DEFAULT;\n        let verticalAngle = LandscapePlane.VERTICAL_ANGLE_DEFAULT;\n        if (visualization.horizontalAngle) horizontalAngle = visualization.horizontalAngle;\n        if (visualization.verticalAngle) verticalAngle = visualization.verticalAngle;\n        const basicLayers = visualization.layers;\n        const animatedLayers = visualization.animationLayers;\n        const totalBasicLayers = basicLayers && basicLayers.length || 0;\n        const totalAnimatedLayers = animatedLayers && animatedLayers.length || 0;\n        const totalLayers = totalBasicLayers + totalAnimatedLayers;\n        const planeVisualization = plane.createPlaneVisualization(size, totalLayers || 0, this.getGeometry(size, horizontalAngle, verticalAngle));\n\n        if (planeVisualization) {\n          Randomizer.setSeed(randomNumber);\n          let layerId = 0;\n\n          if (totalBasicLayers) {\n            while (layerId < basicLayers.length) {\n              const layer = basicLayers[layerId];\n\n              if (layer) {\n                let material = null;\n                let align = PlaneVisualizationLayer.ALIGN_DEFAULT;\n                let color = LandscapePlane.DEFAULT_COLOR;\n                let offset = PlaneVisualizationLayer.DEFAULT_OFFSET;\n                if (layer.materialId) material = this.getMaterial(layer.materialId);\n                if (layer.color) color = layer.color;\n                if (layer.offset) offset = layer.offset;\n\n                if (layer.align) {\n                  if (layer.align === 'bottom') {\n                    align = PlaneVisualizationLayer.ALIGN_BOTTOM;\n                  } else if (layer.align === 'top') align = PlaneVisualizationLayer.ALIGN_TOP;\n                }\n\n                planeVisualization.setLayer(layerId, material, color, align, offset);\n              }\n\n              layerId++;\n            }\n          }\n\n          layerId = 0;\n\n          if (totalAnimatedLayers) {\n            const animationItems = [];\n\n            while (layerId < animatedLayers.length) {\n              const layer = animatedLayers[layerId];\n\n              if (layer) {\n                const items = layer.animationItems;\n\n                if (items && items.length) {\n                  for (const item of items) {\n                    if (item) {\n                      const id = item.id;\n                      const assetId = item.assetId;\n                      const x = this.getCoordinateValue(item.x || '', item.randomX || '');\n                      const y = this.getCoordinateValue(item.y || '', item.randomY || '');\n                      const speedX = item.speedX ? item.speedX / Nitro.instance.getConfiguration('system.animation.fps') : 0;\n                      const speedY = item.speedY ? item.speedY / Nitro.instance.getConfiguration('system.animation.fps') : 0;\n                      animationItems.push({\n                        asset: assetId,\n                        x,\n                        y,\n                        speedX,\n                        speedY\n                      });\n                    }\n                  }\n                }\n              }\n\n              layerId++;\n            }\n\n            planeVisualization.setAnimationLayer(layerId, animationItems, this.assetCollection);\n          }\n        }\n      }\n\n      if (!this.addPlane(id, plane)) plane.dispose();\n    }\n  }\n\n  getCoordinateValue(k, _arg_2) {\n    let _local_3 = 0;\n\n    if (k.length > 0) {\n      if (k.charAt(k.length - 1) === '%') {\n        k = k.substr(0, k.length - 1);\n        _local_3 = parseFloat(k) / 100;\n      }\n    }\n\n    if (_arg_2.length > 0) {\n      const _local_4 = 10000;\n\n      const _local_5 = Randomizer.getValues(1, 0, _local_4);\n\n      const _local_6 = _local_5[0] / _local_4;\n\n      if (_arg_2.charAt(_arg_2.length - 1) === '%') {\n        _arg_2 = _arg_2.substr(0, _arg_2.length - 1);\n        _local_3 = _local_3 + _local_6 * parseFloat(_arg_2) / 100;\n      }\n    }\n\n    return _local_3;\n  }\n\n  render(canvas, id, width, height, scale, normal, useTexture) {\n    let offsetX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let offsetY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let maxX = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let maxY = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    let timeSinceStartMs = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;\n    let plane = this.getPlane(id);\n    if (!plane) plane = this.getPlane(LandscapeRasterizer.DEFAULT);\n    if (!plane) return null;\n\n    if (canvas) {\n      canvas.clear();\n    }\n\n    let graphic = plane.render(canvas, width, height, scale, normal, useTexture, offsetX, offsetY, maxX, maxY, timeSinceStartMs);\n\n    if (graphic && graphic !== canvas) {\n      graphic = graphic.clone();\n      if (!graphic) return null;\n    }\n\n    let planeBitmapData = null;\n\n    if (!plane.isStatic(scale) && LandscapeRasterizer.UPDATE_INTERVAL > 0) {\n      planeBitmapData = new PlaneBitmapData(graphic, Math.round(timeSinceStartMs / LandscapeRasterizer.UPDATE_INTERVAL) * LandscapeRasterizer.UPDATE_INTERVAL + LandscapeRasterizer.UPDATE_INTERVAL);\n    } else {\n      planeBitmapData = new PlaneBitmapData(graphic, -1);\n    }\n\n    return planeBitmapData;\n  }\n\n  getTextureIdentifier(k, _arg_2) {\n    if (_arg_2) {\n      if (_arg_2.x < 0) return k + '_0';\n      return k + '_1';\n    }\n\n    return super.getTextureIdentifier(k, _arg_2);\n  }\n\n}\nLandscapeRasterizer.UPDATE_INTERVAL = 500;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/room/rasterizer/animated/LandscapeRasterizer.ts"],"names":["Nitro","PlaneBitmapData","Randomizer","PlaneRasterizer","PlaneVisualizationLayer","LandscapePlane","LandscapeRasterizer","_landscapeWidth","_landscapeHeight","initializeDimensions","k","_arg_2","initializePlanes","data","landscapes","length","parseLandscapes","randomNumber","Math","trunc","random","landscapeIndex","landscape","id","visualizations","animatedVisualizations","plane","visualization","size","horizontalAngle","HORIZONTAL_ANGLE_DEFAULT","verticalAngle","VERTICAL_ANGLE_DEFAULT","basicLayers","layers","animatedLayers","animationLayers","totalBasicLayers","totalAnimatedLayers","totalLayers","planeVisualization","createPlaneVisualization","getGeometry","setSeed","layerId","layer","material","align","ALIGN_DEFAULT","color","DEFAULT_COLOR","offset","DEFAULT_OFFSET","materialId","getMaterial","ALIGN_BOTTOM","ALIGN_TOP","setLayer","animationItems","items","item","assetId","x","getCoordinateValue","randomX","y","randomY","speedX","instance","getConfiguration","speedY","push","asset","setAnimationLayer","assetCollection","addPlane","dispose","_local_3","charAt","substr","parseFloat","_local_4","_local_5","getValues","_local_6","render","canvas","width","height","scale","normal","useTexture","offsetX","offsetY","maxX","maxY","timeSinceStartMs","getPlane","DEFAULT","clear","graphic","clone","planeBitmapData","isStatic","UPDATE_INTERVAL","round","getTextureIdentifier"],"mappings":"AAEA,SAASA,KAAT,QAAsB,yBAAtB;AACA,SAASC,eAAT,QAAgC,6BAAhC;AACA,SAASC,UAAT,QAA2B,wBAA3B;AAEA,SAASC,eAAT,QAAgC,0BAAhC;AACA,SAASC,uBAAT,QAAwC,kCAAxC;AACA,SAASC,cAAT,QAA+B,kBAA/B;AAEA,OAAO,MAAMC,mBAAN,SAAkCH,eAAlC,CACP;AAAA;AAAA;AAAA,SAGYI,eAHZ,GAGsC,CAHtC;AAAA,SAIYC,gBAJZ,GAIuC,CAJvC;AAAA;;AAMWC,EAAAA,oBAAoB,CAACC,CAAD,EAAYC,MAAZ,EAC3B;AACI,QAAGD,CAAC,GAAG,CAAP,EAAUA,CAAC,GAAG,CAAJ;AAEV,QAAGC,MAAM,GAAG,CAAZ,EAAeA,MAAM,GAAG,CAAT;AAEf,SAAKJ,eAAL,GAAuBG,CAAvB;AACA,SAAKF,gBAAL,GAAwBG,MAAxB;AAEA,WAAO,IAAP;AACH;;AAESC,EAAAA,gBAAgB,GAC1B;AACI,QAAG,CAAC,KAAKC,IAAT,EAAe;AAEf,UAAMC,UAAU,GAAG,KAAKD,IAAL,CAAUC,UAA7B;AAEA,QAAGA,UAAU,IAAIA,UAAU,CAACC,MAA5B,EAAoC,KAAKC,eAAL,CAAqBF,UAArB;AACvC;;AAEOE,EAAAA,eAAe,CAACN,CAAD,EACvB;AACI,QAAG,CAACA,CAAJ,EAAO;AAEP,UAAMO,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAYD,IAAI,CAACE,MAAL,KAAgB,MAA5B,CAArB;;AAEA,SAAI,MAAMC,cAAV,IAA4BX,CAA5B,EACA;AACI,YAAMY,SAAS,GAAGZ,CAAC,CAACW,cAAD,CAAnB;AAEA,UAAG,CAACC,SAAJ,EAAe;AAEf,YAAMC,EAAE,GAAGD,SAAS,CAACC,EAArB;AACA,YAAMC,cAAc,GAAGF,SAAS,CAACG,sBAAjC;AAEA,YAAMC,KAAK,GAAG,IAAIrB,cAAJ,EAAd;;AAEA,WAAI,MAAMsB,aAAV,IAA2BH,cAA3B,EACA;AACI,YAAG,CAACG,aAAJ,EAAmB;AAEnB,cAAMC,IAAI,GAAGD,aAAa,CAACC,IAA3B;AAEA,YAAIC,eAAe,GAAGxB,cAAc,CAACyB,wBAArC;AACA,YAAIC,aAAa,GAAG1B,cAAc,CAAC2B,sBAAnC;AAEA,YAAGL,aAAa,CAACE,eAAjB,EAAkCA,eAAe,GAAGF,aAAa,CAACE,eAAhC;AAClC,YAAGF,aAAa,CAACI,aAAjB,EAAgCA,aAAa,GAAGJ,aAAa,CAACI,aAA9B;AAEhC,cAAME,WAAW,GAAGN,aAAa,CAACO,MAAlC;AACA,cAAMC,cAAc,GAAGR,aAAa,CAACS,eAArC;AACA,cAAMC,gBAAgB,GAAKJ,WAAW,IAAIA,WAAW,CAAClB,MAA5B,IAAuC,CAAjE;AACA,cAAMuB,mBAAmB,GAAKH,cAAc,IAAIA,cAAc,CAACpB,MAAlC,IAA6C,CAA1E;AACA,cAAMwB,WAAW,GAAIF,gBAAgB,GAAGC,mBAAxC;AAEA,cAAME,kBAAkB,GAAGd,KAAK,CAACe,wBAAN,CAA+Bb,IAA/B,EAAsCW,WAAW,IAAI,CAArD,EAAyD,KAAKG,WAAL,CAAiBd,IAAjB,EAAuBC,eAAvB,EAAwCE,aAAxC,CAAzD,CAA3B;;AAEA,YAAGS,kBAAH,EACA;AACItC,UAAAA,UAAU,CAACyC,OAAX,CAAmB1B,YAAnB;AAEA,cAAI2B,OAAO,GAAG,CAAd;;AAEA,cAAGP,gBAAH,EACA;AACI,mBAAMO,OAAO,GAAGX,WAAW,CAAClB,MAA5B,EACA;AACI,oBAAM8B,KAAK,GAAGZ,WAAW,CAACW,OAAD,CAAzB;;AAEA,kBAAGC,KAAH,EACA;AACI,oBAAIC,QAAuB,GAAG,IAA9B;AACA,oBAAIC,KAAa,GAAG3C,uBAAuB,CAAC4C,aAA5C;AACA,oBAAIC,KAAa,GAAG5C,cAAc,CAAC6C,aAAnC;AACA,oBAAIC,MAAc,GAAG/C,uBAAuB,CAACgD,cAA7C;AAEA,oBAAGP,KAAK,CAACQ,UAAT,EAAqBP,QAAQ,GAAG,KAAKQ,WAAL,CAAiBT,KAAK,CAACQ,UAAvB,CAAX;AAErB,oBAAGR,KAAK,CAACI,KAAT,EAAgBA,KAAK,GAAGJ,KAAK,CAACI,KAAd;AAEhB,oBAAGJ,KAAK,CAACM,MAAT,EAAiBA,MAAM,GAAGN,KAAK,CAACM,MAAf;;AAEjB,oBAAGN,KAAK,CAACE,KAAT,EACA;AACI,sBAAGF,KAAK,CAACE,KAAN,KAAgB,QAAnB,EACA;AACIA,oBAAAA,KAAK,GAAG3C,uBAAuB,CAACmD,YAAhC;AACH,mBAHD,MAKK,IAAGV,KAAK,CAACE,KAAN,KAAgB,KAAnB,EAA0BA,KAAK,GAAG3C,uBAAuB,CAACoD,SAAhC;AAClC;;AAEDhB,gBAAAA,kBAAkB,CAACiB,QAAnB,CAA4Bb,OAA5B,EAAqCE,QAArC,EAA+CG,KAA/C,EAAsDF,KAAtD,EAA6DI,MAA7D;AACH;;AAEDP,cAAAA,OAAO;AACV;AACJ;;AAEDA,UAAAA,OAAO,GAAG,CAAV;;AAEA,cAAGN,mBAAH,EACA;AACI,kBAAMoB,cAAoB,GAAG,EAA7B;;AAEA,mBAAMd,OAAO,GAAGT,cAAc,CAACpB,MAA/B,EACA;AACI,oBAAM8B,KAAK,GAAGV,cAAc,CAACS,OAAD,CAA5B;;AAEA,kBAAGC,KAAH,EACA;AACI,sBAAMc,KAAK,GAAGd,KAAK,CAACa,cAApB;;AAEA,oBAAGC,KAAK,IAAIA,KAAK,CAAC5C,MAAlB,EACA;AACI,uBAAI,MAAM6C,IAAV,IAAkBD,KAAlB,EACA;AACI,wBAAGC,IAAH,EACA;AACI,4BAAMrC,EAAE,GAAGqC,IAAI,CAACrC,EAAhB;AACA,4BAAMsC,OAAO,GAAGD,IAAI,CAACC,OAArB;AACA,4BAAMC,CAAC,GAAG,KAAKC,kBAAL,CAAwBH,IAAI,CAACE,CAAL,IAAU,EAAlC,EAAsCF,IAAI,CAACI,OAAL,IAAgB,EAAtD,CAAV;AACA,4BAAMC,CAAC,GAAG,KAAKF,kBAAL,CAAwBH,IAAI,CAACK,CAAL,IAAU,EAAlC,EAAsCL,IAAI,CAACM,OAAL,IAAgB,EAAtD,CAAV;AACA,4BAAMC,MAAM,GAAGP,IAAI,CAACO,MAAL,GAAcP,IAAI,CAACO,MAAL,GAAcnE,KAAK,CAACoE,QAAN,CAAeC,gBAAf,CAAwC,sBAAxC,CAA5B,GAA8F,CAA7G;AACA,4BAAMC,MAAM,GAAGV,IAAI,CAACU,MAAL,GAAcV,IAAI,CAACU,MAAL,GAActE,KAAK,CAACoE,QAAN,CAAeC,gBAAf,CAAwC,sBAAxC,CAA5B,GAA8F,CAA7G;AAEAX,sBAAAA,cAAc,CAACa,IAAf,CAAoB;AAChBC,wBAAAA,KAAK,EAAEX,OADS;AAEhBC,wBAAAA,CAFgB;AAGhBG,wBAAAA,CAHgB;AAIhBE,wBAAAA,MAJgB;AAKhBG,wBAAAA;AALgB,uBAApB;AAOH;AACJ;AACJ;AACJ;;AAED1B,cAAAA,OAAO;AACV;;AAEDJ,YAAAA,kBAAkB,CAACiC,iBAAnB,CAAqC7B,OAArC,EAA8Cc,cAA9C,EAA8D,KAAKgB,eAAnE;AACH;AACJ;AACJ;;AAED,UAAG,CAAC,KAAKC,QAAL,CAAcpD,EAAd,EAAkBG,KAAlB,CAAJ,EAA8BA,KAAK,CAACkD,OAAN;AACjC;AACJ;;AAEOb,EAAAA,kBAAkB,CAACrD,CAAD,EAAYC,MAAZ,EAC1B;AACI,QAAIkE,QAAQ,GAAG,CAAf;;AAEA,QAAInE,CAAC,CAACK,MAAF,GAAW,CAAf,EACA;AACI,UAAGL,CAAC,CAACoE,MAAF,CAAUpE,CAAC,CAACK,MAAF,GAAW,CAArB,MAA6B,GAAhC,EACA;AACIL,QAAAA,CAAC,GAAGA,CAAC,CAACqE,MAAF,CAAS,CAAT,EAAarE,CAAC,CAACK,MAAF,GAAW,CAAxB,CAAJ;AAEA8D,QAAAA,QAAQ,GAAIG,UAAU,CAACtE,CAAD,CAAV,GAAgB,GAA5B;AACH;AACJ;;AAED,QAAIC,MAAM,CAACI,MAAP,GAAgB,CAApB,EACA;AACI,YAAMkE,QAAQ,GAAG,KAAjB;;AACA,YAAMC,QAAQ,GAAGhF,UAAU,CAACiF,SAAX,CAAqB,CAArB,EAAwB,CAAxB,EAA2BF,QAA3B,CAAjB;;AACA,YAAMG,QAAQ,GAAIF,QAAQ,CAAC,CAAD,CAAR,GAAcD,QAAhC;;AAEA,UAAGtE,MAAM,CAACmE,MAAP,CAAenE,MAAM,CAACI,MAAP,GAAgB,CAA/B,MAAuC,GAA1C,EACA;AACIJ,QAAAA,MAAM,GAAGA,MAAM,CAACoE,MAAP,CAAc,CAAd,EAAkBpE,MAAM,CAACI,MAAP,GAAgB,CAAlC,CAAT;AAEA8D,QAAAA,QAAQ,GAAIA,QAAQ,GAAKO,QAAQ,GAAGJ,UAAU,CAACrE,MAAD,CAAtB,GAAkC,GAA1D;AACH;AACJ;;AAED,WAAOkE,QAAP;AACH;;AAEMQ,EAAAA,MAAM,CAACC,MAAD,EAAmB/D,EAAnB,EAA+BgE,KAA/B,EAA8CC,MAA9C,EAA8DC,KAA9D,EAA6EC,MAA7E,EAAgGC,UAAhG,EACb;AAAA,QADkIC,OAClI,uEADoJ,CACpJ;AAAA,QADuJC,OACvJ,uEADyK,CACzK;AAAA,QAD4KC,IAC5K,uEAD2L,CAC3L;AAAA,QAD8LC,IAC9L,0EAD6M,CAC7M;AAAA,QADgNC,gBAChN,0EAD2O,CAC3O;AACI,QAAItE,KAAK,GAAG,KAAKuE,QAAL,CAAc1E,EAAd,CAAZ;AAEA,QAAG,CAACG,KAAJ,EAAWA,KAAK,GAAG,KAAKuE,QAAL,CAAc3F,mBAAmB,CAAC4F,OAAlC,CAAR;AAEX,QAAG,CAACxE,KAAJ,EAAW,OAAO,IAAP;;AAEX,QAAG4D,MAAH,EACA;AACIA,MAAAA,MAAM,CAACa,KAAP;AACH;;AAED,QAAIC,OAAO,GAAG1E,KAAK,CAAC2D,MAAN,CAAaC,MAAb,EAAqBC,KAArB,EAA4BC,MAA5B,EAAoCC,KAApC,EAA2CC,MAA3C,EAAmDC,UAAnD,EAA+DC,OAA/D,EAAwEC,OAAxE,EAAiFC,IAAjF,EAAuFC,IAAvF,EAA6FC,gBAA7F,CAAd;;AAEA,QAAGI,OAAO,IAAKA,OAAO,KAAKd,MAA3B,EACA;AACIc,MAAAA,OAAO,GAAGA,OAAO,CAACC,KAAR,EAAV;AAEA,UAAG,CAACD,OAAJ,EAAa,OAAO,IAAP;AAChB;;AAED,QAAIE,eAAgC,GAAG,IAAvC;;AAEA,QAAG,CAAC5E,KAAK,CAAC6E,QAAN,CAAed,KAAf,CAAD,IAA2BnF,mBAAmB,CAACkG,eAApB,GAAsC,CAApE,EACA;AACIF,MAAAA,eAAe,GAAG,IAAIrG,eAAJ,CAAoBmG,OAApB,EAA+BlF,IAAI,CAACuF,KAAL,CAAYT,gBAAgB,GAAG1F,mBAAmB,CAACkG,eAAnD,IAAuElG,mBAAmB,CAACkG,eAA5F,GAA+GlG,mBAAmB,CAACkG,eAAjK,CAAlB;AACH,KAHD,MAKA;AACIF,MAAAA,eAAe,GAAG,IAAIrG,eAAJ,CAAoBmG,OAApB,EAA6B,CAAC,CAA9B,CAAlB;AACH;;AAED,WAAOE,eAAP;AACH;;AAEMI,EAAAA,oBAAoB,CAAChG,CAAD,EAAYC,MAAZ,EAC3B;AACI,QAAGA,MAAH,EACA;AACI,UAAGA,MAAM,CAACmD,CAAP,GAAW,CAAd,EAAiB,OAAQpD,CAAC,GAAG,IAAZ;AAEjB,aAAQA,CAAC,GAAG,IAAZ;AACH;;AAED,WAAO,MAAMgG,oBAAN,CAA2BhG,CAA3B,EAA8BC,MAA9B,CAAP;AACH;;AA1OL;AADaL,mB,CAEMkG,e,GAA0B,G","sourcesContent":["import { Graphics } from '@pixi/graphics';\r\nimport { IVector3D } from '../../../../../../../room/utils/IVector3D';\r\nimport { Nitro } from '../../../../../../Nitro';\r\nimport { PlaneBitmapData } from '../../utils/PlaneBitmapData';\r\nimport { Randomizer } from '../../utils/Randomizer';\r\nimport { PlaneMaterial } from '../basic/PlaneMaterial';\r\nimport { PlaneRasterizer } from '../basic/PlaneRasterizer';\r\nimport { PlaneVisualizationLayer } from '../basic/PlaneVisualizationLayer';\r\nimport { LandscapePlane } from './LandscapePlane';\r\n\r\nexport class LandscapeRasterizer extends PlaneRasterizer\r\n{\r\n    private static UPDATE_INTERVAL: number = 500;\r\n\r\n    private _landscapeWidth: number = 0;\r\n    private _landscapeHeight: number = 0;\r\n\r\n    public initializeDimensions(k: number, _arg_2: number): boolean\r\n    {\r\n        if(k < 0) k = 0;\r\n\r\n        if(_arg_2 < 0) _arg_2 = 0;\r\n\r\n        this._landscapeWidth = k;\r\n        this._landscapeHeight = _arg_2;\r\n\r\n        return true;\r\n    }\r\n\r\n    protected initializePlanes(): void\r\n    {\r\n        if(!this.data) return;\r\n\r\n        const landscapes = this.data.landscapes;\r\n\r\n        if(landscapes && landscapes.length) this.parseLandscapes(landscapes);\r\n    }\r\n\r\n    private parseLandscapes(k: any): void\r\n    {\r\n        if(!k) return;\r\n\r\n        const randomNumber = Math.trunc((Math.random() * 654321));\r\n\r\n        for(const landscapeIndex in k)\r\n        {\r\n            const landscape = k[landscapeIndex];\r\n\r\n            if(!landscape) continue;\r\n\r\n            const id = landscape.id;\r\n            const visualizations = landscape.animatedVisualizations;\r\n\r\n            const plane = new LandscapePlane();\r\n\r\n            for(const visualization of visualizations)\r\n            {\r\n                if(!visualization) continue;\r\n\r\n                const size = visualization.size;\r\n\r\n                let horizontalAngle = LandscapePlane.HORIZONTAL_ANGLE_DEFAULT;\r\n                let verticalAngle = LandscapePlane.VERTICAL_ANGLE_DEFAULT;\r\n\r\n                if(visualization.horizontalAngle) horizontalAngle = visualization.horizontalAngle;\r\n                if(visualization.verticalAngle) verticalAngle = visualization.verticalAngle;\r\n\r\n                const basicLayers = visualization.layers;\r\n                const animatedLayers = visualization.animationLayers;\r\n                const totalBasicLayers = ((basicLayers && basicLayers.length) || 0);\r\n                const totalAnimatedLayers = ((animatedLayers && animatedLayers.length) || 0);\r\n                const totalLayers = (totalBasicLayers + totalAnimatedLayers);\r\n\r\n                const planeVisualization = plane.createPlaneVisualization(size, (totalLayers || 0), this.getGeometry(size, horizontalAngle, verticalAngle));\r\n\r\n                if(planeVisualization)\r\n                {\r\n                    Randomizer.setSeed(randomNumber);\r\n\r\n                    let layerId = 0;\r\n\r\n                    if(totalBasicLayers)\r\n                    {\r\n                        while(layerId < basicLayers.length)\r\n                        {\r\n                            const layer = basicLayers[layerId];\r\n\r\n                            if(layer)\r\n                            {\r\n                                let material: PlaneMaterial = null;\r\n                                let align: number = PlaneVisualizationLayer.ALIGN_DEFAULT;\r\n                                let color: number = LandscapePlane.DEFAULT_COLOR;\r\n                                let offset: number = PlaneVisualizationLayer.DEFAULT_OFFSET;\r\n\r\n                                if(layer.materialId) material = this.getMaterial(layer.materialId);\r\n\r\n                                if(layer.color) color = layer.color;\r\n\r\n                                if(layer.offset) offset = layer.offset;\r\n\r\n                                if(layer.align)\r\n                                {\r\n                                    if(layer.align === 'bottom')\r\n                                    {\r\n                                        align = PlaneVisualizationLayer.ALIGN_BOTTOM;\r\n                                    }\r\n\r\n                                    else if(layer.align === 'top') align = PlaneVisualizationLayer.ALIGN_TOP;\r\n                                }\r\n\r\n                                planeVisualization.setLayer(layerId, material, color, align, offset);\r\n                            }\r\n\r\n                            layerId++;\r\n                        }\r\n                    }\r\n\r\n                    layerId = 0;\r\n\r\n                    if(totalAnimatedLayers)\r\n                    {\r\n                        const animationItems: {}[] = [];\r\n\r\n                        while(layerId < animatedLayers.length)\r\n                        {\r\n                            const layer = animatedLayers[layerId];\r\n\r\n                            if(layer)\r\n                            {\r\n                                const items = layer.animationItems;\r\n\r\n                                if(items && items.length)\r\n                                {\r\n                                    for(const item of items)\r\n                                    {\r\n                                        if(item)\r\n                                        {\r\n                                            const id = item.id;\r\n                                            const assetId = item.assetId;\r\n                                            const x = this.getCoordinateValue(item.x || '', item.randomX || '');\r\n                                            const y = this.getCoordinateValue(item.y || '', item.randomY || '');\r\n                                            const speedX = item.speedX ? item.speedX / Nitro.instance.getConfiguration<number>('system.animation.fps') : 0;\r\n                                            const speedY = item.speedY ? item.speedY / Nitro.instance.getConfiguration<number>('system.animation.fps') : 0;\r\n\r\n                                            animationItems.push({\r\n                                                asset: assetId,\r\n                                                x,\r\n                                                y,\r\n                                                speedX,\r\n                                                speedY\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            layerId++;\r\n                        }\r\n\r\n                        planeVisualization.setAnimationLayer(layerId, animationItems, this.assetCollection);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(!this.addPlane(id, plane)) plane.dispose();\r\n        }\r\n    }\r\n\r\n    private getCoordinateValue(k: string, _arg_2: string): number\r\n    {\r\n        let _local_3 = 0;\r\n\r\n        if((k.length > 0))\r\n        {\r\n            if(k.charAt((k.length - 1)) === '%')\r\n            {\r\n                k = k.substr(0, (k.length - 1));\r\n\r\n                _local_3 = (parseFloat(k) / 100);\r\n            }\r\n        }\r\n\r\n        if((_arg_2.length > 0))\r\n        {\r\n            const _local_4 = 10000;\r\n            const _local_5 = Randomizer.getValues(1, 0, _local_4);\r\n            const _local_6 = (_local_5[0] / _local_4);\r\n\r\n            if(_arg_2.charAt((_arg_2.length - 1)) === '%')\r\n            {\r\n                _arg_2 = _arg_2.substr(0, (_arg_2.length - 1));\r\n\r\n                _local_3 = (_local_3 + ((_local_6 * parseFloat(_arg_2)) / 100));\r\n            }\r\n        }\r\n\r\n        return _local_3;\r\n    }\r\n\r\n    public render(canvas: Graphics, id: string, width: number, height: number, scale: number, normal: IVector3D, useTexture: boolean, offsetX: number = 0, offsetY: number = 0, maxX: number = 0, maxY: number = 0, timeSinceStartMs: number = 0): PlaneBitmapData\r\n    {\r\n        let plane = this.getPlane(id) as LandscapePlane;\r\n\r\n        if(!plane) plane = this.getPlane(LandscapeRasterizer.DEFAULT) as LandscapePlane;\r\n\r\n        if(!plane) return null;\r\n\r\n        if(canvas)\r\n        {\r\n            canvas.clear();\r\n        }\r\n\r\n        let graphic = plane.render(canvas, width, height, scale, normal, useTexture, offsetX, offsetY, maxX, maxY, timeSinceStartMs);\r\n\r\n        if(graphic && (graphic !== canvas))\r\n        {\r\n            graphic = graphic.clone();\r\n\r\n            if(!graphic) return null;\r\n        }\r\n\r\n        let planeBitmapData: PlaneBitmapData = null;\r\n\r\n        if(!plane.isStatic(scale) && (LandscapeRasterizer.UPDATE_INTERVAL > 0))\r\n        {\r\n            planeBitmapData = new PlaneBitmapData(graphic, ((Math.round((timeSinceStartMs / LandscapeRasterizer.UPDATE_INTERVAL)) * LandscapeRasterizer.UPDATE_INTERVAL) + LandscapeRasterizer.UPDATE_INTERVAL));\r\n        }\r\n        else\r\n        {\r\n            planeBitmapData = new PlaneBitmapData(graphic, -1);\r\n        }\r\n\r\n        return planeBitmapData;\r\n    }\r\n\r\n    public getTextureIdentifier(k: number, _arg_2: IVector3D): string\r\n    {\r\n        if(_arg_2)\r\n        {\r\n            if(_arg_2.x < 0) return (k + '_0');\r\n\r\n            return (k + '_1');\r\n        }\r\n\r\n        return super.getTextureIdentifier(k, _arg_2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}