{"ast":null,"code":"import { Nitro } from '../../../../Nitro';\nimport { RoomObjectVariable } from '../../RoomObjectVariable';\nimport { RoomObjectVisualizationType } from '../../RoomObjectVisualizationType';\nimport { AnimationData } from '../data/AnimationData';\nimport { AnimationStateData } from '../data/AnimationStateData';\nimport { DirectionData } from '../data/DirectionData';\nimport { LayerData } from '../data/LayerData';\nimport { FurnitureAnimatedVisualization } from '../furniture/FurnitureAnimatedVisualization';\nimport { FurnitureVisualizationData } from '../furniture/FurnitureVisualizationData';\nimport { ExperienceData } from './ExperienceData';\nimport { PetVisualizationData } from './PetVisualizationData';\nexport class PetVisualization extends FurnitureAnimatedVisualization {\n  constructor() {\n    super();\n    this._data = void 0;\n    this._posture = void 0;\n    this._gesture = void 0;\n    this._isSleeping = void 0;\n    this._headDirection = void 0;\n    this._headOnly = void 0;\n    this._nonHeadSprites = void 0;\n    this._headSprites = void 0;\n    this._saddleSprites = void 0;\n    this._animationOver = void 0;\n    this._paletteIndex = void 0;\n    this._paletteName = void 0;\n    this._customLayerIds = void 0;\n    this._customPartIds = void 0;\n    this._customPaletteIds = void 0;\n    this._isRiding = void 0;\n    this._color = void 0;\n    this._experience = void 0;\n    this._experienceTimestamp = void 0;\n    this._experienceData = void 0;\n    this._previousAnimationDirection = void 0;\n    this._animationStates = void 0;\n    this._data = null;\n    this._posture = '';\n    this._gesture = '';\n    this._isSleeping = false;\n    this._headDirection = -1;\n    this._headOnly = false;\n    this._nonHeadSprites = [];\n    this._headSprites = [];\n    this._saddleSprites = [];\n    this._animationOver = false;\n    this._paletteIndex = -1;\n    this._paletteName = '';\n    this._customLayerIds = [];\n    this._customPartIds = [];\n    this._customPaletteIds = [];\n    this._isRiding = false;\n    this._color = 0xFFFFFF;\n    this._experience = 0;\n    this._experienceTimestamp = 0;\n    this._experienceData = null;\n    this._previousAnimationDirection = -1;\n    this._animationStates = [];\n\n    while (this._animationStates.length < PetVisualization.ANIMATION_INDEX_COUNT) this._animationStates.push(new AnimationStateData());\n  }\n\n  initialize(data) {\n    if (!(data instanceof PetVisualizationData)) return false;\n    const texture = this.getPetAdditionAsset(PetVisualization.PET_EXPERIENCE_BUBBLE);\n\n    if (texture) {\n      this._experienceData = new ExperienceData(texture);\n    }\n\n    return super.initialize(data);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._animationStates) {\n      while (this._animationStates.length) {\n        const animationState = this._animationStates[0];\n        if (animationState) animationState.dispose();\n\n        this._animationStates.pop();\n      }\n\n      this._animationStates = null;\n    }\n  }\n\n  getAnimationId(animationData) {\n    return animationData.animationId;\n  }\n\n  update(geometry, time, update, skipUpdate) {\n    super.update(geometry, time, update, skipUpdate);\n    this.updateExperienceBubble(time);\n  }\n\n  updateExperienceBubble(time) {\n    if (!this._experienceData) return;\n    this._experienceData.alpha = 0;\n\n    if (this._experienceTimestamp) {\n      const difference = time - this._experienceTimestamp;\n\n      if (difference < PetVisualization.EXPERIENCE_BUBBLE_VISIBLE_IN_MS) {\n        this._experienceData.alpha = Math.sin(difference / PetVisualization.EXPERIENCE_BUBBLE_VISIBLE_IN_MS * Math.PI) * 0xFF;\n      } else {\n        this._experienceTimestamp = 0;\n      }\n\n      const sprite = this.getSprite(this.totalSprites - 1);\n\n      if (sprite) {\n        if (this._experienceData.alpha > 0) {\n          const texture = this._experienceData.renderBubble(this._experience);\n\n          if (texture) {\n            sprite.texture = texture;\n            sprite.offsetX = -20;\n            sprite.offsetY = -80;\n            sprite.alpha = this._experienceData.alpha;\n            sprite.visible = true;\n            sprite.relativeDepth = -0.2;\n            return;\n          }\n        }\n\n        sprite.texture = null;\n        sprite.visible = false;\n      }\n    }\n  }\n\n  updateModel(scale) {\n    const model = this.object && this.object.model;\n    if (!model) return false;\n    if (this.updateModelCounter === model.updateCounter) return false;\n    const posture = model.getValue(RoomObjectVariable.FIGURE_POSTURE);\n    const gesture = model.getValue(RoomObjectVariable.FIGURE_GESTURE);\n    this.setPostureAndGesture(posture, gesture);\n    let alphaMultiplier = model.getValue(RoomObjectVariable.FURNITURE_ALPHA_MULTIPLIER) || null;\n    if (alphaMultiplier === null || isNaN(alphaMultiplier)) alphaMultiplier = 1;\n\n    if (this._alphaMultiplier !== alphaMultiplier) {\n      this._alphaMultiplier = alphaMultiplier;\n      this._alphaChanged = true;\n    }\n\n    this._isSleeping = model.getValue(RoomObjectVariable.FIGURE_SLEEP) > 0;\n    const headDirection = model.getValue(RoomObjectVariable.HEAD_DIRECTION);\n\n    if (!isNaN(headDirection) && this._data.isAllowedToTurnHead) {\n      this._headDirection = headDirection;\n    } else {\n      this._headDirection = this.object.getDirection().x;\n    }\n\n    this._experience = model.getValue(RoomObjectVariable.FIGURE_GAINED_EXPERIENCE);\n    this._experienceTimestamp = model.getValue(RoomObjectVariable.FIGURE_EXPERIENCE_TIMESTAMP);\n    const customPaletteIndex = model.getValue(RoomObjectVariable.PET_PALETTE_INDEX);\n    const customLayerIds = model.getValue(RoomObjectVariable.PET_CUSTOM_LAYER_IDS);\n    const customPartIds = model.getValue(RoomObjectVariable.PET_CUSTOM_PARTS_IDS);\n    const customPaletteIds = model.getValue(RoomObjectVariable.PET_CUSTOM_PALETTE_IDS);\n    const isRiding = model.getValue(RoomObjectVariable.PET_IS_RIDING);\n    const headOnly = model.getValue(RoomObjectVariable.PET_HEAD_ONLY);\n    const color = model.getValue(RoomObjectVariable.PET_COLOR);\n\n    if (customPaletteIndex !== this._paletteIndex) {\n      this._paletteIndex = customPaletteIndex;\n      this._paletteName = this._paletteIndex.toString();\n    }\n\n    this._customLayerIds = customLayerIds ? customLayerIds : [];\n    this._customPartIds = customPartIds ? customPartIds : [];\n    this._customPaletteIds = customPaletteIds ? customPaletteIds : [];\n    this._isRiding = !isNaN(isRiding) && isRiding > 0;\n    this._headOnly = !isNaN(headOnly) && headOnly > 0;\n    if (!isNaN(color) && this._color !== color) this._color = color;\n    this.updateModelCounter = model.updateCounter;\n    return true;\n  }\n\n  updateAnimation(scale) {\n    if (this.object) {\n      const direction = this.object.getDirection().x;\n\n      if (direction !== this._previousAnimationDirection) {\n        this._previousAnimationDirection = direction;\n        this.resetAllAnimationFrames();\n      }\n    }\n\n    return super.updateAnimation(scale);\n  }\n\n  setPostureAndGesture(posture, gesture) {\n    if (posture !== this._posture) {\n      this._posture = posture;\n      this.setAnimationForIndex(PetVisualization.POSTURE_ANIMATION_INDEX, this._data.postureToAnimation(this._scale, posture));\n    }\n\n    if (this._data.getGestureDisabled(this._scale, posture)) gesture = null;\n\n    if (gesture !== this._gesture) {\n      this._gesture = gesture;\n      this.setAnimationForIndex(PetVisualization.GESTURE_ANIMATION_INDEX, this._data.gestureToAnimation(this._scale, gesture));\n    }\n  }\n\n  getAnimationStateData(k) {\n    if (k >= 0 && k < this._animationStates.length) return this._animationStates[k];\n    return null;\n  }\n\n  setAnimationForIndex(k, _arg_2) {\n    const animationStateData = this.getAnimationStateData(k);\n\n    if (animationStateData) {\n      if (this.setSubAnimation(animationStateData, _arg_2)) this._animationOver = false;\n    }\n  }\n\n  resetAllAnimationFrames() {\n    this._animationOver = false;\n    let index = this._animationStates.length - 1;\n\n    while (index >= 0) {\n      const stateData = this._animationStates[index];\n      if (stateData) stateData.setLayerCount(this.animatedLayerCount);\n      index--;\n    }\n  }\n\n  updateAnimations(scale) {\n    if (this._animationOver) return 0;\n    let animationOver = true;\n    let _local_3 = 0;\n    let index = 0;\n\n    while (index < this._animationStates.length) {\n      const stateData = this._animationStates[index];\n\n      if (stateData) {\n        if (!stateData.animationOver) {\n          const _local_6 = this.updateFramesForAnimation(stateData, scale);\n\n          _local_3 = _local_3 | _local_6;\n\n          if (!stateData.animationOver) {\n            animationOver = false;\n          } else {\n            if (AnimationData.isTransitionFromAnimation(stateData.animationId) || AnimationData.isTransitionToAnimation(stateData.animationId)) {\n              this.setAnimationForIndex(index, stateData.animationAfterTransitionId);\n              animationOver = false;\n            }\n          }\n        }\n      }\n\n      index++;\n    }\n\n    this._animationOver = animationOver;\n    return _local_3;\n  }\n\n  getSpriteAssetName(scale, layerId) {\n    if (this._headOnly && this.isNonHeadSprite(layerId)) return null;\n    if (this._isRiding && this._parser3(layerId)) return null;\n    const totalSprites = this.totalSprites;\n\n    if (layerId < totalSprites - PetVisualization.ADDITIONAL_SPRITE_COUNT) {\n      const validScale = this.getValidSize(scale);\n\n      if (layerId < totalSprites - (1 + PetVisualization.ADDITIONAL_SPRITE_COUNT)) {\n        if (layerId >= FurnitureVisualizationData.LAYER_LETTERS.length) return null;\n        const layerLetter = FurnitureVisualizationData.LAYER_LETTERS[layerId];\n        if (validScale === 1) return this._type + '_icon_' + layerLetter;\n        return this._type + '_' + validScale + '_' + layerLetter + '_' + this.getDirection(scale, layerId) + '_' + this.getFrameNumber(validScale, layerId);\n      }\n\n      return this._type + '_' + validScale + '_sd_' + this.getDirection(scale, layerId) + '_0';\n    }\n\n    return null;\n  }\n\n  getLayerColor(scale, layerId, colorId) {\n    if (layerId < this.totalSprites - PetVisualization.ADDITIONAL_SPRITE_COUNT) return this._color;\n    return 0xFFFFFF;\n  }\n\n  getLayerXOffset(scale, direction, layerId) {\n    let offset = super.getLayerXOffset(scale, direction, layerId);\n    let index = this._animationStates.length - 1;\n\n    while (index >= 0) {\n      const stateData = this._animationStates[index];\n\n      if (stateData) {\n        const frame = stateData.getFrame(layerId);\n        if (frame) offset += frame.x;\n      }\n\n      index--;\n    }\n\n    return offset;\n  }\n\n  getLayerYOffset(scale, direction, layerId) {\n    let offset = super.getLayerYOffset(scale, direction, layerId);\n    let index = this._animationStates.length - 1;\n\n    while (index >= 0) {\n      const stateData = this._animationStates[index];\n\n      if (stateData) {\n        const frame = stateData.getFrame(layerId);\n        if (frame) offset += frame.y;\n      }\n\n      index--;\n    }\n\n    return offset;\n  }\n\n  getLayerZOffset(scale, direction, layerId) {\n    if (!this._data) return LayerData.DEFAULT_ZOFFSET;\n    return this._data.getLayerZOffset(scale, this.getDirection(scale, layerId), layerId);\n  }\n\n  getDirection(scale, layerId) {\n    if (!this.isHeadSprite(layerId)) return this._direction;\n    return this._data.getValidDirection(scale, this._headDirection);\n  }\n\n  getFrameNumber(scale, layerId) {\n    let index = this._animationStates.length - 1;\n\n    while (index >= 0) {\n      const stateData = this._animationStates[index];\n\n      if (stateData) {\n        const frame = stateData.getFrame(layerId);\n        if (frame) return frame.id;\n      }\n\n      index--;\n    }\n\n    return super.getFrameNumber(scale, layerId);\n  }\n\n  isHeadSprite(layerId) {\n    if (this._headSprites[layerId] === undefined) {\n      const isHead = this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.HEAD;\n      const isHair = this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.HAIR;\n      if (isHead || isHair) this._headSprites[layerId] = true;else this._headSprites[layerId] = false;\n    }\n\n    return this._headSprites[layerId];\n  }\n\n  isNonHeadSprite(layerId) {\n    if (this._nonHeadSprites[layerId] === undefined) {\n      if (layerId < this.totalSprites - (1 + PetVisualization.ADDITIONAL_SPRITE_COUNT)) {\n        const tag = this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId);\n\n        if (tag && tag.length > 0 && tag !== PetVisualization.HEAD && tag !== PetVisualization.HAIR) {\n          this._nonHeadSprites[layerId] = true;\n        } else {\n          this._nonHeadSprites[layerId] = false;\n        }\n      } else {\n        this._nonHeadSprites[layerId] = true;\n      }\n    }\n\n    return this._nonHeadSprites[layerId];\n  }\n\n  _parser3(layerId) {\n    if (this._saddleSprites[layerId] === undefined) {\n      if (this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.SADDLE) {\n        this._saddleSprites[layerId] = true;\n      } else {\n        this._saddleSprites[layerId] = false;\n      }\n    }\n\n    return this._saddleSprites[layerId];\n  }\n\n  getAsset(name) {\n    let layerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    if (!this.asset) return null;\n\n    const layerIndex = this._customLayerIds.indexOf(layerId);\n\n    let paletteName = this._paletteName;\n    let partId = -1;\n    let paletteId = -1;\n\n    if (layerIndex > -1) {\n      partId = this._customPartIds[layerIndex];\n      paletteId = this._customPaletteIds[layerIndex];\n      paletteName = paletteId > -1 ? paletteId.toString() : this._paletteName;\n    }\n\n    if (!isNaN(partId) && partId > -1) {\n      name = name + '_' + partId;\n    }\n\n    return this.asset.getAssetWithPalette(name, paletteName);\n  }\n\n  getAdditionalLayerCount() {\n    return super.getAdditionalLayerCount() + PetVisualization.ADDITIONAL_SPRITE_COUNT;\n  }\n\n  setLayerCount(count) {\n    super.setLayerCount(count);\n    this._headSprites = [];\n  }\n\n  getPostureForAsset(scale, name) {\n    const parts = name.split('_');\n    let length = parts.length;\n    let i = 0;\n\n    while (i < parts.length) {\n      if (parts[i] === '64' || parts[i] === '32') {\n        length = i + 3;\n        break;\n      }\n\n      i++;\n    }\n\n    let posture = null;\n\n    if (length < parts.length) {\n      let part = parts[length];\n      part = part.split('@')[0];\n      posture = this._data.animationToPosture(scale, parseInt(part) / 100, false);\n      if (!posture) posture = this._data.getGestureForAnimationId(scale, parseInt(part) / 100);\n    }\n\n    return posture;\n  }\n\n  getPetAdditionAsset(name) {\n    return Nitro.instance.core.asset.getTexture(name);\n  }\n\n}\nPetVisualization.TYPE = RoomObjectVisualizationType.PET_ANIMATED;\nPetVisualization.HEAD = 'head';\nPetVisualization.SADDLE = 'saddle';\nPetVisualization.HAIR = 'hair';\nPetVisualization.ADDITIONAL_SPRITE_COUNT = 1;\nPetVisualization.EXPERIENCE_BUBBLE_VISIBLE_IN_MS = 1000;\nPetVisualization.PET_EXPERIENCE_BUBBLE = 'avatar_addition_pet_experience_bubble';\nPetVisualization.POSTURE_ANIMATION_INDEX = 0;\nPetVisualization.GESTURE_ANIMATION_INDEX = 1;\nPetVisualization.ANIMATION_INDEX_COUNT = 2;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/pet/PetVisualization.ts"],"names":["Nitro","RoomObjectVariable","RoomObjectVisualizationType","AnimationData","AnimationStateData","DirectionData","LayerData","FurnitureAnimatedVisualization","FurnitureVisualizationData","ExperienceData","PetVisualizationData","PetVisualization","constructor","_data","_posture","_gesture","_isSleeping","_headDirection","_headOnly","_nonHeadSprites","_headSprites","_saddleSprites","_animationOver","_paletteIndex","_paletteName","_customLayerIds","_customPartIds","_customPaletteIds","_isRiding","_color","_experience","_experienceTimestamp","_experienceData","_previousAnimationDirection","_animationStates","length","ANIMATION_INDEX_COUNT","push","initialize","data","texture","getPetAdditionAsset","PET_EXPERIENCE_BUBBLE","dispose","animationState","pop","getAnimationId","animationData","animationId","update","geometry","time","skipUpdate","updateExperienceBubble","alpha","difference","EXPERIENCE_BUBBLE_VISIBLE_IN_MS","Math","sin","PI","sprite","getSprite","totalSprites","renderBubble","offsetX","offsetY","visible","relativeDepth","updateModel","scale","model","object","updateModelCounter","updateCounter","posture","getValue","FIGURE_POSTURE","gesture","FIGURE_GESTURE","setPostureAndGesture","alphaMultiplier","FURNITURE_ALPHA_MULTIPLIER","isNaN","_alphaMultiplier","_alphaChanged","FIGURE_SLEEP","headDirection","HEAD_DIRECTION","isAllowedToTurnHead","getDirection","x","FIGURE_GAINED_EXPERIENCE","FIGURE_EXPERIENCE_TIMESTAMP","customPaletteIndex","PET_PALETTE_INDEX","customLayerIds","PET_CUSTOM_LAYER_IDS","customPartIds","PET_CUSTOM_PARTS_IDS","customPaletteIds","PET_CUSTOM_PALETTE_IDS","isRiding","PET_IS_RIDING","headOnly","PET_HEAD_ONLY","color","PET_COLOR","toString","updateAnimation","direction","resetAllAnimationFrames","setAnimationForIndex","POSTURE_ANIMATION_INDEX","postureToAnimation","_scale","getGestureDisabled","GESTURE_ANIMATION_INDEX","gestureToAnimation","getAnimationStateData","k","_arg_2","animationStateData","setSubAnimation","index","stateData","setLayerCount","animatedLayerCount","updateAnimations","animationOver","_local_3","_local_6","updateFramesForAnimation","isTransitionFromAnimation","isTransitionToAnimation","animationAfterTransitionId","getSpriteAssetName","layerId","isNonHeadSprite","_parser3","ADDITIONAL_SPRITE_COUNT","validScale","getValidSize","LAYER_LETTERS","layerLetter","_type","getFrameNumber","getLayerColor","colorId","getLayerXOffset","offset","frame","getFrame","getLayerYOffset","y","getLayerZOffset","DEFAULT_ZOFFSET","isHeadSprite","_direction","getValidDirection","id","undefined","isHead","getLayerTag","USE_DEFAULT_DIRECTION","HEAD","isHair","HAIR","tag","SADDLE","getAsset","name","asset","layerIndex","indexOf","paletteName","partId","paletteId","getAssetWithPalette","getAdditionalLayerCount","count","getPostureForAsset","parts","split","i","part","animationToPosture","parseInt","getGestureForAnimationId","instance","core","getTexture","TYPE","PET_ANIMATED"],"mappings":"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","sourcesContent":["import { Resource, Texture } from '@pixi/core';\r\nimport { IObjectVisualizationData } from '../../../../../room/object/visualization/IRoomObjectVisualizationData';\r\nimport { IGraphicAsset } from '../../../../../room/object/visualization/utils/IGraphicAsset';\r\nimport { IRoomGeometry } from '../../../../../room/utils/IRoomGeometry';\r\nimport { Nitro } from '../../../../Nitro';\r\nimport { RoomObjectVariable } from '../../RoomObjectVariable';\r\nimport { RoomObjectVisualizationType } from '../../RoomObjectVisualizationType';\r\nimport { AnimationData } from '../data/AnimationData';\r\nimport { AnimationStateData } from '../data/AnimationStateData';\r\nimport { DirectionData } from '../data/DirectionData';\r\nimport { LayerData } from '../data/LayerData';\r\nimport { FurnitureAnimatedVisualization } from '../furniture/FurnitureAnimatedVisualization';\r\nimport { FurnitureVisualizationData } from '../furniture/FurnitureVisualizationData';\r\nimport { ExperienceData } from './ExperienceData';\r\nimport { PetVisualizationData } from './PetVisualizationData';\r\n\r\nexport class PetVisualization extends FurnitureAnimatedVisualization\r\n{\r\n    public static TYPE: string = RoomObjectVisualizationType.PET_ANIMATED;\r\n\r\n    private static HEAD: string = 'head';\r\n    private static SADDLE: string = 'saddle';\r\n    private static HAIR: string = 'hair';\r\n    private static ADDITIONAL_SPRITE_COUNT: number = 1;\r\n    private static EXPERIENCE_BUBBLE_VISIBLE_IN_MS: number = 1000;\r\n    private static PET_EXPERIENCE_BUBBLE: string = 'avatar_addition_pet_experience_bubble';\r\n    private static POSTURE_ANIMATION_INDEX: number = 0;\r\n    private static GESTURE_ANIMATION_INDEX: number = 1;\r\n    private static ANIMATION_INDEX_COUNT: number = 2;\r\n\r\n    protected _data: PetVisualizationData;\r\n\r\n    private _posture: string;\r\n    private _gesture: string;\r\n    private _isSleeping: boolean;\r\n    private _headDirection: number;\r\n    private _headOnly: boolean;\r\n    private _nonHeadSprites: boolean[];\r\n    private _headSprites: boolean[];\r\n    private _saddleSprites: boolean[];\r\n    private _animationOver: boolean;\r\n    private _paletteIndex: number;\r\n    private _paletteName: string;\r\n    private _customLayerIds: number[];\r\n    private _customPartIds: number[];\r\n    private _customPaletteIds: number[];\r\n    private _isRiding: boolean;\r\n    private _color: number;\r\n    private _experience: number;\r\n    private _experienceTimestamp: number;\r\n    private _experienceData: ExperienceData;\r\n\r\n    private _previousAnimationDirection: number;\r\n    private _animationStates: AnimationStateData[];\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._data = null;\r\n\r\n        this._posture = '';\r\n        this._gesture = '';\r\n        this._isSleeping = false;\r\n        this._headDirection = -1;\r\n        this._headOnly = false;\r\n        this._nonHeadSprites = [];\r\n        this._headSprites = [];\r\n        this._saddleSprites = [];\r\n        this._animationOver = false;\r\n        this._paletteIndex = -1;\r\n        this._paletteName = '';\r\n        this._customLayerIds = [];\r\n        this._customPartIds = [];\r\n        this._customPaletteIds = [];\r\n        this._isRiding = false;\r\n        this._color = 0xFFFFFF;\r\n        this._experience = 0;\r\n        this._experienceTimestamp = 0;\r\n        this._experienceData = null;\r\n\r\n        this._previousAnimationDirection = -1;\r\n        this._animationStates = [];\r\n\r\n        while(this._animationStates.length < PetVisualization.ANIMATION_INDEX_COUNT) this._animationStates.push(new AnimationStateData());\r\n    }\r\n\r\n    public initialize(data: IObjectVisualizationData): boolean\r\n    {\r\n        if(!(data instanceof PetVisualizationData)) return false;\r\n\r\n        const texture = this.getPetAdditionAsset(PetVisualization.PET_EXPERIENCE_BUBBLE);\r\n\r\n        if(texture)\r\n        {\r\n            this._experienceData = new ExperienceData(texture);\r\n        }\r\n\r\n        return super.initialize(data);\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        super.dispose();\r\n\r\n        if(this._animationStates)\r\n        {\r\n            while(this._animationStates.length)\r\n            {\r\n                const animationState = this._animationStates[0];\r\n\r\n                if(animationState) animationState.dispose();\r\n\r\n                this._animationStates.pop();\r\n            }\r\n\r\n            this._animationStates = null;\r\n        }\r\n    }\r\n\r\n    protected getAnimationId(animationData: AnimationStateData): number\r\n    {\r\n        return animationData.animationId;\r\n    }\r\n\r\n    public update(geometry: IRoomGeometry, time: number, update: boolean, skipUpdate: boolean): void\r\n    {\r\n        super.update(geometry, time, update, skipUpdate);\r\n\r\n        this.updateExperienceBubble(time);\r\n    }\r\n\r\n    protected updateExperienceBubble(time: number): void\r\n    {\r\n        if(!this._experienceData) return;\r\n\r\n        this._experienceData.alpha = 0;\r\n\r\n        if(this._experienceTimestamp)\r\n        {\r\n            const difference = (time - this._experienceTimestamp);\r\n\r\n            if(difference < PetVisualization.EXPERIENCE_BUBBLE_VISIBLE_IN_MS)\r\n            {\r\n                this._experienceData.alpha = (Math.sin(((difference / PetVisualization.EXPERIENCE_BUBBLE_VISIBLE_IN_MS) * Math.PI)) * 0xFF);\r\n            }\r\n            else\r\n            {\r\n                this._experienceTimestamp = 0;\r\n            }\r\n\r\n            const sprite = this.getSprite((this.totalSprites - 1));\r\n\r\n            if(sprite)\r\n            {\r\n                if(this._experienceData.alpha > 0)\r\n                {\r\n                    const texture = this._experienceData.renderBubble(this._experience);\r\n\r\n                    if(texture)\r\n                    {\r\n                        sprite.texture = texture;\r\n                        sprite.offsetX = -20;\r\n                        sprite.offsetY = -80;\r\n                        sprite.alpha = this._experienceData.alpha;\r\n                        sprite.visible = true;\r\n                        sprite.relativeDepth = -0.2;\r\n\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                sprite.texture = null;\r\n                sprite.visible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected updateModel(scale: number): boolean\r\n    {\r\n        const model = this.object && this.object.model;\r\n\r\n        if(!model) return false;\r\n\r\n        if(this.updateModelCounter === model.updateCounter) return false;\r\n\r\n        const posture = model.getValue<string>(RoomObjectVariable.FIGURE_POSTURE);\r\n        const gesture = model.getValue<string>(RoomObjectVariable.FIGURE_GESTURE);\r\n\r\n        this.setPostureAndGesture(posture, gesture);\r\n\r\n        let alphaMultiplier = (model.getValue<number>(RoomObjectVariable.FURNITURE_ALPHA_MULTIPLIER) || null);\r\n\r\n        if(alphaMultiplier === null || isNaN(alphaMultiplier)) alphaMultiplier = 1;\r\n\r\n        if(this._alphaMultiplier !== alphaMultiplier)\r\n        {\r\n            this._alphaMultiplier = alphaMultiplier;\r\n\r\n            this._alphaChanged = true;\r\n        }\r\n\r\n        this._isSleeping = (model.getValue<number>(RoomObjectVariable.FIGURE_SLEEP) > 0);\r\n\r\n        const headDirection = model.getValue<number>(RoomObjectVariable.HEAD_DIRECTION);\r\n\r\n        if(!isNaN(headDirection) && this._data.isAllowedToTurnHead)\r\n        {\r\n            this._headDirection = headDirection;\r\n        }\r\n        else\r\n        {\r\n            this._headDirection = this.object.getDirection().x;\r\n        }\r\n\r\n        this._experience = (model.getValue<number>(RoomObjectVariable.FIGURE_GAINED_EXPERIENCE));\r\n        this._experienceTimestamp = (model.getValue<number>(RoomObjectVariable.FIGURE_EXPERIENCE_TIMESTAMP));\r\n\r\n        const customPaletteIndex = model.getValue<number>(RoomObjectVariable.PET_PALETTE_INDEX);\r\n        const customLayerIds = model.getValue<number[]>(RoomObjectVariable.PET_CUSTOM_LAYER_IDS);\r\n        const customPartIds = model.getValue<number[]>(RoomObjectVariable.PET_CUSTOM_PARTS_IDS);\r\n        const customPaletteIds = model.getValue<number[]>(RoomObjectVariable.PET_CUSTOM_PALETTE_IDS);\r\n        const isRiding = model.getValue<number>(RoomObjectVariable.PET_IS_RIDING);\r\n        const headOnly = model.getValue<number>(RoomObjectVariable.PET_HEAD_ONLY);\r\n        const color = model.getValue<number>(RoomObjectVariable.PET_COLOR);\r\n\r\n        if(customPaletteIndex !== this._paletteIndex)\r\n        {\r\n            this._paletteIndex = customPaletteIndex;\r\n            this._paletteName = this._paletteIndex.toString();\r\n        }\r\n\r\n        this._customLayerIds = (customLayerIds) ? customLayerIds : [];\r\n        this._customPartIds = (customPartIds) ? customPartIds : [];\r\n        this._customPaletteIds = (customPaletteIds) ? customPaletteIds : [];\r\n        this._isRiding = (!isNaN(isRiding) && (isRiding > 0));\r\n        this._headOnly = (!isNaN(headOnly) && (headOnly > 0));\r\n\r\n        if(!isNaN(color) && this._color !== color) this._color = color;\r\n\r\n        this.updateModelCounter = model.updateCounter;\r\n\r\n        return true;\r\n    }\r\n\r\n    protected updateAnimation(scale: number): number\r\n    {\r\n        if(this.object)\r\n        {\r\n            const direction = this.object.getDirection().x;\r\n\r\n            if(direction !== this._previousAnimationDirection)\r\n            {\r\n                this._previousAnimationDirection = direction;\r\n\r\n                this.resetAllAnimationFrames();\r\n            }\r\n        }\r\n\r\n        return super.updateAnimation(scale);\r\n    }\r\n\r\n    protected setPostureAndGesture(posture: string, gesture: string): void\r\n    {\r\n        if(posture !== this._posture)\r\n        {\r\n            this._posture = posture;\r\n\r\n            this.setAnimationForIndex(PetVisualization.POSTURE_ANIMATION_INDEX, this._data.postureToAnimation(this._scale, posture));\r\n        }\r\n\r\n        if(this._data.getGestureDisabled(this._scale, posture)) gesture = null;\r\n\r\n        if(gesture !== this._gesture)\r\n        {\r\n            this._gesture = gesture;\r\n\r\n            this.setAnimationForIndex(PetVisualization.GESTURE_ANIMATION_INDEX, this._data.gestureToAnimation(this._scale, gesture));\r\n        }\r\n    }\r\n\r\n    private getAnimationStateData(k: number): AnimationStateData\r\n    {\r\n        if((k >= 0) && (k < this._animationStates.length)) return this._animationStates[k];\r\n\r\n        return null;\r\n    }\r\n\r\n    private setAnimationForIndex(k: number, _arg_2: number): void\r\n    {\r\n        const animationStateData = this.getAnimationStateData(k);\r\n\r\n        if(animationStateData)\r\n        {\r\n            if(this.setSubAnimation(animationStateData, _arg_2)) this._animationOver = false;\r\n        }\r\n    }\r\n\r\n    protected resetAllAnimationFrames(): void\r\n    {\r\n        this._animationOver = false;\r\n\r\n        let index = (this._animationStates.length - 1);\r\n\r\n        while(index >= 0)\r\n        {\r\n            const stateData = this._animationStates[index];\r\n\r\n            if(stateData) stateData.setLayerCount(this.animatedLayerCount);\r\n\r\n            index--;\r\n        }\r\n    }\r\n\r\n    protected updateAnimations(scale: number): number\r\n    {\r\n        if(this._animationOver) return 0;\r\n\r\n        let animationOver = true;\r\n        let _local_3 = 0;\r\n        let index = 0;\r\n\r\n        while(index < this._animationStates.length)\r\n        {\r\n            const stateData = this._animationStates[index];\r\n\r\n            if(stateData)\r\n            {\r\n                if(!stateData.animationOver)\r\n                {\r\n                    const _local_6 = this.updateFramesForAnimation(stateData, scale);\r\n\r\n                    _local_3 = (_local_3 | _local_6);\r\n\r\n                    if(!stateData.animationOver)\r\n                    {\r\n                        animationOver = false;\r\n                    }\r\n                    else\r\n                    {\r\n                        if(AnimationData.isTransitionFromAnimation(stateData.animationId) || AnimationData.isTransitionToAnimation(stateData.animationId))\r\n                        {\r\n                            this.setAnimationForIndex(index, stateData.animationAfterTransitionId);\r\n\r\n                            animationOver = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        this._animationOver = animationOver;\r\n\r\n        return _local_3;\r\n    }\r\n\r\n    protected getSpriteAssetName(scale: number, layerId: number): string\r\n    {\r\n        if(this._headOnly && this.isNonHeadSprite(layerId)) return null;\r\n\r\n        if(this._isRiding && this._parser3(layerId)) return null;\r\n\r\n        const totalSprites = this.totalSprites;\r\n\r\n        if(layerId < (totalSprites - PetVisualization.ADDITIONAL_SPRITE_COUNT))\r\n        {\r\n            const validScale = this.getValidSize(scale);\r\n\r\n            if(layerId < (totalSprites - (1 + PetVisualization.ADDITIONAL_SPRITE_COUNT)))\r\n            {\r\n                if(layerId >= FurnitureVisualizationData.LAYER_LETTERS.length) return null;\r\n\r\n                const layerLetter = FurnitureVisualizationData.LAYER_LETTERS[layerId];\r\n\r\n                if(validScale === 1) return (this._type + '_icon_' + layerLetter);\r\n\r\n                return (this._type + '_' + validScale + '_' + layerLetter + '_' + this.getDirection(scale, layerId) + '_' + this.getFrameNumber(validScale, layerId));\r\n            }\r\n\r\n            return (this._type + '_' + validScale + '_sd_' + this.getDirection(scale, layerId) + '_0');\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    protected getLayerColor(scale: number, layerId: number, colorId: number): number\r\n    {\r\n        if(layerId < (this.totalSprites - PetVisualization.ADDITIONAL_SPRITE_COUNT)) return this._color;\r\n\r\n        return 0xFFFFFF;\r\n    }\r\n\r\n    protected getLayerXOffset(scale: number, direction: number, layerId: number): number\r\n    {\r\n        let offset = super.getLayerXOffset(scale, direction, layerId);\r\n        let index = (this._animationStates.length - 1);\r\n\r\n        while(index >= 0)\r\n        {\r\n            const stateData = this._animationStates[index];\r\n\r\n            if(stateData)\r\n            {\r\n                const frame = stateData.getFrame(layerId);\r\n\r\n                if(frame) offset += frame.x;\r\n            }\r\n\r\n            index--;\r\n        }\r\n\r\n        return offset;\r\n    }\r\n\r\n    protected getLayerYOffset(scale: number, direction: number, layerId: number): number\r\n    {\r\n        let offset = super.getLayerYOffset(scale, direction, layerId);\r\n        let index = (this._animationStates.length - 1);\r\n\r\n        while(index >= 0)\r\n        {\r\n            const stateData = this._animationStates[index];\r\n\r\n            if(stateData)\r\n            {\r\n                const frame = stateData.getFrame(layerId);\r\n\r\n                if(frame) offset += frame.y;\r\n            }\r\n\r\n            index--;\r\n        }\r\n\r\n        return offset;\r\n    }\r\n\r\n    protected getLayerZOffset(scale: number, direction: number, layerId: number): number\r\n    {\r\n        if(!this._data) return LayerData.DEFAULT_ZOFFSET;\r\n\r\n        return this._data.getLayerZOffset(scale, this.getDirection(scale, layerId), layerId);\r\n    }\r\n\r\n    private getDirection(scale: number, layerId: number): number\r\n    {\r\n        if(!this.isHeadSprite(layerId)) return this._direction;\r\n\r\n        return this._data.getValidDirection(scale, this._headDirection);\r\n    }\r\n\r\n    protected getFrameNumber(scale: number, layerId: number): number\r\n    {\r\n        let index = (this._animationStates.length - 1);\r\n\r\n        while(index >= 0)\r\n        {\r\n            const stateData = this._animationStates[index];\r\n\r\n            if(stateData)\r\n            {\r\n                const frame = stateData.getFrame(layerId);\r\n\r\n                if(frame) return frame.id;\r\n            }\r\n\r\n            index--;\r\n        }\r\n\r\n        return super.getFrameNumber(scale, layerId);\r\n    }\r\n\r\n    private isHeadSprite(layerId: number): boolean\r\n    {\r\n        if(this._headSprites[layerId] === undefined)\r\n        {\r\n            const isHead = (this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.HEAD);\r\n            const isHair = (this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.HAIR);\r\n\r\n            if(isHead || isHair) this._headSprites[layerId] = true;\r\n            else this._headSprites[layerId] = false;\r\n        }\r\n\r\n        return this._headSprites[layerId];\r\n    }\r\n\r\n    private isNonHeadSprite(layerId: number): boolean\r\n    {\r\n        if(this._nonHeadSprites[layerId] === undefined)\r\n        {\r\n            if(layerId < (this.totalSprites - (1 + PetVisualization.ADDITIONAL_SPRITE_COUNT)))\r\n            {\r\n                const tag = this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId);\r\n\r\n                if(((tag && (tag.length > 0)) && (tag !== PetVisualization.HEAD)) && (tag !== PetVisualization.HAIR))\r\n                {\r\n                    this._nonHeadSprites[layerId] = true;\r\n                }\r\n                else\r\n                {\r\n                    this._nonHeadSprites[layerId] = false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this._nonHeadSprites[layerId] = true;\r\n            }\r\n        }\r\n\r\n        return this._nonHeadSprites[layerId];\r\n    }\r\n\r\n    private _parser3(layerId: number): boolean\r\n    {\r\n        if(this._saddleSprites[layerId] === undefined)\r\n        {\r\n            if(this._data.getLayerTag(this._scale, DirectionData.USE_DEFAULT_DIRECTION, layerId) === PetVisualization.SADDLE)\r\n            {\r\n                this._saddleSprites[layerId] = true;\r\n            }\r\n            else\r\n            {\r\n                this._saddleSprites[layerId] = false;\r\n            }\r\n        }\r\n\r\n        return this._saddleSprites[layerId];\r\n    }\r\n\r\n    public getAsset(name: string, layerId: number = -1): IGraphicAsset\r\n    {\r\n        if(!this.asset) return null;\r\n\r\n        const layerIndex = this._customLayerIds.indexOf(layerId);\r\n        let paletteName = this._paletteName;\r\n        let partId = -1;\r\n        let paletteId = -1;\r\n\r\n        if(layerIndex > -1)\r\n        {\r\n            partId = this._customPartIds[layerIndex];\r\n            paletteId = this._customPaletteIds[layerIndex];\r\n            paletteName = ((paletteId > -1) ? paletteId.toString() : this._paletteName);\r\n        }\r\n\r\n        if(!(isNaN(partId)) && (partId > -1))\r\n        {\r\n            name = (name + '_' + partId);\r\n        }\r\n\r\n        return this.asset.getAssetWithPalette(name, paletteName);\r\n    }\r\n\r\n    protected getAdditionalLayerCount(): number\r\n    {\r\n        return super.getAdditionalLayerCount() + PetVisualization.ADDITIONAL_SPRITE_COUNT;\r\n    }\r\n\r\n    protected setLayerCount(count: number): void\r\n    {\r\n        super.setLayerCount(count);\r\n\r\n        this._headSprites = [];\r\n    }\r\n\r\n    protected getPostureForAsset(scale: number, name: string): string\r\n    {\r\n        const parts = name.split('_');\r\n        let length = parts.length;\r\n        let i = 0;\r\n\r\n        while(i < parts.length)\r\n        {\r\n            if((parts[i] === '64') || (parts[i] === '32'))\r\n            {\r\n                length = (i + 3);\r\n\r\n                break;\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        let posture: string = null;\r\n\r\n        if(length < parts.length)\r\n        {\r\n            let part = parts[length];\r\n\r\n            part = part.split('@')[0];\r\n\r\n            posture = this._data.animationToPosture(scale, (parseInt(part) / 100), false);\r\n\r\n            if(!posture) posture = this._data.getGestureForAnimationId(scale, (parseInt(part) / 100));\r\n        }\r\n\r\n        return posture;\r\n    }\r\n\r\n    public getPetAdditionAsset(name: string): Texture<Resource>\r\n    {\r\n        return Nitro.instance.core.asset.getTexture(name);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}