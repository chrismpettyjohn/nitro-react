{"ast":null,"code":"import { BLEND_MODES } from '@pixi/constants';\nimport { Texture } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { NitroSprite } from '../../../core';\nimport { TextureUtils } from '../../utils';\nexport class ExtendedSprite extends Sprite {\n  constructor() {\n    let texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(texture);\n    this._offsetX = void 0;\n    this._offsetY = void 0;\n    this._tag = void 0;\n    this._alphaTolerance = void 0;\n    this._varyingDepth = void 0;\n    this._clickHandling = void 0;\n    this._pairedSpriteId = void 0;\n    this._pairedSpriteUpdateCounter = void 0;\n    this.name = void 0;\n    this._offsetX = 0;\n    this._offsetY = 0;\n    this._tag = '';\n    this._alphaTolerance = 128;\n    this._varyingDepth = false;\n    this._clickHandling = false;\n    this._pairedSpriteId = -1;\n    this._pairedSpriteUpdateCounter = -1;\n  }\n\n  needsUpdate(pairedSpriteId, pairedSpriteUpdateCounter) {\n    if (this._pairedSpriteId === pairedSpriteId && this._pairedSpriteUpdateCounter === pairedSpriteUpdateCounter) return false;\n    this._pairedSpriteId = pairedSpriteId;\n    this._pairedSpriteUpdateCounter = pairedSpriteUpdateCounter;\n    return true;\n  }\n\n  calculateVertices() {\n    if (!this.texture.orig) return;\n    super.calculateVertices();\n  }\n\n  setTexture(texture) {\n    if (!texture) texture = Texture.EMPTY;\n    if (texture === this.texture) return;\n\n    if (texture === Texture.EMPTY) {\n      this._pairedSpriteId = -1;\n      this._pairedSpriteUpdateCounter = -1;\n    }\n\n    this.texture = texture;\n  }\n\n  containsPoint(point) {\n    return ExtendedSprite.containsPoint(this, point);\n  }\n\n  static containsPoint(sprite, point) {\n    if (!sprite || !point || sprite.alphaTolerance > 255) return false;\n    if (!(sprite instanceof Sprite)) return false;\n    if (sprite.texture === Texture.EMPTY || sprite.blendMode !== BLEND_MODES.NORMAL) return;\n    const texture = sprite.texture;\n    const baseTexture = texture.baseTexture;\n    if (!texture || !baseTexture || !baseTexture.valid) return false;\n    const x = point.x * sprite.scale.x;\n    const y = point.y * sprite.scale.y;\n    if (!sprite.getLocalBounds().contains(x, y)) return false; //@ts-ignore\n\n    if (!baseTexture.hitMap) {\n      let canvas = null;\n\n      if (!baseTexture.resource) {\n        //@ts-ignore\n        if (!texture.getLocalBounds) {\n          const tempSprite = new NitroSprite(texture);\n          canvas = TextureUtils.generateCanvas(tempSprite);\n          tempSprite.destroy();\n        } else {\n          canvas = TextureUtils.generateCanvas(texture);\n        }\n      }\n\n      if (!ExtendedSprite.generateHitMap(baseTexture, canvas)) return false;\n    } //@ts-ignore\n\n\n    const hitMap = baseTexture.hitMap;\n    let dx = x + texture.frame.x;\n    let dy = y + texture.frame.y;\n\n    if (texture.trim) {\n      dx -= texture.trim.x;\n      dy -= texture.trim.y;\n    }\n\n    dx = Math.round(dx) * baseTexture.resolution;\n    dy = Math.round(dy) * baseTexture.resolution;\n    const ind = dx + dy * baseTexture.realWidth;\n    const ind1 = ind % 32;\n    const ind2 = ind / 32 | 0;\n    return (hitMap[ind2] & 1 << ind1) !== 0;\n  }\n\n  static generateHitMap(baseTexture) {\n    let tempCanvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let canvas = null;\n    let context = null;\n\n    if (tempCanvas) {\n      canvas = tempCanvas;\n      context = canvas.getContext('2d');\n    } else {\n      if (!baseTexture.resource) return false; //@ts-ignore\n\n      const source = baseTexture.resource.source;\n      if (!source) return false;\n\n      if (source.getContext) {\n        canvas = source;\n        context = canvas.getContext('2d');\n      } else if (source instanceof Image) {\n        canvas = document.createElement('canvas');\n        canvas.width = source.width;\n        canvas.height = source.height;\n        context = canvas.getContext('2d');\n        context.drawImage(source, 0, 0);\n      } else return false;\n    }\n\n    const width = canvas.width;\n    const height = canvas.height;\n    const imageData = context.getImageData(0, 0, width, height);\n    const hitmap = new Uint32Array(Math.ceil(width * height / 32));\n    const threshold = 128;\n\n    for (let i = 0; i < width * height; i++) {\n      const ind1 = i % 32;\n      const ind2 = i / 32 | 0;\n\n      if (imageData.data[i * 4 + 3] >= threshold) {\n        hitmap[ind2] = hitmap[ind2] | 1 << ind1;\n      }\n    } //@ts-ignore\n\n\n    baseTexture.hitMap = hitmap;\n    return true;\n  }\n\n  get offsetX() {\n    return this._offsetX;\n  }\n\n  set offsetX(offset) {\n    this._offsetX = offset;\n  }\n\n  get offsetY() {\n    return this._offsetY;\n  }\n\n  set offsetY(offset) {\n    this._offsetY = offset;\n  }\n\n  get tag() {\n    return this._tag;\n  }\n\n  set tag(tag) {\n    this._tag = tag;\n  }\n\n  get alphaTolerance() {\n    return this._alphaTolerance;\n  }\n\n  set alphaTolerance(tolerance) {\n    this._alphaTolerance = tolerance;\n  }\n\n  get varyingDepth() {\n    return this._varyingDepth;\n  }\n\n  set varyingDepth(flag) {\n    this._varyingDepth = flag;\n  }\n\n  get clickHandling() {\n    return this._clickHandling;\n  }\n\n  set clickHandling(flag) {\n    this._clickHandling = flag;\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/room/renderer/utils/ExtendedSprite.ts"],"names":["BLEND_MODES","Texture","Sprite","NitroSprite","TextureUtils","ExtendedSprite","constructor","texture","_offsetX","_offsetY","_tag","_alphaTolerance","_varyingDepth","_clickHandling","_pairedSpriteId","_pairedSpriteUpdateCounter","name","needsUpdate","pairedSpriteId","pairedSpriteUpdateCounter","calculateVertices","orig","setTexture","EMPTY","containsPoint","point","sprite","alphaTolerance","blendMode","NORMAL","baseTexture","valid","x","scale","y","getLocalBounds","contains","hitMap","canvas","resource","tempSprite","generateCanvas","destroy","generateHitMap","dx","frame","dy","trim","Math","round","resolution","ind","realWidth","ind1","ind2","tempCanvas","context","getContext","source","Image","document","createElement","width","height","drawImage","imageData","getImageData","hitmap","Uint32Array","ceil","threshold","i","data","offsetX","offset","offsetY","tag","tolerance","varyingDepth","flag","clickHandling"],"mappings":"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","sourcesContent":["import { BLEND_MODES } from '@pixi/constants';\r\nimport { BaseTexture, RenderTexture, Resource, Texture } from '@pixi/core';\r\nimport { Point } from '@pixi/math';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { NitroSprite } from '../../../core';\r\nimport { TextureUtils } from '../../utils';\r\n\r\nexport class ExtendedSprite extends Sprite\r\n{\r\n    private _offsetX: number;\r\n    private _offsetY: number;\r\n    private _tag: string;\r\n    private _alphaTolerance: number;\r\n    private _varyingDepth: boolean;\r\n    private _clickHandling: boolean;\r\n\r\n    private _pairedSpriteId: number;\r\n    private _pairedSpriteUpdateCounter: number;\r\n\r\n    public name: string;\r\n\r\n    constructor(texture: Texture<Resource> = null)\r\n    {\r\n        super(texture);\r\n\r\n        this._offsetX = 0;\r\n        this._offsetY = 0;\r\n        this._tag = '';\r\n        this._alphaTolerance = 128;\r\n        this._varyingDepth = false;\r\n        this._clickHandling = false;\r\n\r\n        this._pairedSpriteId = -1;\r\n        this._pairedSpriteUpdateCounter = -1;\r\n    }\r\n\r\n    public needsUpdate(pairedSpriteId: number, pairedSpriteUpdateCounter: number): boolean\r\n    {\r\n        if((this._pairedSpriteId === pairedSpriteId) && (this._pairedSpriteUpdateCounter === pairedSpriteUpdateCounter)) return false;\r\n\r\n        this._pairedSpriteId = pairedSpriteId;\r\n        this._pairedSpriteUpdateCounter = pairedSpriteUpdateCounter;\r\n\r\n        return true;\r\n    }\r\n\r\n    public calculateVertices(): void\r\n    {\r\n        if(!this.texture.orig) return;\r\n\r\n        super.calculateVertices();\r\n    }\r\n\r\n    public setTexture(texture: Texture<Resource>): void\r\n    {\r\n        if(!texture) texture = Texture.EMPTY;\r\n\r\n        if(texture === this.texture) return;\r\n\r\n        if(texture === Texture.EMPTY)\r\n        {\r\n            this._pairedSpriteId = -1;\r\n            this._pairedSpriteUpdateCounter = -1;\r\n        }\r\n\r\n        this.texture = texture;\r\n    }\r\n\r\n    public containsPoint(point: Point): boolean\r\n    {\r\n        return ExtendedSprite.containsPoint(this, point);\r\n    }\r\n\r\n    public static containsPoint(sprite: ExtendedSprite, point: Point): boolean\r\n    {\r\n        if(!sprite || !point || (sprite.alphaTolerance > 255)) return false;\r\n\r\n        if(!(sprite instanceof Sprite)) return false;\r\n\r\n        if((sprite.texture === Texture.EMPTY) || (sprite.blendMode !== BLEND_MODES.NORMAL)) return;\r\n\r\n        const texture = sprite.texture;\r\n        const baseTexture = texture.baseTexture;\r\n\r\n        if(!texture || !baseTexture || !baseTexture.valid) return false;\r\n\r\n        const x = (point.x * sprite.scale.x);\r\n        const y = (point.y * sprite.scale.y);\r\n\r\n        if(!sprite.getLocalBounds().contains(x, y)) return false;\r\n\r\n        //@ts-ignore\r\n        if(!baseTexture.hitMap)\r\n        {\r\n            let canvas: HTMLCanvasElement = null;\r\n\r\n            if(!baseTexture.resource)\r\n            {\r\n                //@ts-ignore\r\n                if(!texture.getLocalBounds)\r\n                {\r\n                    const tempSprite = new NitroSprite(texture);\r\n\r\n                    canvas = TextureUtils.generateCanvas(tempSprite);\r\n\r\n                    tempSprite.destroy();\r\n                }\r\n                else\r\n                {\r\n                    canvas = TextureUtils.generateCanvas(texture as RenderTexture);\r\n                }\r\n            }\r\n\r\n            if(!ExtendedSprite.generateHitMap(baseTexture, canvas)) return false;\r\n        }\r\n\r\n        //@ts-ignore\r\n        const hitMap = (baseTexture.hitMap as Uint32Array);\r\n\r\n        let dx = (x + texture.frame.x);\r\n        let dy = (y + texture.frame.y);\r\n\r\n        if(texture.trim)\r\n        {\r\n            dx -= texture.trim.x;\r\n            dy -= texture.trim.y;\r\n        }\r\n\r\n        dx = (Math.round(dx) * baseTexture.resolution);\r\n        dy = (Math.round(dy) * baseTexture.resolution);\r\n\r\n        const ind = (dx + dy * baseTexture.realWidth);\r\n        const ind1 = ind % 32;\r\n        const ind2 = ind / 32 | 0;\r\n\r\n        return (hitMap[ind2] & (1 << ind1)) !== 0;\r\n    }\r\n\r\n    private static generateHitMap(baseTexture: BaseTexture, tempCanvas: HTMLCanvasElement = null): boolean\r\n    {\r\n        let canvas: HTMLCanvasElement = null;\r\n        let context: CanvasRenderingContext2D = null;\r\n\r\n        if(tempCanvas)\r\n        {\r\n            canvas = tempCanvas;\r\n            context = canvas.getContext('2d');\r\n        }\r\n        else\r\n        {\r\n            if(!baseTexture.resource) return false;\r\n\r\n            //@ts-ignore\r\n            const source = baseTexture.resource.source as HTMLCanvasElement;\r\n\r\n            if(!source) return false;\r\n\r\n            if(source.getContext)\r\n            {\r\n                canvas = source;\r\n                context = canvas.getContext('2d');\r\n            }\r\n\r\n            else if(source instanceof Image)\r\n            {\r\n                canvas = document.createElement('canvas');\r\n                canvas.width = source.width;\r\n                canvas.height = source.height;\r\n                context = canvas.getContext('2d');\r\n\r\n                context.drawImage(source, 0, 0);\r\n            }\r\n\r\n            else return false;\r\n        }\r\n\r\n        const width = canvas.width;\r\n        const height = canvas.height;\r\n        const imageData = context.getImageData(0, 0, width, height);\r\n\r\n        const hitmap = new Uint32Array(Math.ceil(width * height / 32));\r\n        const threshold = 128;\r\n\r\n        for(let i = 0; i < width * height; i++)\r\n        {\r\n            const ind1 = i % 32;\r\n            const ind2 = i / 32 | 0;\r\n\r\n            if(imageData.data[i * 4 + 3] >= threshold)\r\n            {\r\n                hitmap[ind2] = hitmap[ind2] | (1 << ind1);\r\n            }\r\n        }\r\n\r\n        //@ts-ignore\r\n        baseTexture.hitMap = hitmap;\r\n\r\n        return true;\r\n    }\r\n\r\n    public get offsetX(): number\r\n    {\r\n        return this._offsetX;\r\n    }\r\n\r\n    public set offsetX(offset: number)\r\n    {\r\n        this._offsetX = offset;\r\n    }\r\n\r\n    public get offsetY(): number\r\n    {\r\n        return this._offsetY;\r\n    }\r\n\r\n    public set offsetY(offset: number)\r\n    {\r\n        this._offsetY = offset;\r\n    }\r\n\r\n    public get tag(): string\r\n    {\r\n        return this._tag;\r\n    }\r\n\r\n    public set tag(tag: string)\r\n    {\r\n        this._tag = tag;\r\n    }\r\n\r\n    public get alphaTolerance(): number\r\n    {\r\n        return this._alphaTolerance;\r\n    }\r\n\r\n    public set alphaTolerance(tolerance: number)\r\n    {\r\n        this._alphaTolerance = tolerance;\r\n    }\r\n\r\n    public get varyingDepth(): boolean\r\n    {\r\n        return this._varyingDepth;\r\n    }\r\n\r\n    public set varyingDepth(flag: boolean)\r\n    {\r\n        this._varyingDepth = flag;\r\n    }\r\n\r\n    public get clickHandling(): boolean\r\n    {\r\n        return this._clickHandling;\r\n    }\r\n\r\n    public set clickHandling(flag: boolean)\r\n    {\r\n        this._clickHandling = flag;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}