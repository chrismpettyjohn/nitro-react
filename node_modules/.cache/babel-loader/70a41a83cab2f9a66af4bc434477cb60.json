{"ast":null,"code":"import { Point } from '@pixi/math';\nimport { Vector3d } from '../../../room/utils/Vector3d';\nexport class RoomWallData {\n  constructor() {\n    this._corners = void 0;\n    this._endPoints = void 0;\n    this._directions = void 0;\n    this._lengths = void 0;\n    this._leftTurns = void 0;\n    this._borders = void 0;\n    this._hideWalls = void 0;\n    this._manuallyLeftCut = void 0;\n    this._manuallyRightCut = void 0;\n    this._addDuplicates = void 0;\n    this._count = void 0;\n    this._corners = [];\n    this._endPoints = [];\n    this._directions = [];\n    this._lengths = [];\n    this._leftTurns = [];\n    this._borders = [];\n    this._hideWalls = [];\n    this._manuallyLeftCut = [];\n    this._manuallyRightCut = [];\n    this._addDuplicates = false;\n    this._count = 0;\n  }\n\n  addWall(k, _arg_2, _arg_3, _arg_4, _arg_5) {\n    if (this._addDuplicates || this.checkIsNotDuplicate(k, _arg_2, _arg_3, _arg_4, _arg_5)) {\n      this._corners.push(k);\n\n      this._directions.push(_arg_2);\n\n      this._lengths.push(_arg_3);\n\n      this._borders.push(_arg_4);\n\n      this._leftTurns.push(_arg_5);\n\n      this._hideWalls.push(false);\n\n      this._manuallyLeftCut.push(false);\n\n      this._manuallyRightCut.push(false);\n\n      this._count++;\n    }\n  }\n\n  checkIsNotDuplicate(k, _arg_2, _arg_3, _arg_4, _arg_5) {\n    let _local_6 = 0;\n\n    while (_local_6 < this._count) {\n      if (this._corners[_local_6].x == k.x && this._corners[_local_6].y == k.y && this._directions[_local_6] == _arg_2 && this._lengths[_local_6] == _arg_3 && this._borders[_local_6] == _arg_4 && this._leftTurns[_local_6] == _arg_5) {\n        return false;\n      }\n\n      _local_6++;\n    }\n\n    return true;\n  }\n\n  get count() {\n    return this._count;\n  }\n\n  getCorner(k) {\n    return this._corners[k];\n  }\n\n  getEndPoint(k) {\n    this.calculateWallEndPoints();\n    return this._endPoints[k];\n  }\n\n  getLength(k) {\n    return this._lengths[k];\n  }\n\n  getDirection(k) {\n    return this._directions[k];\n  }\n\n  getBorder(k) {\n    return this._borders[k];\n  }\n\n  getHideWall(k) {\n    return this._hideWalls[k];\n  }\n\n  getLeftTurn(k) {\n    return this._leftTurns[k];\n  }\n\n  getManuallyLeftCut(k) {\n    return this._manuallyLeftCut[k];\n  }\n\n  getManuallyRightCut(k) {\n    return this._manuallyRightCut[k];\n  }\n\n  setHideWall(k, _arg_2) {\n    this._hideWalls[k] = _arg_2;\n  }\n\n  setLength(k, _arg_2) {\n    if (_arg_2 < this._lengths[k]) {\n      this._lengths[k] = _arg_2;\n      this._manuallyRightCut[k] = true;\n    }\n  }\n\n  moveCorner(k, _arg_2) {\n    let _local_3;\n\n    if (_arg_2 > 0 && _arg_2 < this._lengths[k]) {\n      const corner = this._corners[k];\n      _local_3 = RoomWallData.WALL_DIRECTION_VECTORS[this.getDirection(k)];\n      this._corners[k] = new Point(corner.x + _arg_2 * _local_3.x, corner.y + _arg_2 * _local_3.y);\n      this._lengths[k] = this._lengths[k] - _arg_2;\n      this._manuallyLeftCut[k] = true;\n    }\n  }\n\n  calculateWallEndPoints() {\n    let k;\n\n    let _local_2;\n\n    let _local_3;\n\n    let _local_4;\n\n    let _local_5;\n\n    if (this._endPoints.length != this.count) {\n      this._endPoints = [];\n      k = 0;\n\n      while (k < this.count) {\n        _local_2 = this.getCorner(k);\n        _local_3 = new Point(_local_2.x, _local_2.y);\n        _local_4 = RoomWallData.WALL_DIRECTION_VECTORS[this.getDirection(k)];\n        _local_5 = this.getLength(k);\n        _local_3.x = _local_3.x + _local_4.x * _local_5;\n        _local_3.y = _local_3.y + _local_4.y * _local_5;\n\n        this._endPoints.push(_local_3);\n\n        k++;\n      }\n    }\n  }\n\n}\nRoomWallData.WALL_DIRECTION_VECTORS = [new Vector3d(1, 0, 0), new Vector3d(0, 1, 0), new Vector3d(-1, 0, 0), new Vector3d(0, -1, 0)];\nRoomWallData.WALL_NORMAL_VECTORS = [new Vector3d(0, 1, 0), new Vector3d(-1, 0, 0), new Vector3d(0, -1, 0), new Vector3d(1, 0, 0)];","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/RoomWallData.ts"],"names":["Point","Vector3d","RoomWallData","constructor","_corners","_endPoints","_directions","_lengths","_leftTurns","_borders","_hideWalls","_manuallyLeftCut","_manuallyRightCut","_addDuplicates","_count","addWall","k","_arg_2","_arg_3","_arg_4","_arg_5","checkIsNotDuplicate","push","_local_6","x","y","count","getCorner","getEndPoint","calculateWallEndPoints","getLength","getDirection","getBorder","getHideWall","getLeftTurn","getManuallyLeftCut","getManuallyRightCut","setHideWall","setLength","moveCorner","_local_3","corner","WALL_DIRECTION_VECTORS","_local_2","_local_4","_local_5","length","WALL_NORMAL_VECTORS"],"mappings":"AAAA,SAASA,KAAT,QAAsB,YAAtB;AAEA,SAASC,QAAT,QAAyB,8BAAzB;AAEA,OAAO,MAAMC,YAAN,CACP;AA2BIC,EAAAA,WAAW,GACX;AAAA,SAbQC,QAaR;AAAA,SAZQC,UAYR;AAAA,SAXQC,WAWR;AAAA,SAVQC,QAUR;AAAA,SATQC,UASR;AAAA,SARQC,QAQR;AAAA,SAPQC,UAOR;AAAA,SANQC,gBAMR;AAAA,SALQC,iBAKR;AAAA,SAJQC,cAIR;AAAA,SAHQC,MAGR;AACI,SAAKV,QAAL,GAAgB,EAAhB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,cAAL,GAAsB,KAAtB;AACA,SAAKC,MAAL,GAAc,CAAd;AACH;;AAEMC,EAAAA,OAAO,CAACC,CAAD,EAAWC,MAAX,EAA2BC,MAA3B,EAA2CC,MAA3C,EAA4DC,MAA5D,EACd;AACI,QAAK,KAAKP,cAAN,IAA0B,KAAKQ,mBAAL,CAAyBL,CAAzB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,MAApD,CAA9B,EACA;AACI,WAAKhB,QAAL,CAAckB,IAAd,CAAmBN,CAAnB;;AACA,WAAKV,WAAL,CAAiBgB,IAAjB,CAAsBL,MAAtB;;AACA,WAAKV,QAAL,CAAce,IAAd,CAAmBJ,MAAnB;;AACA,WAAKT,QAAL,CAAca,IAAd,CAAmBH,MAAnB;;AACA,WAAKX,UAAL,CAAgBc,IAAhB,CAAqBF,MAArB;;AACA,WAAKV,UAAL,CAAgBY,IAAhB,CAAqB,KAArB;;AACA,WAAKX,gBAAL,CAAsBW,IAAtB,CAA2B,KAA3B;;AACA,WAAKV,iBAAL,CAAuBU,IAAvB,CAA4B,KAA5B;;AACA,WAAKR,MAAL;AACH;AACJ;;AAEOO,EAAAA,mBAAmB,CAACL,CAAD,EAAWC,MAAX,EAA2BC,MAA3B,EAA2CC,MAA3C,EAA4DC,MAA5D,EAC3B;AACI,QAAIG,QAAQ,GAAG,CAAf;;AAEA,WAAMA,QAAQ,GAAG,KAAKT,MAAtB,EACA;AACI,UAAS,KAAKV,QAAL,CAAcmB,QAAd,EAAwBC,CAAxB,IAA6BR,CAAC,CAACQ,CAAhC,IAAuC,KAAKpB,QAAL,CAAcmB,QAAd,EAAwBE,CAAxB,IAA6BT,CAAC,CAACS,CAAvE,IAA+E,KAAKnB,WAAL,CAAiBiB,QAAjB,KAA8BN,MAA9G,IAA2H,KAAKV,QAAL,CAAcgB,QAAd,KAA2BL,MAAvJ,IAAoK,KAAKT,QAAL,CAAcc,QAAd,KAA2BJ,MAAhM,IAA6M,KAAKX,UAAL,CAAgBe,QAAhB,KAA6BH,MAA9O,EACA;AACI,eAAO,KAAP;AACH;;AACDG,MAAAA,QAAQ;AACX;;AACD,WAAO,IAAP;AACH;;AAEe,MAALG,KAAK,GAChB;AACI,WAAO,KAAKZ,MAAZ;AACH;;AAEMa,EAAAA,SAAS,CAACX,CAAD,EAChB;AACI,WAAO,KAAKZ,QAAL,CAAcY,CAAd,CAAP;AACH;;AAEMY,EAAAA,WAAW,CAACZ,CAAD,EAClB;AACI,SAAKa,sBAAL;AACA,WAAO,KAAKxB,UAAL,CAAgBW,CAAhB,CAAP;AACH;;AAEMc,EAAAA,SAAS,CAACd,CAAD,EAChB;AACI,WAAO,KAAKT,QAAL,CAAcS,CAAd,CAAP;AACH;;AAEMe,EAAAA,YAAY,CAACf,CAAD,EACnB;AACI,WAAO,KAAKV,WAAL,CAAiBU,CAAjB,CAAP;AACH;;AAEMgB,EAAAA,SAAS,CAAChB,CAAD,EAChB;AACI,WAAO,KAAKP,QAAL,CAAcO,CAAd,CAAP;AACH;;AAEMiB,EAAAA,WAAW,CAACjB,CAAD,EAClB;AACI,WAAO,KAAKN,UAAL,CAAgBM,CAAhB,CAAP;AACH;;AAEMkB,EAAAA,WAAW,CAAClB,CAAD,EAClB;AACI,WAAO,KAAKR,UAAL,CAAgBQ,CAAhB,CAAP;AACH;;AAEMmB,EAAAA,kBAAkB,CAACnB,CAAD,EACzB;AACI,WAAO,KAAKL,gBAAL,CAAsBK,CAAtB,CAAP;AACH;;AAEMoB,EAAAA,mBAAmB,CAACpB,CAAD,EAC1B;AACI,WAAO,KAAKJ,iBAAL,CAAuBI,CAAvB,CAAP;AACH;;AAEMqB,EAAAA,WAAW,CAACrB,CAAD,EAAYC,MAAZ,EAClB;AACI,SAAKP,UAAL,CAAgBM,CAAhB,IAAqBC,MAArB;AACH;;AAEMqB,EAAAA,SAAS,CAACtB,CAAD,EAAYC,MAAZ,EAChB;AACI,QAAGA,MAAM,GAAG,KAAKV,QAAL,CAAcS,CAAd,CAAZ,EACA;AACI,WAAKT,QAAL,CAAcS,CAAd,IAAmBC,MAAnB;AACA,WAAKL,iBAAL,CAAuBI,CAAvB,IAA4B,IAA5B;AACH;AACJ;;AAEMuB,EAAAA,UAAU,CAACvB,CAAD,EAAYC,MAAZ,EACjB;AACI,QAAIuB,QAAJ;;AACA,QAAKvB,MAAM,GAAG,CAAV,IAAiBA,MAAM,GAAG,KAAKV,QAAL,CAAcS,CAAd,CAA9B,EACA;AACI,YAAMyB,MAAM,GAAG,KAAKrC,QAAL,CAAcY,CAAd,CAAf;AAEAwB,MAAAA,QAAQ,GAAGtC,YAAY,CAACwC,sBAAb,CAAoC,KAAKX,YAAL,CAAkBf,CAAlB,CAApC,CAAX;AACA,WAAKZ,QAAL,CAAcY,CAAd,IAAmB,IAAIhB,KAAJ,CAAWyC,MAAM,CAACjB,CAAP,GAAYP,MAAM,GAAGuB,QAAQ,CAAChB,CAAzC,EAA+CiB,MAAM,CAAChB,CAAP,GAAYR,MAAM,GAAGuB,QAAQ,CAACf,CAA7E,CAAnB;AACA,WAAKlB,QAAL,CAAcS,CAAd,IAAoB,KAAKT,QAAL,CAAcS,CAAd,IAAmBC,MAAvC;AACA,WAAKN,gBAAL,CAAsBK,CAAtB,IAA2B,IAA3B;AACH;AACJ;;AAEOa,EAAAA,sBAAsB,GAC9B;AACI,QAAIb,CAAJ;;AACA,QAAI2B,QAAJ;;AACA,QAAIH,QAAJ;;AACA,QAAII,QAAJ;;AACA,QAAIC,QAAJ;;AACA,QAAG,KAAKxC,UAAL,CAAgByC,MAAhB,IAA0B,KAAKpB,KAAlC,EACA;AACI,WAAKrB,UAAL,GAAkB,EAAlB;AACAW,MAAAA,CAAC,GAAG,CAAJ;;AACA,aAAMA,CAAC,GAAG,KAAKU,KAAf,EACA;AACIiB,QAAAA,QAAQ,GAAG,KAAKhB,SAAL,CAAeX,CAAf,CAAX;AACAwB,QAAAA,QAAQ,GAAG,IAAIxC,KAAJ,CAAU2C,QAAQ,CAACnB,CAAnB,EAAsBmB,QAAQ,CAAClB,CAA/B,CAAX;AACAmB,QAAAA,QAAQ,GAAG1C,YAAY,CAACwC,sBAAb,CAAoC,KAAKX,YAAL,CAAkBf,CAAlB,CAApC,CAAX;AACA6B,QAAAA,QAAQ,GAAG,KAAKf,SAAL,CAAed,CAAf,CAAX;AACAwB,QAAAA,QAAQ,CAAChB,CAAT,GAAcgB,QAAQ,CAAChB,CAAT,GAAcoB,QAAQ,CAACpB,CAAT,GAAaqB,QAAzC;AACAL,QAAAA,QAAQ,CAACf,CAAT,GAAce,QAAQ,CAACf,CAAT,GAAcmB,QAAQ,CAACnB,CAAT,GAAaoB,QAAzC;;AACA,aAAKxC,UAAL,CAAgBiB,IAAhB,CAAqBkB,QAArB;;AACAxB,QAAAA,CAAC;AACJ;AACJ;AACJ;;AA/KL;AADad,Y,CAEKwC,sB,GAAqC,CAC/C,IAAIzC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAD+C,EAE/C,IAAIA,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAF+C,EAG/C,IAAIA,QAAJ,CAAa,CAAC,CAAd,EAAiB,CAAjB,EAAoB,CAApB,CAH+C,EAI/C,IAAIA,QAAJ,CAAa,CAAb,EAAgB,CAAC,CAAjB,EAAoB,CAApB,CAJ+C,C;AAF1CC,Y,CASK6C,mB,GAAkC,CAC5C,IAAI9C,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAD4C,EAE5C,IAAIA,QAAJ,CAAa,CAAC,CAAd,EAAiB,CAAjB,EAAoB,CAApB,CAF4C,EAG5C,IAAIA,QAAJ,CAAa,CAAb,EAAgB,CAAC,CAAjB,EAAoB,CAApB,CAH4C,EAI5C,IAAIA,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAJ4C,C","sourcesContent":["import { Point } from '@pixi/math';\r\nimport { IVector3D } from '../../../room/utils/IVector3D';\r\nimport { Vector3d } from '../../../room/utils/Vector3d';\r\n\r\nexport class RoomWallData\r\n{\r\n    public static WALL_DIRECTION_VECTORS: Vector3d[] = [\r\n        new Vector3d(1, 0, 0),\r\n        new Vector3d(0, 1, 0),\r\n        new Vector3d(-1, 0, 0),\r\n        new Vector3d(0, -1, 0)\r\n    ];\r\n\r\n    public static WALL_NORMAL_VECTORS: Vector3d[] = [\r\n        new Vector3d(0, 1, 0),\r\n        new Vector3d(-1, 0, 0),\r\n        new Vector3d(0, -1, 0),\r\n        new Vector3d(1, 0, 0)\r\n    ];\r\n\r\n    private _corners: Point[];\r\n    private _endPoints: Point[];\r\n    private _directions: number[];\r\n    private _lengths: number[];\r\n    private _leftTurns: boolean[];\r\n    private _borders: boolean[];\r\n    private _hideWalls: boolean[];\r\n    private _manuallyLeftCut: boolean[];\r\n    private _manuallyRightCut: boolean[];\r\n    private _addDuplicates: boolean;\r\n    private _count: number;\r\n\r\n    constructor()\r\n    {\r\n        this._corners = [];\r\n        this._endPoints = [];\r\n        this._directions = [];\r\n        this._lengths = [];\r\n        this._leftTurns = [];\r\n        this._borders = [];\r\n        this._hideWalls = [];\r\n        this._manuallyLeftCut = [];\r\n        this._manuallyRightCut = [];\r\n        this._addDuplicates = false;\r\n        this._count = 0;\r\n    }\r\n\r\n    public addWall(k: Point, _arg_2: number, _arg_3: number, _arg_4: boolean, _arg_5: boolean): void\r\n    {\r\n        if(((this._addDuplicates) || (this.checkIsNotDuplicate(k, _arg_2, _arg_3, _arg_4, _arg_5))))\r\n        {\r\n            this._corners.push(k);\r\n            this._directions.push(_arg_2);\r\n            this._lengths.push(_arg_3);\r\n            this._borders.push(_arg_4);\r\n            this._leftTurns.push(_arg_5);\r\n            this._hideWalls.push(false);\r\n            this._manuallyLeftCut.push(false);\r\n            this._manuallyRightCut.push(false);\r\n            this._count++;\r\n        }\r\n    }\r\n\r\n    private checkIsNotDuplicate(k: Point, _arg_2: number, _arg_3: number, _arg_4: boolean, _arg_5: boolean): boolean\r\n    {\r\n        let _local_6 = 0;\r\n\r\n        while(_local_6 < this._count)\r\n        {\r\n            if(((((((this._corners[_local_6].x == k.x) && (this._corners[_local_6].y == k.y)) && (this._directions[_local_6] == _arg_2)) && (this._lengths[_local_6] == _arg_3)) && (this._borders[_local_6] == _arg_4)) && (this._leftTurns[_local_6] == _arg_5)))\r\n            {\r\n                return false;\r\n            }\r\n            _local_6++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public get count(): number\r\n    {\r\n        return this._count;\r\n    }\r\n\r\n    public getCorner(k: number): Point\r\n    {\r\n        return this._corners[k];\r\n    }\r\n\r\n    public getEndPoint(k: number): Point\r\n    {\r\n        this.calculateWallEndPoints();\r\n        return this._endPoints[k];\r\n    }\r\n\r\n    public getLength(k: number): number\r\n    {\r\n        return this._lengths[k];\r\n    }\r\n\r\n    public getDirection(k: number): number\r\n    {\r\n        return this._directions[k];\r\n    }\r\n\r\n    public getBorder(k: number): boolean\r\n    {\r\n        return this._borders[k];\r\n    }\r\n\r\n    public getHideWall(k: number): boolean\r\n    {\r\n        return this._hideWalls[k];\r\n    }\r\n\r\n    public getLeftTurn(k: number): boolean\r\n    {\r\n        return this._leftTurns[k];\r\n    }\r\n\r\n    public getManuallyLeftCut(k: number): boolean\r\n    {\r\n        return this._manuallyLeftCut[k];\r\n    }\r\n\r\n    public getManuallyRightCut(k: number): boolean\r\n    {\r\n        return this._manuallyRightCut[k];\r\n    }\r\n\r\n    public setHideWall(k: number, _arg_2: boolean): void\r\n    {\r\n        this._hideWalls[k] = _arg_2;\r\n    }\r\n\r\n    public setLength(k: number, _arg_2: number): void\r\n    {\r\n        if(_arg_2 < this._lengths[k])\r\n        {\r\n            this._lengths[k] = _arg_2;\r\n            this._manuallyRightCut[k] = true;\r\n        }\r\n    }\r\n\r\n    public moveCorner(k: number, _arg_2: number): void\r\n    {\r\n        let _local_3: IVector3D;\r\n        if(((_arg_2 > 0) && (_arg_2 < this._lengths[k])))\r\n        {\r\n            const corner = this._corners[k];\r\n\r\n            _local_3 = RoomWallData.WALL_DIRECTION_VECTORS[this.getDirection(k)];\r\n            this._corners[k] = new Point((corner.x + (_arg_2 * _local_3.x)), (corner.y + (_arg_2 * _local_3.y)));\r\n            this._lengths[k] = (this._lengths[k] - _arg_2);\r\n            this._manuallyLeftCut[k] = true;\r\n        }\r\n    }\r\n\r\n    private calculateWallEndPoints(): void\r\n    {\r\n        let k: number;\r\n        let _local_2: Point;\r\n        let _local_3: Point;\r\n        let _local_4:IVector3D;\r\n        let _local_5: number;\r\n        if(this._endPoints.length != this.count)\r\n        {\r\n            this._endPoints = [];\r\n            k = 0;\r\n            while(k < this.count)\r\n            {\r\n                _local_2 = this.getCorner(k);\r\n                _local_3 = new Point(_local_2.x, _local_2.y);\r\n                _local_4 = RoomWallData.WALL_DIRECTION_VECTORS[this.getDirection(k)];\r\n                _local_5 = this.getLength(k);\r\n                _local_3.x = (_local_3.x + (_local_4.x * _local_5));\r\n                _local_3.y = (_local_3.y + (_local_4.y * _local_5));\r\n                this._endPoints.push(_local_3);\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}