{"ast":null,"code":"import { BinaryReader } from '../BinaryReader';\nimport { BinaryWriter } from '../BinaryWriter';\nimport { Byte } from '../Byte';\nimport { Short } from '../Short';\nimport { EvaWireDataWrapper } from './EvaWireDataWrapper';\nexport class EvaWireFormat {\n  encode(header, messages) {\n    const writer = new BinaryWriter();\n    writer.writeShort(header);\n\n    for (const value of messages) {\n      let type = typeof value;\n\n      if (type === 'object') {\n        if (value === null) type = 'null';else if (value instanceof Byte) type = 'byte';else if (value instanceof Short) type = 'short';else if (value instanceof ArrayBuffer) type = 'arraybuffer';\n      }\n\n      switch (type) {\n        case 'null':\n          writer.writeShort(0);\n          break;\n\n        case 'byte':\n          writer.writeByte(value.value);\n          break;\n\n        case 'short':\n          writer.writeShort(value.value);\n          break;\n\n        case 'number':\n          writer.writeInt(value);\n          break;\n\n        case 'boolean':\n          writer.writeByte(value ? 1 : 0);\n          break;\n\n        case 'string':\n          if (!value) writer.writeShort(0);else {\n            writer.writeString(value, true);\n          }\n          break;\n\n        case 'arraybuffer':\n          writer.writeBytes(value);\n          break;\n      }\n    }\n\n    const buffer = writer.getBuffer();\n    if (!buffer) return null;\n    return new BinaryWriter().writeInt(buffer.byteLength).writeBytes(buffer);\n  }\n\n  decode(connection) {\n    if (!connection || !connection.dataBuffer || !connection.dataBuffer.byteLength) return null;\n    const wrappers = [];\n\n    while (connection.dataBuffer.byteLength) {\n      if (connection.dataBuffer.byteLength < 4) break;\n      const container = new BinaryReader(connection.dataBuffer);\n      const length = container.readInt();\n      if (length > connection.dataBuffer.byteLength - 4) break;\n      const extracted = container.readBytes(length);\n      wrappers.push(new EvaWireDataWrapper(extracted.readShort(), extracted));\n      connection.dataBuffer = connection.dataBuffer.slice(length + 4);\n    }\n\n    return wrappers;\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/core/communication/codec/evawire/EvaWireFormat.ts"],"names":["BinaryReader","BinaryWriter","Byte","Short","EvaWireDataWrapper","EvaWireFormat","encode","header","messages","writer","writeShort","value","type","ArrayBuffer","writeByte","writeInt","writeString","writeBytes","buffer","getBuffer","byteLength","decode","connection","dataBuffer","wrappers","container","length","readInt","extracted","readBytes","push","readShort","slice"],"mappings":"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","sourcesContent":["import { IConnection } from '../../connections/IConnection';\r\nimport { IMessageDataWrapper } from '../../messages/IMessageDataWrapper';\r\nimport { BinaryReader } from '../BinaryReader';\r\nimport { BinaryWriter } from '../BinaryWriter';\r\nimport { Byte } from '../Byte';\r\nimport { ICodec } from '../ICodec';\r\nimport { Short } from '../Short';\r\nimport { EvaWireDataWrapper } from './EvaWireDataWrapper';\r\n\r\nexport class EvaWireFormat implements ICodec\r\n{\r\n    public encode(header: number, messages: any[]): BinaryWriter\r\n    {\r\n        const writer = new BinaryWriter();\r\n\r\n        writer.writeShort(header);\r\n\r\n        for(const value of messages)\r\n        {\r\n            let type: string = typeof value;\r\n\r\n            if(type === 'object')\r\n            {\r\n                if(value === null) type = 'null';\r\n                else if(value instanceof Byte) type = 'byte';\r\n                else if(value instanceof Short) type = 'short';\r\n                else if(value instanceof ArrayBuffer) type = 'arraybuffer';\r\n            }\r\n\r\n            switch(type)\r\n            {\r\n                case 'null':\r\n                    writer.writeShort(0);\r\n                    break;\r\n                case 'byte':\r\n                    writer.writeByte(value.value);\r\n                    break;\r\n                case 'short':\r\n                    writer.writeShort(value.value);\r\n                    break;\r\n                case 'number':\r\n                    writer.writeInt(value);\r\n                    break;\r\n                case 'boolean':\r\n                    writer.writeByte(value ? 1 : 0);\r\n                    break;\r\n                case 'string':\r\n                    if(!value) writer.writeShort(0);\r\n                    else\r\n                    {\r\n                        writer.writeString(value, true);\r\n                    }\r\n                    break;\r\n                case 'arraybuffer':\r\n                    writer.writeBytes(value);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        const buffer = writer.getBuffer();\r\n\r\n        if(!buffer) return null;\r\n\r\n        return new BinaryWriter().writeInt(buffer.byteLength).writeBytes(buffer);\r\n    }\r\n\r\n    public decode(connection: IConnection): IMessageDataWrapper[]\r\n    {\r\n        if(!connection || !connection.dataBuffer || !connection.dataBuffer.byteLength) return null;\r\n\r\n        const wrappers: IMessageDataWrapper[] = [];\r\n\r\n        while(connection.dataBuffer.byteLength)\r\n        {\r\n            if(connection.dataBuffer.byteLength < 4) break;\r\n\r\n            const container = new BinaryReader(connection.dataBuffer);\r\n            const length = container.readInt();\r\n\r\n            if(length > (connection.dataBuffer.byteLength - 4)) break;\r\n\r\n            const extracted = container.readBytes(length);\r\n\r\n            wrappers.push(new EvaWireDataWrapper(extracted.readShort(), extracted));\r\n\r\n            connection.dataBuffer = connection.dataBuffer.slice(length + 4);\r\n        }\r\n\r\n        return wrappers;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}