{"ast":null,"code":"import { NitroManager } from '../../core/common/NitroManager';\nimport { Nitro } from '../Nitro';\nimport { BadgeBaseAndLevel } from './BadgeBaseAndLevel';\nimport { NitroLocalizationEvent } from './NitroLocalizationEvent';\nexport class NitroLocalizationManager extends NitroManager {\n  constructor() {\n    super();\n    this._definitions = void 0;\n    this._parameters = void 0;\n    this._badgePointLimits = void 0;\n    this._romanNumerals = void 0;\n    this._pendingUrls = void 0;\n    this._definitions = new Map();\n    this._parameters = new Map();\n    this._badgePointLimits = new Map();\n    this._romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX'];\n    this._pendingUrls = [];\n  }\n\n  onInit() {\n    let urls = Nitro.instance.getConfiguration('external.texts.url');\n\n    if (!Array.isArray(urls)) {\n      urls = [Nitro.instance.getConfiguration('external.texts.url')];\n    }\n\n    for (let i = 0; i < urls.length; i++) urls[i] = Nitro.instance.core.configuration.interpolate(urls[i]);\n\n    this._pendingUrls = urls;\n    this.loadNextLocalization();\n  }\n\n  loadNextLocalization() {\n    if (!this._pendingUrls.length) {\n      this.events && this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.LOADED));\n      return;\n    }\n\n    this.loadLocalizationFromURL(this._pendingUrls[0]);\n  }\n\n  loadLocalizationFromURL(url) {\n    fetch(url).then(response => response.json()).then(data => this.onLocalizationLoaded(data, url)).catch(err => this.onLocalizationFailed(err));\n  }\n\n  onLocalizationLoaded(data, url) {\n    if (!data) return;\n    if (!this.parseLocalization(data)) return;\n\n    const index = this._pendingUrls.indexOf(url);\n\n    if (index >= 0) this._pendingUrls.splice(index, 1);\n    this.loadNextLocalization();\n  }\n\n  onLocalizationFailed(error) {\n    this.events && this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.FAILED));\n  }\n\n  parseLocalization(data) {\n    if (!data) return false;\n\n    for (const key in data) this._definitions.set(key, data[key]);\n\n    return true;\n  }\n\n  getBadgePointLimit(badge) {\n    return this._badgePointLimits.get(badge) || -1;\n  }\n\n  setBadgePointLimit(badge, point) {\n    this._badgePointLimits.set(badge, point);\n  }\n\n  getRomanNumeral(number) {\n    return this._romanNumerals[Math.max(0, number - 1)];\n  }\n\n  getPreviousLevelBadgeId(badgeName) {\n    const badge = new BadgeBaseAndLevel(badgeName);\n    badge.level--;\n    return badge.getBadgeId;\n  }\n\n  hasValue(key) {\n    return this._definitions.has(key);\n  }\n\n  getValue(key) {\n    let doParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!key || !key.length) return null;\n    const keys = key.match(/\\$\\{.[^}]*\\}/g);\n\n    if (keys && keys.length) {\n      for (const splitKey of keys) key = key.replace(splitKey, this.getValue(splitKey.slice(2, -1), doParams));\n    }\n\n    let value = this._definitions.get(key) || null;\n\n    if (!value) {\n      value = Nitro.instance.core.configuration.definitions.get(key);\n      if (value) return value;\n    }\n\n    if (value && doParams) {\n      const parameters = this._parameters.get(key);\n\n      if (parameters) {\n        for (const [parameter, replacement] of parameters) {\n          value = value.replace('%' + parameter + '%', replacement);\n        }\n      }\n    }\n\n    return value || key;\n  }\n\n  getValueWithParameter(key, parameter, replacement) {\n    const value = this.getValue(key, false);\n    const replacedValue = value.replace('%' + parameter + '%', replacement);\n\n    if (value.startsWith('%{')) {\n      // This adds support for multi-optioned texts like\n      // catalog.vip.item.header.months=%{NUM_MONTHS|0 months|1 month|%% months}\n      // It only checks for this multi-optioned thext if the value of the key starts with %{\n      // If it does, it will create a RegEx with the provided parameter, eg. NUM_DAYS or NUM_MONTS\n      // Then, based on the provided replacement it searches for the resultgroup based on the replacement.\n      // If the replacement is not either 0, 1 - it will be assumed it will be plural. (eg. Months)\n      const regex = new RegExp('%{' + parameter.toUpperCase() + '\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');\n      const result = value.match(regex);\n      if (!result) return replacedValue;\n      let indexKey = -1;\n      const replacementAsNumber = Number.parseInt(replacement);\n      let replace = false;\n\n      switch (replacementAsNumber) {\n        case 0:\n          indexKey = 1;\n          break;\n\n        case 1:\n          indexKey = 2;\n          break;\n\n        default:\n        case 2:\n          indexKey = 3;\n          replace = true;\n          break;\n      }\n\n      if (indexKey == -1 || typeof result[indexKey] == 'undefined') {\n        return replacedValue;\n      }\n\n      const valueFromResults = result[indexKey];\n\n      if (valueFromResults) {\n        return valueFromResults.replace('%%', replacement);\n      }\n    }\n\n    return replacedValue;\n  }\n\n  getValueWithParameters(key, parameters, replacements) {\n    let value = this.getValue(key, false);\n\n    if (parameters) {\n      for (let i = 0; i < parameters.length; i++) {\n        const parameter = parameters[i];\n        const replacement = replacements[i];\n        value = value.replace('%' + parameter + '%', replacement);\n\n        if (value.startsWith('%{')) {\n          const regex = new RegExp('%{' + parameter.toUpperCase() + '\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');\n          const result = value.match(regex);\n          if (!result) continue;\n          const replacementAsNumber = parseInt(replacement);\n          let indexKey = -1;\n          let replace = false;\n\n          switch (replacementAsNumber) {\n            case 0:\n              indexKey = 1;\n              break;\n\n            case 1:\n              indexKey = 2;\n              break;\n\n            case 2:\n            default:\n              indexKey = 3;\n              replace = true;\n              break;\n          }\n\n          if (indexKey === -1 || typeof result[indexKey] === 'undefined') continue;\n          const valueFromResults = result[indexKey];\n\n          if (valueFromResults) {\n            value = valueFromResults.replace('%%', replacement);\n          }\n        }\n      }\n    }\n\n    return value;\n  }\n\n  setValue(key, value) {\n    this._definitions.set(key, value);\n  }\n\n  registerParameter(key, parameter, value) {\n    if (!key || key.length === 0 || !parameter || parameter.length === 0) return;\n\n    let existing = this._parameters.get(key);\n\n    if (!existing) {\n      existing = new Map();\n\n      this._parameters.set(key, existing);\n    }\n\n    existing.set(parameter, value);\n  }\n\n  getBadgeName(key) {\n    const badge = new BadgeBaseAndLevel(key);\n    const keys = ['badge_name_' + key, 'badge_name_' + badge.base];\n\n    let name = this._Str_2103(this.getExistingKey(keys));\n\n    name = name.replace('%roman%', this.getRomanNumeral(badge.level));\n    return name;\n  }\n\n  getBadgeDesc(key) {\n    const badge = new BadgeBaseAndLevel(key);\n    const keys = ['badge_desc_' + key, 'badge_desc_' + badge.base];\n\n    let desc = this._Str_2103(this.getExistingKey(keys));\n\n    const limit = this.getBadgePointLimit(key);\n    if (limit > -1) desc = desc.replace('%limit%', limit.toString());\n    desc = desc.replace('%roman%', this.getRomanNumeral(badge.level));\n    return desc;\n  }\n\n  getExistingKey(keys) {\n    for (const entry of keys) {\n      const item = this.getValue(entry);\n      if (item != entry) return item;\n    }\n\n    return '';\n  }\n\n  _Str_2103(k) {\n    return k.replace('${', '$').replace('{', '$').replace('}', '$');\n  }\n\n}","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/localization/NitroLocalizationManager.ts"],"names":["NitroManager","Nitro","BadgeBaseAndLevel","NitroLocalizationEvent","NitroLocalizationManager","constructor","_definitions","_parameters","_badgePointLimits","_romanNumerals","_pendingUrls","Map","onInit","urls","instance","getConfiguration","Array","isArray","i","length","core","configuration","interpolate","loadNextLocalization","events","dispatchEvent","LOADED","loadLocalizationFromURL","url","fetch","then","response","json","data","onLocalizationLoaded","catch","err","onLocalizationFailed","parseLocalization","index","indexOf","splice","error","FAILED","key","set","getBadgePointLimit","badge","get","setBadgePointLimit","point","getRomanNumeral","number","Math","max","getPreviousLevelBadgeId","badgeName","level","getBadgeId","hasValue","has","getValue","doParams","keys","match","splitKey","replace","slice","value","definitions","parameters","parameter","replacement","getValueWithParameter","replacedValue","startsWith","regex","RegExp","toUpperCase","result","indexKey","replacementAsNumber","Number","parseInt","valueFromResults","getValueWithParameters","replacements","setValue","registerParameter","existing","getBadgeName","base","name","_Str_2103","getExistingKey","getBadgeDesc","desc","limit","toString","entry","item","k"],"mappings":"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","sourcesContent":["import { NitroManager } from '../../core/common/NitroManager';\r\nimport { Nitro } from '../Nitro';\r\nimport { BadgeBaseAndLevel } from './BadgeBaseAndLevel';\r\nimport { INitroLocalizationManager } from './INitroLocalizationManager';\r\nimport { NitroLocalizationEvent } from './NitroLocalizationEvent';\r\n\r\nexport class NitroLocalizationManager extends NitroManager implements INitroLocalizationManager\r\n{\r\n    private _definitions: Map<string, string>;\r\n    private _parameters: Map<string, Map<string, string>>;\r\n    private _badgePointLimits: Map<string, number>;\r\n    private _romanNumerals: string[];\r\n    private _pendingUrls: string[];\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._definitions = new Map();\r\n        this._parameters = new Map();\r\n        this._badgePointLimits = new Map();\r\n        this._romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI', 'XXVII', 'XXVIII', 'XXIX', 'XXX'];\r\n        this._pendingUrls = [];\r\n    }\r\n\r\n    protected onInit(): void\r\n    {\r\n        let urls: string[] = Nitro.instance.getConfiguration<string[]>('external.texts.url');\r\n\r\n        if(!Array.isArray(urls))\r\n        {\r\n            urls = [ Nitro.instance.getConfiguration<string>('external.texts.url') ];\r\n        }\r\n\r\n        for(let i = 0; i < urls.length; i++) urls[i] = Nitro.instance.core.configuration.interpolate(urls[i]);\r\n\r\n        this._pendingUrls = urls;\r\n\r\n        this.loadNextLocalization();\r\n    }\r\n\r\n    private loadNextLocalization(): void\r\n    {\r\n        if(!this._pendingUrls.length)\r\n        {\r\n            this.events && this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.LOADED));\r\n\r\n            return;\r\n        }\r\n\r\n        this.loadLocalizationFromURL(this._pendingUrls[0]);\r\n    }\r\n\r\n    public loadLocalizationFromURL(url: string): void\r\n    {\r\n        fetch(url)\r\n            .then(response => response.json())\r\n            .then(data => this.onLocalizationLoaded(data, url))\r\n            .catch(err => this.onLocalizationFailed(err));\r\n    }\r\n\r\n    private onLocalizationLoaded(data: { [index: string]: any }, url: string): void\r\n    {\r\n        if(!data) return;\r\n\r\n        if(!this.parseLocalization(data)) return;\r\n\r\n        const index = this._pendingUrls.indexOf(url);\r\n\r\n        if(index >= 0) this._pendingUrls.splice(index, 1);\r\n\r\n        this.loadNextLocalization();\r\n    }\r\n\r\n    private onLocalizationFailed(error: Error): void\r\n    {\r\n        this.events && this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.FAILED));\r\n    }\r\n\r\n    private parseLocalization(data: { [index: string]: any }): boolean\r\n    {\r\n        if(!data) return false;\r\n\r\n        for(const key in data) this._definitions.set(key, data[key]);\r\n\r\n        return true;\r\n    }\r\n\r\n    public getBadgePointLimit(badge: string): number\r\n    {\r\n        return (this._badgePointLimits.get(badge) || -1);\r\n    }\r\n\r\n    public setBadgePointLimit(badge: string, point: number): void\r\n    {\r\n        this._badgePointLimits.set(badge, point);\r\n    }\r\n\r\n    public getRomanNumeral(number: number): string\r\n    {\r\n        return this._romanNumerals[Math.max(0, (number - 1))];\r\n    }\r\n\r\n    public getPreviousLevelBadgeId(badgeName: string): string\r\n    {\r\n        const badge = new BadgeBaseAndLevel(badgeName);\r\n\r\n        badge.level--;\r\n\r\n        return badge.getBadgeId;\r\n    }\r\n\r\n    public hasValue(key: string): boolean\r\n    {\r\n        return this._definitions.has(key);\r\n    }\r\n\r\n    public getValue(key: string, doParams: boolean = true): string\r\n    {\r\n        if(!key || !key.length) return null;\r\n\r\n        const keys = key.match(/\\$\\{.[^}]*\\}/g);\r\n\r\n        if(keys && keys.length)\r\n        {\r\n            for(const splitKey of keys) key = key.replace(splitKey, this.getValue(splitKey.slice(2, -1), doParams));\r\n        }\r\n\r\n        let value = (this._definitions.get(key) || null);\r\n\r\n        if(!value)\r\n        {\r\n            value = (Nitro.instance.core.configuration.definitions.get(key) as any);\r\n\r\n            if(value) return value;\r\n        }\r\n\r\n        if(value && doParams)\r\n        {\r\n            const parameters = this._parameters.get(key);\r\n\r\n            if(parameters)\r\n            {\r\n                for(const [ parameter, replacement ] of parameters)\r\n                {\r\n                    value = value.replace('%' + parameter + '%', replacement);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (value || key);\r\n    }\r\n\r\n    public getValueWithParameter(key: string, parameter: string, replacement: string): string\r\n    {\r\n        const value = this.getValue(key, false);\r\n\r\n        const replacedValue = value.replace('%' + parameter + '%', replacement);\r\n\r\n        if(value.startsWith('%{'))\r\n        {\r\n            // This adds support for multi-optioned texts like\r\n            // catalog.vip.item.header.months=%{NUM_MONTHS|0 months|1 month|%% months}\r\n            // It only checks for this multi-optioned thext if the value of the key starts with %{\r\n\r\n            // If it does, it will create a RegEx with the provided parameter, eg. NUM_DAYS or NUM_MONTS\r\n            // Then, based on the provided replacement it searches for the resultgroup based on the replacement.\r\n            // If the replacement is not either 0, 1 - it will be assumed it will be plural. (eg. Months)\r\n            const regex = new RegExp('%{' + parameter.toUpperCase() + '\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');\r\n            const result = value.match(regex);\r\n\r\n            if(!result) return replacedValue;\r\n\r\n            let indexKey = -1;\r\n            const replacementAsNumber = Number.parseInt(replacement);\r\n            let replace = false;\r\n\r\n            switch(replacementAsNumber)\r\n            {\r\n                case 0:\r\n                    indexKey = 1;\r\n                    break;\r\n                case 1:\r\n                    indexKey = 2;\r\n                    break;\r\n                default:\r\n                case 2:\r\n                    indexKey = 3;\r\n                    replace = true;\r\n                    break;\r\n            }\r\n\r\n\r\n            if(indexKey == -1 || typeof result[indexKey] == 'undefined')\r\n            {\r\n                return replacedValue;\r\n            }\r\n\r\n            const valueFromResults = result[indexKey];\r\n\r\n            if(valueFromResults)\r\n            {\r\n                return valueFromResults.replace('%%', replacement);\r\n            }\r\n        }\r\n\r\n        return replacedValue;\r\n    }\r\n\r\n    public getValueWithParameters(key: string, parameters: string[], replacements: string[]): string\r\n    {\r\n        let value = this.getValue(key, false);\r\n\r\n        if(parameters)\r\n        {\r\n            for(let i = 0; i < parameters.length; i++)\r\n            {\r\n                const parameter = parameters[i];\r\n                const replacement = replacements[i];\r\n\r\n                value = value.replace('%' + parameter + '%', replacement);\r\n\r\n                if(value.startsWith('%{'))\r\n                {\r\n                    const regex = new RegExp('%{' + parameter.toUpperCase() + '\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');\r\n                    const result = value.match(regex);\r\n\r\n                    if(!result) continue;\r\n\r\n                    const replacementAsNumber = parseInt(replacement);\r\n\r\n                    let indexKey = -1;\r\n                    let replace = false;\r\n\r\n                    switch(replacementAsNumber)\r\n                    {\r\n                        case 0:\r\n                            indexKey = 1;\r\n                            break;\r\n                        case 1:\r\n                            indexKey = 2;\r\n                            break;\r\n                        case 2:\r\n                        default:\r\n                            indexKey = 3;\r\n                            replace = true;\r\n                            break;\r\n                    }\r\n\r\n\r\n                    if((indexKey === -1) || (typeof result[indexKey] === 'undefined')) continue;\r\n\r\n                    const valueFromResults = result[indexKey];\r\n\r\n                    if(valueFromResults)\r\n                    {\r\n                        value = valueFromResults.replace('%%', replacement);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    public setValue(key: string, value: string): void\r\n    {\r\n        this._definitions.set(key, value);\r\n    }\r\n\r\n    public registerParameter(key: string, parameter: string, value: string): void\r\n    {\r\n        if(!key || (key.length === 0) || !parameter || (parameter.length === 0)) return;\r\n\r\n        let existing = this._parameters.get(key);\r\n\r\n        if(!existing)\r\n        {\r\n            existing = new Map();\r\n\r\n            this._parameters.set(key, existing);\r\n        }\r\n\r\n        existing.set(parameter, value);\r\n    }\r\n\r\n    public getBadgeName(key: string): string\r\n    {\r\n        const badge = new BadgeBaseAndLevel(key);\r\n        const keys = [ 'badge_name_' + key, 'badge_name_' + badge.base ];\r\n\r\n        let name = this._Str_2103(this.getExistingKey(keys));\r\n\r\n        name = name.replace('%roman%', this.getRomanNumeral(badge.level));\r\n\r\n        return name;\r\n    }\r\n\r\n    public getBadgeDesc(key: string): string\r\n    {\r\n        const badge = new BadgeBaseAndLevel(key);\r\n        const keys = [ 'badge_desc_' + key, 'badge_desc_' + badge.base ];\r\n\r\n        let desc = this._Str_2103(this.getExistingKey(keys));\r\n\r\n        const limit = this.getBadgePointLimit(key);\r\n\r\n        if(limit > -1) desc = desc.replace('%limit%', limit.toString());\r\n\r\n        desc = desc.replace('%roman%', this.getRomanNumeral(badge.level));\r\n\r\n        return desc;\r\n    }\r\n\r\n    private getExistingKey(keys: string[]): string\r\n    {\r\n        for(const entry of keys)\r\n        {\r\n            const item = this.getValue(entry);\r\n            if(item != entry) return item;\r\n        }\r\n\r\n        return '';\r\n    }\r\n\r\n    private _Str_2103(k: string): string\r\n    {\r\n        return k.replace('${', '$')\r\n            .replace('{', '$')\r\n            .replace('}', '$');\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}