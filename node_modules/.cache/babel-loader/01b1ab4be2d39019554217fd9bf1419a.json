{"ast":null,"code":"import { NitroContainer, NitroTexture } from '../../..';\nimport { NitroSprite } from '../../../core/utils/proxy/NitroSprite';\nimport { GroupBadgePartsEvent } from '../../communication/messages/incoming/group/GroupBadgePartsEvent';\nimport { Nitro } from '../../Nitro';\nimport { BadgeImageReadyEvent } from '../events/BadgeImageReadyEvent';\nimport { TextureUtils } from './../../../room/utils/TextureUtils';\nimport { BadgeInfo } from './BadgeInfo';\nimport { GroupBadge } from './GroupBadge';\nimport { GroupBadgePart } from './GroupBadgePart';\nexport class BadgeImageManager {\n  constructor(assetManager, sessionDataManager) {\n    this._assets = void 0;\n    this._sessionDataManager = void 0;\n    this._messages = void 0;\n    this._groupBases = void 0;\n    this._groupSymbols = void 0;\n    this._groupPartColors = void 0;\n    this._requestedBadges = void 0;\n    this._groupBadgesQueue = void 0;\n    this._readyToGenerateGroupBadges = void 0;\n    this._assets = assetManager;\n    this._sessionDataManager = sessionDataManager;\n    this._groupBases = new Map();\n    this._groupSymbols = new Map();\n    this._groupPartColors = new Map();\n    this._requestedBadges = new Map();\n    this._groupBadgesQueue = new Map();\n    this._readyToGenerateGroupBadges = false;\n  }\n\n  init() {\n    if (this._sessionDataManager && this._sessionDataManager.communication) {\n      this._messages = [new GroupBadgePartsEvent(this.onGroupBadgePartsEvent.bind(this))];\n\n      for (const message of this._messages) this._sessionDataManager.communication.registerMessageEvent(message); //this._sessionDataManager.send(new GroupBadgePartsComposer());\n\n    }\n  }\n\n  dispose() {\n    if (this._messages && this._messages.length) {\n      for (const message of this._messages) this._sessionDataManager.communication.removeMessageEvent(message);\n\n      this._messages = null;\n    }\n\n    this._sessionDataManager = null;\n  }\n\n  getBadgeImage(badgeName) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BadgeImageManager.NORMAL_BADGE;\n    let load = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let badge = this.getBadgeTexture(badgeName, type);\n    if (!badge && load) badge = this.getBadgePlaceholder();\n    return badge;\n  }\n\n  getBadgeInfo(k) {\n    const badge = this.getBadgeTexture(k);\n    return badge ? new BadgeInfo(badge, false) : new BadgeInfo(this.getBadgePlaceholder(), true);\n  }\n\n  loadBadgeImage(badgeName) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BadgeImageManager.NORMAL_BADGE;\n    if (this._assets.getTexture(this.getBadgeUrl(badgeName, type))) return badgeName;\n    this.getBadgeTexture(badgeName, type);\n    return null;\n  }\n\n  getBadgeTexture(badgeName) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BadgeImageManager.NORMAL_BADGE;\n    const url = this.getBadgeUrl(badgeName, type);\n    if (!url || !url.length) return null;\n\n    const existing = this._assets.getTexture(url);\n\n    if (existing) return existing.clone();\n\n    if (type === BadgeImageManager.NORMAL_BADGE) {\n      if (this._requestedBadges.get(badgeName)) return null;\n\n      this._requestedBadges.set(badgeName, true);\n\n      this._assets.downloadAsset(url, flag => {\n        if (flag) {\n          this._requestedBadges.delete(badgeName);\n\n          const texture = this._assets.getTexture(url);\n\n          if (texture && this._sessionDataManager) this._sessionDataManager.events.dispatchEvent(new BadgeImageReadyEvent(badgeName, texture.clone()));\n        }\n      });\n    } else if (type === BadgeImageManager.GROUP_BADGE) {\n      if (this._groupBadgesQueue.get(badgeName)) return;\n\n      this._groupBadgesQueue.set(badgeName, true);\n\n      if (this._readyToGenerateGroupBadges) this.loadGroupBadge(badgeName);\n    }\n\n    return null;\n  }\n\n  getBadgePlaceholder() {\n    const url = Nitro.instance.getConfiguration('images.url') + '/loading_icon.png';\n\n    const existing = this._assets.getTexture(url);\n\n    if (!existing) return null;\n    return existing.clone();\n  }\n\n  getBadgeUrl(badge) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BadgeImageManager.NORMAL_BADGE;\n    let url = null;\n\n    switch (type) {\n      case BadgeImageManager.NORMAL_BADGE:\n        url = Nitro.instance.getConfiguration('badge.asset.url').replace('%badgename%', badge);\n        break;\n\n      case BadgeImageManager.GROUP_BADGE:\n        url = badge;\n        break;\n    }\n\n    return url;\n  }\n\n  loadGroupBadge(badgeCode) {\n    const groupBadge = new GroupBadge(badgeCode);\n    const partMatches = [...badgeCode.matchAll(/[b|s][0-9]{5,6}/g)];\n\n    for (const partMatch of partMatches) {\n      const partCode = partMatch[0];\n      const shortMethod = partCode.length === 6;\n      const partType = partCode[0];\n      const partId = parseInt(partCode.slice(1, shortMethod ? 3 : 4));\n      const partColor = parseInt(partCode.slice(shortMethod ? 3 : 4, shortMethod ? 5 : 6));\n      const partPosition = parseInt(partCode.slice(shortMethod ? 5 : 6, shortMethod ? 6 : 7));\n      const part = new GroupBadgePart(partType, partId, partColor, partPosition);\n      groupBadge.parts.push(part);\n    }\n\n    this.renderGroupBadge(groupBadge);\n  }\n\n  renderGroupBadge(groupBadge) {\n    const container = new NitroContainer();\n    const tempSprite = new NitroSprite(NitroTexture.EMPTY);\n    tempSprite.width = GroupBadgePart.IMAGE_WIDTH;\n    tempSprite.height = GroupBadgePart.IMAGE_HEIGHT;\n    container.addChild(tempSprite);\n\n    for (const part of groupBadge.parts) {\n      let isFirst = true;\n      const partNames = part.type === 'b' ? this._groupBases.get(part.key) : this._groupSymbols.get(part.key);\n\n      for (const partName of partNames) {\n        if (!partName || !partName.length) continue;\n\n        const texture = this._assets.getTexture(`badgepart_${partName}`);\n\n        if (!texture) continue;\n        const {\n          x,\n          y\n        } = part.calculatePosition(texture);\n        const sprite = new NitroSprite(texture);\n        sprite.position.set(x, y);\n        if (isFirst) sprite.tint = parseInt(this._groupPartColors.get(part.color), 16);\n        isFirst = false;\n        container.addChild(sprite);\n      }\n    }\n\n    this._requestedBadges.delete(groupBadge.code);\n\n    this._groupBadgesQueue.delete(groupBadge.code);\n\n    const texture = TextureUtils.generateTexture(container);\n\n    this._assets.setTexture(groupBadge.code, texture);\n\n    if (this._sessionDataManager) this._sessionDataManager.events.dispatchEvent(new BadgeImageReadyEvent(groupBadge.code, texture));\n  }\n\n  onGroupBadgePartsEvent(event) {\n    if (!event) return;\n    const data = event.getParser();\n    if (!data) return;\n    data.bases.forEach((names, id) => this._groupBases.set(id, names.map(val => val.replace('.png', '').replace('.gif', ''))));\n    data.symbols.forEach((names, id) => this._groupSymbols.set(id, names.map(val => val.replace('.png', '').replace('.gif', ''))));\n    this._groupPartColors = data.partColors;\n    this._readyToGenerateGroupBadges = true;\n\n    for (const badgeCode of this._groupBadgesQueue.keys()) this.loadGroupBadge(badgeCode);\n  }\n\n  get disposed() {\n    return !!this._sessionDataManager;\n  }\n\n}\nBadgeImageManager.GROUP_BADGE = 'group_badge';\nBadgeImageManager.NORMAL_BADGE = 'normal_badge';","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/session/badge/BadgeImageManager.ts"],"names":["NitroContainer","NitroTexture","NitroSprite","GroupBadgePartsEvent","Nitro","BadgeImageReadyEvent","TextureUtils","BadgeInfo","GroupBadge","GroupBadgePart","BadgeImageManager","constructor","assetManager","sessionDataManager","_assets","_sessionDataManager","_messages","_groupBases","_groupSymbols","_groupPartColors","_requestedBadges","_groupBadgesQueue","_readyToGenerateGroupBadges","Map","init","communication","onGroupBadgePartsEvent","bind","message","registerMessageEvent","dispose","length","removeMessageEvent","getBadgeImage","badgeName","type","NORMAL_BADGE","load","badge","getBadgeTexture","getBadgePlaceholder","getBadgeInfo","k","loadBadgeImage","getTexture","getBadgeUrl","url","existing","clone","get","set","downloadAsset","flag","delete","texture","events","dispatchEvent","GROUP_BADGE","loadGroupBadge","instance","getConfiguration","replace","badgeCode","groupBadge","partMatches","matchAll","partMatch","partCode","shortMethod","partType","partId","parseInt","slice","partColor","partPosition","part","parts","push","renderGroupBadge","container","tempSprite","EMPTY","width","IMAGE_WIDTH","height","IMAGE_HEIGHT","addChild","isFirst","partNames","key","partName","x","y","calculatePosition","sprite","position","tint","color","code","generateTexture","setTexture","event","data","getParser","bases","forEach","names","id","map","val","symbols","partColors","keys","disposed"],"mappings":"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","sourcesContent":["import { Resource, Texture } from '@pixi/core';\r\nimport { NitroContainer, NitroTexture } from '../../..';\r\nimport { IAssetManager } from '../../../core/asset/IAssetManager';\r\nimport { IMessageEvent } from '../../../core/communication/messages/IMessageEvent';\r\nimport { NitroSprite } from '../../../core/utils/proxy/NitroSprite';\r\nimport { GroupBadgePartsEvent } from '../../communication/messages/incoming/group/GroupBadgePartsEvent';\r\nimport { Nitro } from '../../Nitro';\r\nimport { BadgeImageReadyEvent } from '../events/BadgeImageReadyEvent';\r\nimport { IDisposable } from './../../../core/common/disposable/IDisposable';\r\nimport { TextureUtils } from './../../../room/utils/TextureUtils';\r\nimport { SessionDataManager } from './../SessionDataManager';\r\nimport { BadgeInfo } from './BadgeInfo';\r\nimport { GroupBadge } from './GroupBadge';\r\nimport { GroupBadgePart } from './GroupBadgePart';\r\n\r\nexport class BadgeImageManager implements IDisposable\r\n{\r\n    public static GROUP_BADGE: string = 'group_badge';\r\n    public static NORMAL_BADGE: string = 'normal_badge';\r\n\r\n    private _assets: IAssetManager;\r\n    private _sessionDataManager: SessionDataManager;\r\n    private _messages: IMessageEvent[];\r\n\r\n    private _groupBases: Map<number, string[]>;\r\n    private _groupSymbols: Map<number, string[]>;\r\n    private _groupPartColors: Map<number, string>;\r\n\r\n    private _requestedBadges: Map<string, boolean>;\r\n    private _groupBadgesQueue: Map<string, boolean>;\r\n\r\n    private _readyToGenerateGroupBadges: boolean;\r\n\r\n    constructor(assetManager: IAssetManager, sessionDataManager: SessionDataManager)\r\n    {\r\n        this._assets = assetManager;\r\n        this._sessionDataManager = sessionDataManager;\r\n\r\n        this._groupBases = new Map();\r\n        this._groupSymbols = new Map();\r\n        this._groupPartColors = new Map();\r\n\r\n        this._requestedBadges = new Map();\r\n        this._groupBadgesQueue = new Map();\r\n\r\n        this._readyToGenerateGroupBadges = false;\r\n    }\r\n\r\n    public init(): void\r\n    {\r\n        if(this._sessionDataManager && this._sessionDataManager.communication)\r\n        {\r\n            this._messages = [\r\n                new GroupBadgePartsEvent(this.onGroupBadgePartsEvent.bind(this))\r\n            ];\r\n\r\n            for(const message of this._messages) this._sessionDataManager.communication.registerMessageEvent(message);\r\n\r\n            //this._sessionDataManager.send(new GroupBadgePartsComposer());\r\n        }\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._messages && this._messages.length)\r\n        {\r\n            for(const message of this._messages) this._sessionDataManager.communication.removeMessageEvent(message);\r\n\r\n            this._messages = null;\r\n        }\r\n\r\n        this._sessionDataManager = null;\r\n    }\r\n\r\n    public getBadgeImage(badgeName: string, type: string = BadgeImageManager.NORMAL_BADGE, load: boolean = true): Texture<Resource>\r\n    {\r\n        let badge = this.getBadgeTexture(badgeName, type);\r\n\r\n        if(!badge && load) badge = this.getBadgePlaceholder();\r\n\r\n        return badge;\r\n    }\r\n\r\n    public getBadgeInfo(k: string): BadgeInfo\r\n    {\r\n        const badge = this.getBadgeTexture(k);\r\n\r\n        return (badge) ? new BadgeInfo(badge, false) : new BadgeInfo(this.getBadgePlaceholder(), true);\r\n    }\r\n\r\n    public loadBadgeImage(badgeName: string, type: string = BadgeImageManager.NORMAL_BADGE): string\r\n    {\r\n        if(this._assets.getTexture(this.getBadgeUrl(badgeName, type))) return badgeName;\r\n\r\n        this.getBadgeTexture(badgeName, type);\r\n\r\n        return null;\r\n    }\r\n\r\n    private getBadgeTexture(badgeName: string, type: string = BadgeImageManager.NORMAL_BADGE): Texture<Resource>\r\n    {\r\n        const url = this.getBadgeUrl(badgeName, type);\r\n\r\n        if(!url || !url.length) return null;\r\n\r\n        const existing = this._assets.getTexture(url);\r\n\r\n        if(existing) return existing.clone();\r\n\r\n        if(type === BadgeImageManager.NORMAL_BADGE)\r\n        {\r\n            if(this._requestedBadges.get(badgeName)) return null;\r\n\r\n            this._requestedBadges.set(badgeName, true);\r\n\r\n            this._assets.downloadAsset(url, (flag: boolean) =>\r\n            {\r\n                if(flag)\r\n                {\r\n                    this._requestedBadges.delete(badgeName);\r\n\r\n                    const texture = this._assets.getTexture(url);\r\n\r\n                    if(texture && this._sessionDataManager) this._sessionDataManager.events.dispatchEvent(new BadgeImageReadyEvent(badgeName, texture.clone()));\r\n                }\r\n            });\r\n        }\r\n\r\n        else if(type === BadgeImageManager.GROUP_BADGE)\r\n        {\r\n            if(this._groupBadgesQueue.get(badgeName)) return;\r\n\r\n            this._groupBadgesQueue.set(badgeName, true);\r\n\r\n            if(this._readyToGenerateGroupBadges) this.loadGroupBadge(badgeName);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private getBadgePlaceholder(): Texture<Resource>\r\n    {\r\n        const url = (Nitro.instance.getConfiguration<string>('images.url') + '/loading_icon.png');\r\n        const existing = this._assets.getTexture(url);\r\n\r\n        if(!existing) return null;\r\n\r\n        return existing.clone();\r\n    }\r\n\r\n    public getBadgeUrl(badge: string, type: string = BadgeImageManager.NORMAL_BADGE): string\r\n    {\r\n        let url = null;\r\n\r\n        switch(type)\r\n        {\r\n            case BadgeImageManager.NORMAL_BADGE:\r\n                url = (Nitro.instance.getConfiguration<string>('badge.asset.url')).replace('%badgename%', badge);\r\n                break;\r\n            case BadgeImageManager.GROUP_BADGE:\r\n                url = badge;\r\n                break;\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    private loadGroupBadge(badgeCode: string): void\r\n    {\r\n        const groupBadge = new GroupBadge(badgeCode);\r\n        const partMatches = [...badgeCode.matchAll(/[b|s][0-9]{5,6}/g)];\r\n\r\n        for(const partMatch of partMatches)\r\n        {\r\n            const partCode = partMatch[0];\r\n            const shortMethod = (partCode.length === 6);\r\n            const partType = partCode[0];\r\n            const partId = parseInt(partCode.slice(1, shortMethod ? 3 : 4));\r\n            const partColor = parseInt(partCode.slice(shortMethod ? 3 : 4, shortMethod ? 5 : 6));\r\n            const partPosition = parseInt(partCode.slice(shortMethod ? 5 : 6, shortMethod ? 6 : 7));\r\n            const part = new GroupBadgePart(partType, partId, partColor, partPosition);\r\n\r\n            groupBadge.parts.push(part);\r\n        }\r\n\r\n        this.renderGroupBadge(groupBadge);\r\n    }\r\n\r\n    private renderGroupBadge(groupBadge: GroupBadge): void\r\n    {\r\n        const container = new NitroContainer();\r\n        const tempSprite = new NitroSprite(NitroTexture.EMPTY);\r\n\r\n        tempSprite.width = GroupBadgePart.IMAGE_WIDTH;\r\n        tempSprite.height = GroupBadgePart.IMAGE_HEIGHT;\r\n\r\n        container.addChild(tempSprite);\r\n\r\n        for(const part of groupBadge.parts)\r\n        {\r\n            let isFirst = true;\r\n\r\n            const partNames = ((part.type === 'b') ? this._groupBases.get(part.key) : this._groupSymbols.get(part.key));\r\n\r\n            for(const partName of partNames)\r\n            {\r\n                if(!partName || !partName.length) continue;\r\n\r\n                const texture = this._assets.getTexture(`badgepart_${ partName }`);\r\n\r\n                if(!texture) continue;\r\n\r\n                const { x, y } = part.calculatePosition(texture);\r\n                const sprite = new NitroSprite(texture);\r\n\r\n                sprite.position.set(x, y);\r\n\r\n                if(isFirst) sprite.tint = parseInt(this._groupPartColors.get(part.color), 16);\r\n\r\n                isFirst = false;\r\n\r\n                container.addChild(sprite);\r\n            }\r\n        }\r\n\r\n        this._requestedBadges.delete(groupBadge.code);\r\n        this._groupBadgesQueue.delete(groupBadge.code);\r\n\r\n        const texture = TextureUtils.generateTexture(container);\r\n        this._assets.setTexture(groupBadge.code, texture);\r\n\r\n        if(this._sessionDataManager) this._sessionDataManager.events.dispatchEvent(new BadgeImageReadyEvent(groupBadge.code, texture));\r\n    }\r\n\r\n    private onGroupBadgePartsEvent(event: GroupBadgePartsEvent): void\r\n    {\r\n        if(!event) return;\r\n\r\n        const data = event.getParser();\r\n\r\n        if(!data) return;\r\n\r\n        data.bases.forEach((names, id) => this._groupBases.set(id, names.map( val => val.replace('.png', '').replace('.gif', ''))));\r\n\r\n        data.symbols.forEach( (names, id) => this._groupSymbols.set(id, names.map( val => val.replace('.png', '').replace('.gif', ''))));\r\n\r\n        this._groupPartColors = data.partColors;\r\n        this._readyToGenerateGroupBadges = true;\r\n\r\n        for(const badgeCode of this._groupBadgesQueue.keys()) this.loadGroupBadge(badgeCode);\r\n    }\r\n\r\n    public get disposed(): boolean\r\n    {\r\n        return !!this._sessionDataManager;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}