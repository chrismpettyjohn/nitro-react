{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { AchievementEvent, AchievementsEvent, AchievementsScoreEvent, RequestAchievementsMessageComposer } from '@nitrots/nitro-renderer';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { AchievementCategory, CloneObject, GetAchievementCategoryTotalUnseen, GetAchievementIsIgnored, SendMessageComposer } from '../../api';\nimport { UseMessageEventHook } from '../messages';\n\nconst useAchievementsState = () => {\n  _s();\n\n  const [needsUpdate, setNeedsUpdate] = useState(true);\n  const [achievementCategories, setAchievementCategories] = useState([]);\n  const [selectedCategoryCode, setSelectedCategoryCode] = useState(null);\n  const [selectedAchievementId, setSelectedAchievementId] = useState(-1);\n  const [achievementScore, setAchievementScore] = useState(0);\n  const getTotalUnseen = useMemo(() => {\n    let unseen = 0;\n    achievementCategories.forEach(category => unseen += GetAchievementCategoryTotalUnseen(category));\n    return unseen;\n  }, [achievementCategories]);\n  const getProgress = useMemo(() => {\n    let progress = 0;\n    achievementCategories.forEach(category => progress += category.getProgress());\n    return progress;\n  }, [achievementCategories]);\n  const getMaxProgress = useMemo(() => {\n    let progress = 0;\n    achievementCategories.forEach(category => progress += category.getMaxProgress());\n    return progress;\n  }, [achievementCategories]);\n  const scaledProgressPercent = useMemo(() => {\n    return ~~((getProgress - 0) * (100 - 0) / (getMaxProgress - 0) + 0);\n  }, [getProgress, getMaxProgress]);\n  const setAchievementSeen = useCallback((categoryCode, achievementId) => {\n    setAchievementCategories(prevValue => {\n      const newValue = [...prevValue];\n\n      for (const category of newValue) {\n        if (category.code !== categoryCode) continue;\n\n        for (const achievement of category.achievements) {\n          if (achievement.achievementId !== achievementId) continue;\n          achievement.unseen = 0;\n        }\n      }\n\n      return newValue;\n    });\n  }, []);\n  const onAchievementEvent = useCallback(event => {\n    const parser = event.getParser();\n    const achievement = parser.achievement;\n    setAchievementCategories(prevValue => {\n      const newValue = [...prevValue];\n      const categoryIndex = newValue.findIndex(existing => existing.code === achievement.category);\n\n      if (categoryIndex === -1) {\n        const category = new AchievementCategory(achievement.category);\n        category.achievements.push(achievement);\n        newValue.push(category);\n      } else {\n        const category = CloneObject(newValue[categoryIndex]);\n        const newAchievements = [...category.achievements];\n        const achievementIndex = newAchievements.findIndex(existing => existing.achievementId === achievement.achievementId);\n        let previousAchievement = null;\n\n        if (achievementIndex === -1) {\n          newAchievements.push(achievement);\n        } else {\n          previousAchievement = newAchievements[achievementIndex];\n          newAchievements[achievementIndex] = achievement;\n        }\n\n        if (!GetAchievementIsIgnored(achievement)) {\n          achievement.unseen++;\n          if (previousAchievement) achievement.unseen += previousAchievement.unseen;\n        }\n\n        category.achievements = newAchievements;\n        newValue[categoryIndex] = category;\n      }\n\n      return newValue;\n    });\n  }, []);\n  UseMessageEventHook(AchievementEvent, onAchievementEvent);\n  const onAchievementsEvent = useCallback(event => {\n    const parser = event.getParser();\n    const categories = [];\n\n    for (const achievement of parser.achievements) {\n      const categoryName = achievement.category;\n      let existing = categories.find(category => category.code === categoryName);\n\n      if (!existing) {\n        existing = new AchievementCategory(categoryName);\n        categories.push(existing);\n      }\n\n      existing.achievements.push(achievement);\n    }\n\n    setAchievementCategories(categories);\n  }, []);\n  UseMessageEventHook(AchievementsEvent, onAchievementsEvent);\n  const onAchievementsScoreEvent = useCallback(event => {\n    const parser = event.getParser();\n    setAchievementScore(parser.score);\n  }, []);\n  UseMessageEventHook(AchievementsScoreEvent, onAchievementsScoreEvent);\n  useEffect(() => {\n    if (!needsUpdate) return;\n    SendMessageComposer(new RequestAchievementsMessageComposer());\n    setNeedsUpdate(false);\n  }, [needsUpdate]);\n  return {\n    achievementCategories,\n    selectedCategoryCode,\n    setSelectedCategoryCode,\n    selectedAchievementId,\n    setSelectedAchievementId,\n    achievementScore,\n    getTotalUnseen,\n    getProgress,\n    getMaxProgress,\n    scaledProgressPercent,\n    setAchievementSeen\n  };\n};\n\n_s(useAchievementsState, \"GfhMZlqARv2/+k2a8VqY0LwrDbs=\");\n\nexport const useAchievements = useAchievementsState;","map":{"version":3,"sources":["/var/www/game.bobba.ca/src/hooks/achievements/useAchievements.ts"],"names":["AchievementEvent","AchievementsEvent","AchievementsScoreEvent","RequestAchievementsMessageComposer","useCallback","useEffect","useMemo","useState","AchievementCategory","CloneObject","GetAchievementCategoryTotalUnseen","GetAchievementIsIgnored","SendMessageComposer","UseMessageEventHook","useAchievementsState","needsUpdate","setNeedsUpdate","achievementCategories","setAchievementCategories","selectedCategoryCode","setSelectedCategoryCode","selectedAchievementId","setSelectedAchievementId","achievementScore","setAchievementScore","getTotalUnseen","unseen","forEach","category","getProgress","progress","getMaxProgress","scaledProgressPercent","setAchievementSeen","categoryCode","achievementId","prevValue","newValue","code","achievement","achievements","onAchievementEvent","event","parser","getParser","categoryIndex","findIndex","existing","push","newAchievements","achievementIndex","previousAchievement","onAchievementsEvent","categories","categoryName","find","onAchievementsScoreEvent","score","useAchievements"],"mappings":"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","sourcesContent":["import { AchievementData, AchievementEvent, AchievementsEvent, AchievementsScoreEvent, RequestAchievementsMessageComposer } from '@nitrots/nitro-renderer';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { AchievementCategory, CloneObject, GetAchievementCategoryTotalUnseen, GetAchievementIsIgnored, SendMessageComposer } from '../../api';\nimport { UseMessageEventHook } from '../messages';\n\nconst useAchievementsState = () =>\n{\n    const [ needsUpdate, setNeedsUpdate ] = useState<boolean>(true);\n    const [ achievementCategories, setAchievementCategories ] = useState<AchievementCategory[]>([]);\n    const [ selectedCategoryCode, setSelectedCategoryCode ] = useState<string>(null);\n    const [ selectedAchievementId, setSelectedAchievementId ] = useState<number>(-1);\n    const [ achievementScore, setAchievementScore ] = useState<number>(0);\n\n    const getTotalUnseen = useMemo(() =>\n    {\n        let unseen = 0;\n\n        achievementCategories.forEach(category => unseen += GetAchievementCategoryTotalUnseen(category));\n\n        return unseen;\n    }, [ achievementCategories ]);\n\n    const getProgress = useMemo(() =>\n    {\n        let progress = 0;\n\n        achievementCategories.forEach(category => (progress += category.getProgress()));\n\n        return progress;\n    }, [ achievementCategories ]);\n\n    const getMaxProgress = useMemo(() =>\n    {\n        let progress = 0;\n\n        achievementCategories.forEach(category => (progress += category.getMaxProgress()));\n\n        return progress;\n    }, [ achievementCategories ]);\n\n    const scaledProgressPercent = useMemo(() =>\n    {\n        return ~~((((getProgress - 0) * (100 - 0)) / (getMaxProgress - 0)) + 0);\n    }, [ getProgress, getMaxProgress ]);\n\n    const setAchievementSeen = useCallback((categoryCode: string, achievementId: number) =>\n    {\n        setAchievementCategories(prevValue =>\n        {\n            const newValue = [ ...prevValue ];\n\n            for(const category of newValue)\n            {\n                if(category.code !== categoryCode) continue;\n\n                for(const achievement of category.achievements)\n                {\n                    if(achievement.achievementId !== achievementId) continue;\n\n                    achievement.unseen = 0;\n                }\n            }\n\n            return newValue;\n        });\n    }, []);\n\n    const onAchievementEvent = useCallback((event: AchievementEvent) =>\n    {\n        const parser = event.getParser();\n        const achievement = parser.achievement;\n\n        setAchievementCategories(prevValue =>\n        {\n            const newValue = [ ...prevValue ];\n            const categoryIndex = newValue.findIndex(existing => (existing.code === achievement.category));\n\n            if(categoryIndex === -1)\n            {\n                const category = new AchievementCategory(achievement.category);\n\n                category.achievements.push(achievement);\n\n                newValue.push(category);\n            }\n            else\n            {\n                const category = CloneObject(newValue[categoryIndex]);\n                const newAchievements = [ ...category.achievements ];\n                const achievementIndex = newAchievements.findIndex(existing => (existing.achievementId === achievement.achievementId));\n                let previousAchievement: AchievementData = null;\n\n                if(achievementIndex === -1)\n                {\n                    newAchievements.push(achievement);\n                }\n                else\n                {\n                    previousAchievement = newAchievements[achievementIndex];\n\n                    newAchievements[achievementIndex] = achievement;\n                }\n\n                if(!GetAchievementIsIgnored(achievement))\n                {\n                    achievement.unseen++;\n\n                    if(previousAchievement) achievement.unseen += previousAchievement.unseen;\n                }\n\n                category.achievements = newAchievements;\n\n                newValue[categoryIndex] = category;\n            }\n\n            return newValue;\n        });\n    }, []);\n\n    UseMessageEventHook(AchievementEvent, onAchievementEvent);\n\n    const onAchievementsEvent = useCallback((event: AchievementsEvent) =>\n    {\n        const parser = event.getParser();\n        const categories: AchievementCategory[] = [];\n        \n        for(const achievement of parser.achievements)\n        {\n            const categoryName = achievement.category;\n\n            let existing = categories.find(category => (category.code === categoryName));\n\n            if(!existing)\n            {\n                existing = new AchievementCategory(categoryName);\n\n                categories.push(existing);\n            }\n\n            existing.achievements.push(achievement);\n        }\n\n        setAchievementCategories(categories);\n    }, []);\n\n    UseMessageEventHook(AchievementsEvent, onAchievementsEvent);\n\n    const onAchievementsScoreEvent = useCallback((event: AchievementsScoreEvent) =>\n    {\n        const parser = event.getParser();\n\n        setAchievementScore(parser.score);\n    }, []);\n\n    UseMessageEventHook(AchievementsScoreEvent, onAchievementsScoreEvent);\n\n    useEffect(() =>\n    {\n        if(!needsUpdate) return;\n\n        SendMessageComposer(new RequestAchievementsMessageComposer());\n\n        setNeedsUpdate(false);\n    }, [ needsUpdate ]);\n\n    return { achievementCategories, selectedCategoryCode, setSelectedCategoryCode, selectedAchievementId, setSelectedAchievementId, achievementScore, getTotalUnseen, getProgress, getMaxProgress, scaledProgressPercent, setAchievementSeen };\n}\n\nexport const useAchievements = useAchievementsState;\n"]},"metadata":{},"sourceType":"module"}