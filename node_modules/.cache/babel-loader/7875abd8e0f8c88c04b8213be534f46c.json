{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { UnseenItemsEvent, UnseenResetCategoryComposer, UnseenResetItemsComposer } from '@nitrots/nitro-renderer';\nimport { useCallback, useMemo, useState } from 'react';\nimport { useBetween } from 'use-between';\nimport { UseMessageEventHook } from '..';\nimport { SendMessageComposer } from '../../api';\n\nconst sendResetCategoryMessage = category => SendMessageComposer(new UnseenResetCategoryComposer(category));\n\nconst sendResetItemsMessage = (category, itemIds) => SendMessageComposer(new UnseenResetItemsComposer(category, ...itemIds));\n\nconst useInventoryUnseenTrackerState = () => {\n  _s();\n\n  const [unseenItems, setUnseenItems] = useState(new Map());\n  const getCount = useCallback(category => {\n    var _unseenItems$get;\n\n    return ((_unseenItems$get = unseenItems.get(category)) === null || _unseenItems$get === void 0 ? void 0 : _unseenItems$get.length) || 0;\n  }, [unseenItems]);\n  const getFullCount = useMemo(() => {\n    let count = 0;\n\n    for (const key of unseenItems.keys()) count += getCount(key);\n\n    return count;\n  }, [unseenItems, getCount]);\n  const resetCategory = useCallback(category => {\n    let didReset = true;\n    setUnseenItems(prevValue => {\n      if (!prevValue.has(category)) {\n        didReset = false;\n        return prevValue;\n      }\n\n      const newValue = new Map(prevValue);\n      newValue.delete(category);\n      sendResetCategoryMessage(category);\n      return newValue;\n    });\n    return didReset;\n  }, []);\n  const resetItems = useCallback((category, itemIds) => {\n    let didReset = true;\n    setUnseenItems(prevValue => {\n      if (!prevValue.has(category)) {\n        didReset = false;\n        return prevValue;\n      }\n\n      const newValue = new Map(prevValue);\n      const existing = newValue.get(category);\n      if (existing) for (const itemId of itemIds) existing.splice(existing.indexOf(itemId), 1);\n      sendResetItemsMessage(category, itemIds);\n      return newValue;\n    });\n    return didReset;\n  }, []);\n  const isUnseen = useCallback((category, itemId) => {\n    if (!unseenItems.has(category)) return false;\n    const items = unseenItems.get(category);\n    return items.indexOf(itemId) >= 0;\n  }, [unseenItems]);\n  const removeUnseen = useCallback((category, itemId) => {\n    setUnseenItems(prevValue => {\n      if (!prevValue.has(category)) return prevValue;\n      const newValue = new Map(prevValue);\n      const items = newValue.get(category);\n      const index = items.indexOf(itemId);\n      if (index >= 0) items.splice(index, 1);\n      return newValue;\n    });\n  }, []);\n  const onUnseenItemsEvent = useCallback(event => {\n    const parser = event.getParser();\n    setUnseenItems(prevValue => {\n      const newValue = new Map(prevValue);\n\n      for (const category of parser.categories) {\n        let existing = newValue.get(category);\n\n        if (!existing) {\n          existing = [];\n          newValue.set(category, existing);\n        }\n\n        const itemIds = parser.getItemsByCategory(category);\n\n        for (const itemId of itemIds) existing.indexOf(itemId) === -1 && existing.push(itemId);\n      }\n\n      return newValue;\n    });\n  }, []);\n  UseMessageEventHook(UnseenItemsEvent, onUnseenItemsEvent);\n  return {\n    getCount,\n    getFullCount,\n    resetCategory,\n    resetItems,\n    isUnseen,\n    removeUnseen\n  };\n};\n\n_s(useInventoryUnseenTrackerState, \"kIi9jNRnyla13oU+WYkDQ1mDPYM=\");\n\nexport const useInventoryUnseenTracker = () => {\n  _s2();\n\n  return useBetween(useInventoryUnseenTrackerState);\n};\n\n_s2(useInventoryUnseenTracker, \"diiQ3+ccnY3J9PmIrayiMDIOaiY=\", false, function () {\n  return [useBetween];\n});","map":{"version":3,"sources":["/var/www/game.bobba.ca/src/hooks/inventory/useInventoryUnseenTracker.ts"],"names":["UnseenItemsEvent","UnseenResetCategoryComposer","UnseenResetItemsComposer","useCallback","useMemo","useState","useBetween","UseMessageEventHook","SendMessageComposer","sendResetCategoryMessage","category","sendResetItemsMessage","itemIds","useInventoryUnseenTrackerState","unseenItems","setUnseenItems","Map","getCount","get","length","getFullCount","count","key","keys","resetCategory","didReset","prevValue","has","newValue","delete","resetItems","existing","itemId","splice","indexOf","isUnseen","items","removeUnseen","index","onUnseenItemsEvent","event","parser","getParser","categories","set","getItemsByCategory","push","useInventoryUnseenTracker"],"mappings":"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","sourcesContent":["import { UnseenItemsEvent, UnseenResetCategoryComposer, UnseenResetItemsComposer } from '@nitrots/nitro-renderer';\nimport { useCallback, useMemo, useState } from 'react';\nimport { useBetween } from 'use-between';\nimport { UseMessageEventHook } from '..';\nimport { SendMessageComposer } from '../../api';\n\nconst sendResetCategoryMessage = (category: number) => SendMessageComposer(new UnseenResetCategoryComposer(category));\nconst sendResetItemsMessage = (category: number, itemIds: number[]) => SendMessageComposer(new UnseenResetItemsComposer(category, ...itemIds));\n\nconst useInventoryUnseenTrackerState = () =>\n{\n    const [ unseenItems, setUnseenItems ] = useState<Map<number, number[]>>(new Map());\n\n    const getCount = useCallback((category: number) => (unseenItems.get(category)?.length || 0), [ unseenItems ]);\n\n    const getFullCount = useMemo(() =>\n    {\n        let count = 0;\n\n        for(const key of unseenItems.keys()) count += getCount(key);\n\n        return count;\n    }, [ unseenItems, getCount ]);\n\n    const resetCategory = useCallback((category: number) =>\n    {\n        let didReset = true;\n\n        setUnseenItems(prevValue =>\n        {\n            if(!prevValue.has(category))\n            {\n                didReset = false;\n\n                return prevValue;\n            }\n\n            const newValue = new Map(prevValue);\n\n            newValue.delete(category);\n\n            sendResetCategoryMessage(category);\n\n            return newValue;\n        });\n\n        return didReset;\n    }, []);\n\n    const resetItems = useCallback((category: number, itemIds: number[]) =>\n    {\n        let didReset = true;\n\n        setUnseenItems(prevValue =>\n        {\n            if(!prevValue.has(category))\n            {\n                didReset = false;\n\n                return prevValue;\n            }\n\n            const newValue = new Map(prevValue);\n            const existing = newValue.get(category);\n\n            if(existing) for(const itemId of itemIds) existing.splice(existing.indexOf(itemId), 1);\n\n            sendResetItemsMessage(category, itemIds);\n\n            return newValue;\n        });\n\n        return didReset;\n    }, []);\n\n    const isUnseen = useCallback((category: number, itemId: number) =>\n    {\n        if(!unseenItems.has(category)) return false;\n\n        const items = unseenItems.get(category);\n\n        return (items.indexOf(itemId) >= 0);\n    }, [ unseenItems ]);\n\n    const removeUnseen = useCallback((category: number, itemId: number) =>\n    {\n        setUnseenItems(prevValue =>\n        {\n            if(!prevValue.has(category)) return prevValue;\n\n            const newValue = new Map(prevValue);\n            const items = newValue.get(category);\n            const index = items.indexOf(itemId);\n\n            if(index >= 0) items.splice(index, 1);\n\n            return newValue;\n        });\n    }, []);\n\n    const onUnseenItemsEvent = useCallback((event: UnseenItemsEvent) =>\n    {\n        const parser = event.getParser();\n\n        setUnseenItems(prevValue =>\n        {\n            const newValue = new Map(prevValue);\n\n            for(const category of parser.categories)\n            {\n                let existing = newValue.get(category);\n\n                if(!existing)\n                {\n                    existing = [];\n\n                    newValue.set(category, existing);\n                }\n\n                const itemIds = parser.getItemsByCategory(category);\n\n                for(const itemId of itemIds) ((existing.indexOf(itemId) === -1) && existing.push(itemId));\n            }\n\n            return newValue;\n        });\n    }, []);\n\n    UseMessageEventHook(UnseenItemsEvent, onUnseenItemsEvent);\n\n    return { getCount, getFullCount, resetCategory, resetItems, isUnseen, removeUnseen };\n}\n\nexport const useInventoryUnseenTracker = () => useBetween(useInventoryUnseenTrackerState);\n"]},"metadata":{},"sourceType":"module"}