{"ast":null,"code":"import { AnimationLayerData } from './AnimationLayerData';\nimport { DirectionalOffsetData } from './DirectionalOffsetData';\nexport class AnimationData {\n  constructor() {\n    this._layers = void 0;\n    this._frameCount = void 0;\n    this._randomStart = void 0;\n    this._immediateChanges = void 0;\n    this._layers = new Map();\n    this._frameCount = -1;\n    this._randomStart = false;\n    this._immediateChanges = null;\n  }\n\n  static getTransitionToAnimationId(animationId) {\n    return AnimationData.TRANSITION_TO_ANIMATION_OFFSET + animationId;\n  }\n\n  static getTransitionFromAnimationId(animationId) {\n    return AnimationData.TRANSITION_FROM_ANIMATION_OFFSET + animationId;\n  }\n\n  static isTransitionToAnimation(animationId) {\n    return animationId >= AnimationData.TRANSITION_TO_ANIMATION_OFFSET && animationId < AnimationData.TRANSITION_FROM_ANIMATION_OFFSET;\n  }\n\n  static isTransitionFromAnimation(animationId) {\n    return animationId >= AnimationData.TRANSITION_FROM_ANIMATION_OFFSET;\n  }\n\n  dispose() {\n    for (const layer of this._layers.values()) {\n      if (!layer) continue;\n      layer.dispose();\n    }\n\n    this._layers.clear();\n\n    this._immediateChanges = null;\n  }\n\n  setImmediateChanges(k) {\n    this._immediateChanges = k;\n  }\n\n  isImmediateChange(k) {\n    if (!this._immediateChanges || this._immediateChanges.indexOf(k) === -1) return false;\n    return true;\n  }\n\n  getStartFrame(direction) {\n    if (!this._randomStart) return 0;\n    return Math.random() * this._frameCount;\n  }\n\n  initialize(k) {\n    if (k.randomStart) this._randomStart = true;\n\n    if (k.layers) {\n      for (const key in k.layers) {\n        const layer = k.layers[key];\n        if (!layer) return false;\n        const animationId = parseInt(key);\n        const loopCount = layer.loopCount !== undefined ? layer.loopCount : 1;\n        const frameRepeat = layer.frameRepeat !== undefined ? layer.frameRepeat : 1;\n        const isRandom = layer.random !== undefined && layer.random !== 0 ? true : false;\n        if (!this.addLayer(animationId, loopCount, frameRepeat, isRandom, layer)) return false;\n      }\n    }\n\n    return true;\n  }\n\n  addLayer(animationId, loopCount, frameRepeat, isRandom, layer) {\n    const layerData = new AnimationLayerData(loopCount, frameRepeat, isRandom);\n\n    if (layer.frameSequences) {\n      for (const key in layer.frameSequences) {\n        const animationSequence = layer.frameSequences[key];\n        if (!animationSequence) continue;\n        const loopCount = animationSequence.loopCount !== undefined ? animationSequence.loopCount : 1;\n        const isSequenceRandom = animationSequence.random !== undefined && animationSequence.random !== 0 ? true : false;\n        const frame = layerData.addFrameSequence(loopCount, isSequenceRandom);\n\n        if (animationSequence.frames) {\n          for (const key in animationSequence.frames) {\n            const animationFrame = animationSequence.frames[key];\n\n            if (!animationFrame) {\n              layerData.dispose();\n              return false;\n            }\n\n            frame.addFrame(animationFrame.id, animationFrame.x || 0, animationFrame.y || 0, animationFrame.randomX || 0, animationFrame.randomY || 0, this.readDirectionalOffsets(animationFrame));\n          }\n        }\n\n        frame.initialize();\n      }\n    }\n\n    layerData.calculateLength();\n\n    this._layers.set(animationId, layerData);\n\n    const frameCount = layerData.frameCount;\n    if (frameCount > this._frameCount) this._frameCount = frameCount;\n    return true;\n  }\n\n  readDirectionalOffsets(frame) {\n    let directionalOffset = null;\n\n    if (frame && frame.offsets) {\n      for (const directionId in frame.offsets) {\n        const offset = frame.offsets[directionId];\n        if (!offset) continue;\n        if (!directionalOffset) directionalOffset = new DirectionalOffsetData();\n        directionalOffset.setDirection(offset.direction, offset.x, offset.y);\n      }\n    }\n\n    return directionalOffset;\n  }\n\n  getFrame(direction, layerId, frameCount) {\n    const layer = this._layers.get(layerId);\n\n    if (!layer) return null;\n    return layer.getFrame(direction, frameCount);\n  }\n\n  getFrameFromSequence(direction, layerId, sequenceId, offset, frameCount) {\n    const layer = this._layers.get(layerId);\n\n    if (!layer) return null;\n    return layer.getFrameFromSequence(direction, sequenceId, offset, frameCount);\n  }\n\n}\nAnimationData.TRANSITION_TO_ANIMATION_OFFSET = 1000000;\nAnimationData.TRANSITION_FROM_ANIMATION_OFFSET = 2000000;\nAnimationData.DEFAULT_FRAME_NUMBER = 0;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/data/AnimationData.ts"],"names":["AnimationLayerData","DirectionalOffsetData","AnimationData","constructor","_layers","_frameCount","_randomStart","_immediateChanges","Map","getTransitionToAnimationId","animationId","TRANSITION_TO_ANIMATION_OFFSET","getTransitionFromAnimationId","TRANSITION_FROM_ANIMATION_OFFSET","isTransitionToAnimation","isTransitionFromAnimation","dispose","layer","values","clear","setImmediateChanges","k","isImmediateChange","indexOf","getStartFrame","direction","Math","random","initialize","randomStart","layers","key","parseInt","loopCount","undefined","frameRepeat","isRandom","addLayer","layerData","frameSequences","animationSequence","isSequenceRandom","frame","addFrameSequence","frames","animationFrame","addFrame","id","x","y","randomX","randomY","readDirectionalOffsets","calculateLength","set","frameCount","directionalOffset","offsets","directionId","offset","setDirection","getFrame","layerId","get","getFrameFromSequence","sequenceId","DEFAULT_FRAME_NUMBER"],"mappings":"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","sourcesContent":["import { IAssetVisualAnimation, IAssetVisualAnimationLayer, IAssetVisualAnimationSequenceFrame } from '../../../../../core/asset/interfaces';\r\nimport { AnimationFrame } from './AnimationFrame';\r\nimport { AnimationLayerData } from './AnimationLayerData';\r\nimport { DirectionalOffsetData } from './DirectionalOffsetData';\r\n\r\nexport class AnimationData\r\n{\r\n    private static TRANSITION_TO_ANIMATION_OFFSET: number = 1000000;\r\n    private static TRANSITION_FROM_ANIMATION_OFFSET: number = 2000000;\r\n\r\n    public static DEFAULT_FRAME_NUMBER: number = 0;\r\n\r\n    private _layers: Map<number, AnimationLayerData>;\r\n    private _frameCount: number;\r\n    private _randomStart: boolean;\r\n    private _immediateChanges: number[];\r\n\r\n    constructor()\r\n    {\r\n        this._layers = new Map();\r\n        this._frameCount = -1;\r\n        this._randomStart = false;\r\n        this._immediateChanges = null;\r\n    }\r\n\r\n    public static getTransitionToAnimationId(animationId: number): number\r\n    {\r\n        return AnimationData.TRANSITION_TO_ANIMATION_OFFSET + animationId;\r\n    }\r\n\r\n    public static getTransitionFromAnimationId(animationId: number): number\r\n    {\r\n        return AnimationData.TRANSITION_FROM_ANIMATION_OFFSET + animationId;\r\n    }\r\n\r\n    public static isTransitionToAnimation(animationId: number): boolean\r\n    {\r\n        return (animationId >= AnimationData.TRANSITION_TO_ANIMATION_OFFSET) && (animationId < AnimationData.TRANSITION_FROM_ANIMATION_OFFSET);\r\n    }\r\n\r\n    public static isTransitionFromAnimation(animationId: number): boolean\r\n    {\r\n        return animationId >= AnimationData.TRANSITION_FROM_ANIMATION_OFFSET;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        for(const layer of this._layers.values())\r\n        {\r\n            if(!layer) continue;\r\n\r\n            layer.dispose();\r\n        }\r\n\r\n        this._layers.clear();\r\n\r\n        this._immediateChanges = null;\r\n    }\r\n\r\n    public setImmediateChanges(k: number[]): void\r\n    {\r\n        this._immediateChanges = k;\r\n    }\r\n\r\n    public isImmediateChange(k: number): boolean\r\n    {\r\n        if(!this._immediateChanges || (this._immediateChanges.indexOf(k) === -1)) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    public getStartFrame(direction: number): number\r\n    {\r\n        if(!this._randomStart) return 0;\r\n\r\n        return Math.random() * this._frameCount;\r\n    }\r\n\r\n    public initialize(k: IAssetVisualAnimation): boolean\r\n    {\r\n        if(k.randomStart) this._randomStart = true;\r\n\r\n        if(k.layers)\r\n        {\r\n            for(const key in k.layers)\r\n            {\r\n                const layer = k.layers[key];\r\n\r\n                if(!layer) return false;\r\n\r\n                const animationId = parseInt(key);\r\n\r\n                const loopCount = (layer.loopCount !== undefined) ? layer.loopCount : 1;\r\n                const frameRepeat = (layer.frameRepeat !== undefined) ? layer.frameRepeat : 1;\r\n                const isRandom = ((layer.random !== undefined) && (layer.random !== 0)) ? true : false;\r\n\r\n                if(!this.addLayer(animationId, loopCount, frameRepeat, isRandom, layer)) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private addLayer(animationId: number, loopCount: number, frameRepeat: number, isRandom: boolean, layer: IAssetVisualAnimationLayer): boolean\r\n    {\r\n        const layerData = new AnimationLayerData(loopCount, frameRepeat, isRandom);\r\n\r\n        if(layer.frameSequences)\r\n        {\r\n            for(const key in layer.frameSequences)\r\n            {\r\n                const animationSequence = layer.frameSequences[key];\r\n\r\n                if(!animationSequence) continue;\r\n\r\n                const loopCount = (animationSequence.loopCount !== undefined) ? animationSequence.loopCount : 1;\r\n                const isSequenceRandom = ((animationSequence.random !== undefined) && (animationSequence.random !== 0)) ? true : false;\r\n\r\n                const frame = layerData.addFrameSequence(loopCount, isSequenceRandom);\r\n\r\n                if(animationSequence.frames)\r\n                {\r\n                    for(const key in animationSequence.frames)\r\n                    {\r\n                        const animationFrame = animationSequence.frames[key];\r\n\r\n                        if(!animationFrame)\r\n                        {\r\n                            layerData.dispose();\r\n\r\n                            return false;\r\n                        }\r\n\r\n                        frame.addFrame(animationFrame.id, (animationFrame.x || 0), (animationFrame.y || 0), (animationFrame.randomX || 0), (animationFrame.randomY || 0), this.readDirectionalOffsets(animationFrame));\r\n                    }\r\n                }\r\n\r\n                frame.initialize();\r\n            }\r\n        }\r\n\r\n        layerData.calculateLength();\r\n\r\n        this._layers.set(animationId, layerData);\r\n\r\n        const frameCount: number = layerData.frameCount;\r\n\r\n        if(frameCount > this._frameCount) this._frameCount = frameCount;\r\n\r\n        return true;\r\n    }\r\n\r\n    private readDirectionalOffsets(frame: IAssetVisualAnimationSequenceFrame): DirectionalOffsetData\r\n    {\r\n        let directionalOffset: DirectionalOffsetData = null;\r\n\r\n        if(frame && frame.offsets)\r\n        {\r\n            for(const directionId in frame.offsets)\r\n            {\r\n                const offset = frame.offsets[directionId];\r\n\r\n                if(!offset) continue;\r\n\r\n                if(!directionalOffset) directionalOffset = new DirectionalOffsetData();\r\n\r\n                directionalOffset.setDirection(offset.direction, offset.x, offset.y);\r\n            }\r\n        }\r\n\r\n        return directionalOffset;\r\n    }\r\n\r\n    public getFrame(direction: number, layerId: number, frameCount: number): AnimationFrame\r\n    {\r\n        const layer = this._layers.get(layerId);\r\n\r\n        if(!layer) return null;\r\n\r\n        return layer.getFrame(direction, frameCount);\r\n    }\r\n\r\n    public getFrameFromSequence(direction: number, layerId: number, sequenceId: number, offset: number, frameCount: number): AnimationFrame\r\n    {\r\n        const layer = this._layers.get(layerId);\r\n\r\n        if(!layer) return null;\r\n\r\n        return layer.getFrameFromSequence(direction, sequenceId, offset, frameCount);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}