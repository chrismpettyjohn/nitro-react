{"ast":null,"code":"/* eslint-disable */\n\n/*!\n * @pixi/tilemap - v3.2.2\n * Compiled Fri, 22 Oct 2021 12:27:49 UTC\n *\n * @pixi/tilemap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved\n */\nimport { Container, Bounds } from '@pixi/display';\nimport { Texture, Resource, Shader, Program, Geometry, Buffer, ObjectRenderer, BaseTexture, Renderer } from '@pixi/core';\nimport { SCALE_MODES, DRAW_MODES, ALPHA_MODES, WRAP_MODES } from '@pixi/constants';\nimport { groupD8, Matrix } from '@pixi/math';\nimport { createIndicesForQuads } from '@pixi/utils';\n/**\r\n * The renderer plugin for canvas. It isn't registered by default.\r\n *\r\n * ```\r\n * import { CanvasTileRenderer } from '@pixi/tilemap';\r\n * import { CanvasRenderer } from '@pixi/canvas-core';\r\n *\r\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\r\n * // prevent a hard dependency on @pixi/canvas-core.\r\n * CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer);\r\n * ```\r\n */\n// TODO: Move to @pixi/tilemap-canvas\n\nclass CanvasTileRenderer {\n  /** The renderer */\n\n  /** The global tile animation state */\n  __init() {\n    this.tileAnim = [0, 0];\n  }\n  /** @deprecated */\n\n\n  __init2() {\n    this.dontUseTransform = false;\n  }\n  /** @param renderer */\n\n\n  constructor(renderer) {\n    CanvasTileRenderer.prototype.__init.call(this);\n\n    CanvasTileRenderer.prototype.__init2.call(this);\n\n    this.renderer = renderer;\n    this.tileAnim = [0, 0];\n  } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\n  static getInstance(renderer) {\n    if (!renderer.plugins.tilemap) {\n      renderer.plugins.tilemap = new CanvasTileRenderer(renderer);\n    }\n\n    return renderer.plugins.tilemap;\n  }\n\n}\n/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */\n\n\nconst settings = {\n  /** The default number of textures per tilemap in a tilemap composite. */\n  TEXTURES_PER_TILEMAP: 16,\n\n  /**\r\n   * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.\r\n   *\r\n   * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly\r\n   * upload the textures togther in a tiled fashion.\r\n   */\n  TEXTILE_DIMEN: 1024,\n\n  /**\r\n   * The number of texture tiles per {@link TextileResource}.\r\n   *\r\n   * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a\r\n   * higher value, textures will be uploaded together in a tiled fashion.\r\n   *\r\n   * Since {@link TextileResource} is a dual-column format, this should be even for packing\r\n   * efficiency. The optimal value is usually 4.\r\n   */\n  TEXTILE_UNITS: 1,\n\n  /** The scaling mode of the combined texture tiling. */\n  TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,\n\n  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\n  use32bitIndex: false,\n\n  /** Flags whether textiles should be cleared when each tile is uploaded. */\n  DO_CLEAR: true,\n\n  // Backward compatibility\n  get maxTextures() {\n    return this.MAX_TEXTURES;\n  },\n\n  set maxTextures(value) {\n    this.MAX_TEXTURES = value;\n  },\n\n  get boundSize() {\n    return this.TEXTURE_TILE_DIMEN;\n  },\n\n  set boundSize(value) {\n    this.TILE_TEXTURE_DIMEN = value;\n  },\n\n  get boundCountPerBuffer() {\n    return this.TEXTILE_UNITS;\n  },\n\n  set boundCountPerBuffer(value) {\n    this.TEXTILE_UNITS = value;\n  }\n\n}; // @deprecated\n\nconst Constant = settings;\n\nfunction _nullishCoalesce(lhs, rhsFn) {\n  if (lhs != null) {\n    return lhs;\n  } else {\n    return rhsFn();\n  }\n}\n\nvar POINT_STRUCT;\n\n(function (POINT_STRUCT) {\n  const U = 0;\n  POINT_STRUCT[POINT_STRUCT[\"U\"] = U] = \"U\";\n  const V = U + 1;\n  POINT_STRUCT[POINT_STRUCT[\"V\"] = V] = \"V\";\n  const X = V + 1;\n  POINT_STRUCT[POINT_STRUCT[\"X\"] = X] = \"X\";\n  const Y = X + 1;\n  POINT_STRUCT[POINT_STRUCT[\"Y\"] = Y] = \"Y\";\n  const TILE_WIDTH = Y + 1;\n  POINT_STRUCT[POINT_STRUCT[\"TILE_WIDTH\"] = TILE_WIDTH] = \"TILE_WIDTH\";\n  const TILE_HEIGHT = TILE_WIDTH + 1;\n  POINT_STRUCT[POINT_STRUCT[\"TILE_HEIGHT\"] = TILE_HEIGHT] = \"TILE_HEIGHT\";\n  const ROTATE = TILE_HEIGHT + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ROTATE\"] = ROTATE] = \"ROTATE\";\n  const ANIM_X = ROTATE + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ANIM_X\"] = ANIM_X] = \"ANIM_X\";\n  const ANIM_Y = ANIM_X + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ANIM_Y\"] = ANIM_Y] = \"ANIM_Y\";\n  const TEXTURE_INDEX = ANIM_Y + 1;\n  POINT_STRUCT[POINT_STRUCT[\"TEXTURE_INDEX\"] = TEXTURE_INDEX] = \"TEXTURE_INDEX\";\n  const ANIM_COUNT_X = TEXTURE_INDEX + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_X\"] = ANIM_COUNT_X] = \"ANIM_COUNT_X\";\n  const ANIM_COUNT_Y = ANIM_COUNT_X + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_Y\"] = ANIM_COUNT_Y] = \"ANIM_COUNT_Y\";\n  const ANIM_DIVISOR = ANIM_COUNT_Y + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ANIM_DIVISOR\"] = ANIM_DIVISOR] = \"ANIM_DIVISOR\";\n  const ALPHA = ANIM_DIVISOR + 1;\n  POINT_STRUCT[POINT_STRUCT[\"ALPHA\"] = ALPHA] = \"ALPHA\";\n})(POINT_STRUCT || (POINT_STRUCT = {}));\n\nconst POINT_STRUCT_SIZE = Object.keys(POINT_STRUCT).length / 2;\n/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */\n\nclass Tilemap extends Container {\n  __init() {\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n  }\n\n  __init2() {\n    this._globalMat = null;\n  }\n  /**\r\n   * The tile animation frame.\r\n   *\r\n   * @see CompositeTilemap.tileAnim\r\n   */\n\n\n  __init3() {\n    this.tileAnim = null;\n  }\n  /**\r\n   * This is the last uploaded size of the tilemap geometry.\r\n   * @ignore\r\n   */\n\n\n  __init4() {\n    this.modificationMarker = 0;\n  }\n  /** @ignore */\n\n\n  __init5() {\n    this.offsetX = 0;\n  }\n  /** @ignore */\n\n\n  __init6() {\n    this.offsetY = 0;\n  }\n  /** @ignore */\n\n\n  __init7() {\n    this.compositeParent = false;\n  }\n  /**\r\n   * The list of base-textures being used in the tilemap.\r\n   *\r\n   * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n   * should be added after tiles have been added into the map.\r\n   */\n\n  /**\r\n   * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n   */\n\n\n  __init8() {\n    this.tilemapBounds = new Bounds();\n  }\n  /** Flags whether any animated tile was added. */\n\n\n  __init9() {\n    this.hasAnimatedTile = false;\n  }\n  /** The interleaved geometry of the tilemap. */\n\n\n  __init10() {\n    this.pointsBuf = [];\n  }\n  /**\r\n   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n   *      base-textures in this array must not be duplicated.\r\n   */\n\n\n  constructor(tileset) {\n    super();\n\n    Tilemap.prototype.__init.call(this);\n\n    Tilemap.prototype.__init2.call(this);\n\n    Tilemap.prototype.__init3.call(this);\n\n    Tilemap.prototype.__init4.call(this);\n\n    Tilemap.prototype.__init5.call(this);\n\n    Tilemap.prototype.__init6.call(this);\n\n    Tilemap.prototype.__init7.call(this);\n\n    Tilemap.prototype.__init8.call(this);\n\n    Tilemap.prototype.__init9.call(this);\n\n    Tilemap.prototype.__init10.call(this);\n\n    Tilemap.prototype.__init11.call(this);\n\n    Tilemap.prototype.__init12.call(this);\n\n    Tilemap.prototype.__init13.call(this);\n\n    Tilemap.prototype.__init14.call(this);\n\n    Tilemap.prototype.__init15.call(this);\n\n    Tilemap.prototype.__init16.call(this);\n\n    this.setTileset(tileset);\n  }\n  /**\r\n   * @returns The tileset of this tilemap.\r\n   */\n\n\n  getTileset() {\n    return this.tileset;\n  }\n  /**\r\n   * Define the tileset used by the tilemap.\r\n   *\r\n   * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n   *  be wrapped into an array. This should not contain any duplicates.\r\n   */\n\n\n  setTileset() {\n    let tileset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (!Array.isArray(tileset)) {\n      tileset = [tileset];\n    }\n\n    for (let i = 0; i < tileset.length; i++) {\n      if (tileset[i].baseTexture) {\n        tileset[i] = tileset[i].baseTexture;\n      }\n    }\n\n    this.tileset = tileset;\n    return this;\n  }\n  /**  Clears all the tiles added into this tilemap. */\n\n\n  clear() {\n    this.pointsBuf.length = 0;\n    this.modificationMarker = 0;\n    this.tilemapBounds.clear();\n    this.hasAnimatedTile = false;\n    return this;\n  }\n  /**\r\n   * Adds a tile that paints the given texture at (x, y).\r\n   *\r\n   * @param tileTexture - The tiling texture to render.\r\n   * @param x - The local x-coordinate of the tile's position.\r\n   * @param y - The local y-coordinate of the tile's position.\r\n   * @param options - Additional tile options.\r\n   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n   * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n   *      animation frame textures in the base-texture.\r\n   * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n   *      animation frames textures in the base-texture.\r\n   * @param [options.rotate=0]\r\n   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n   *      per row.\r\n   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n   *      per column.\r\n   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n   * @param [options.alpha=1] - Tile alpha\r\n   * @return This tilemap, good for chaining.\r\n   */\n\n\n  tile(tileTexture, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let baseTexture;\n    let textureIndex = -1;\n\n    if (typeof tileTexture === 'number') {\n      textureIndex = tileTexture;\n      baseTexture = this.tileset[textureIndex];\n    } else {\n      let texture;\n\n      if (typeof tileTexture === 'string') {\n        texture = Texture.from(tileTexture);\n      } else {\n        texture = tileTexture;\n      }\n\n      const textureList = this.tileset;\n\n      for (let i = 0; i < textureList.length; i++) {\n        if (textureList[i] === texture.castToBaseTexture()) {\n          textureIndex = i;\n          break;\n        }\n      }\n\n      if ('baseTexture' in texture) {\n        options.u = _nullishCoalesce(options.u, () => texture.frame.x);\n        options.v = _nullishCoalesce(options.v, () => texture.frame.y);\n        options.tileWidth = _nullishCoalesce(options.tileWidth, () => texture.orig.width);\n        options.tileHeight = _nullishCoalesce(options.tileHeight, () => texture.orig.height);\n      }\n\n      baseTexture = texture.castToBaseTexture();\n    }\n\n    if (!baseTexture || textureIndex < 0) {\n      console.error('The tile texture was not found in the tilemap tileset.');\n      return this;\n    }\n\n    const {\n      u = 0,\n      v = 0,\n      tileWidth = baseTexture.realWidth,\n      tileHeight = baseTexture.realHeight,\n      animX = 0,\n      animY = 0,\n      rotate = 0,\n      animCountX = 1024,\n      animCountY = 1024,\n      animDivisor = 1,\n      alpha = 1\n    } = options;\n    const pb = this.pointsBuf;\n    this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\n    pb.push(u);\n    pb.push(v);\n    pb.push(x);\n    pb.push(y);\n    pb.push(tileWidth);\n    pb.push(tileHeight);\n    pb.push(rotate);\n    pb.push(animX | 0);\n    pb.push(animY | 0);\n    pb.push(textureIndex);\n    pb.push(animCountX);\n    pb.push(animCountY);\n    pb.push(animDivisor);\n    pb.push(alpha);\n    this.tilemapBounds.addFramePad(x, y, x + tileWidth, y + tileHeight, 0, 0);\n    return this;\n  }\n  /** Changes the rotation of the last tile. */\n\n\n  tileRotate(rotate) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\n  }\n  /** Changes the `animX`, `animCountX` of the last tile. */\n\n\n  tileAnimX(offset, count) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count; // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n  }\n  /** Changes the `animY`, `animCountY` of the last tile. */\n\n\n  tileAnimY(offset, count) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\n  }\n  /** Changes the `animDivisor` value of the last tile. */\n\n\n  tileAnimDivisor(divisor) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\n  }\n\n  tileAlpha(alpha) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\n  }\n\n  __init11() {\n    this.renderCanvas = renderer => {\n      const plugin = CanvasTileRenderer.getInstance(renderer);\n\n      if (plugin && !plugin.dontUseTransform) {\n        const wt = this.worldTransform;\n        renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n      }\n\n      this.renderCanvasCore(renderer);\n    };\n  }\n\n  renderCanvasCore(renderer) {\n    if (this.tileset.length === 0) return;\n    const points = this.pointsBuf;\n    const tileAnim = this.tileAnim || renderer.plugins.tilemap && renderer.plugins.tilemap.tileAnim;\n    renderer.context.fillStyle = '#000000';\n\n    for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE) {\n      let x1 = points[i + POINT_STRUCT.U];\n      let y1 = points[i + POINT_STRUCT.V];\n      const x2 = points[i + POINT_STRUCT.X];\n      const y2 = points[i + POINT_STRUCT.Y];\n      const w = points[i + POINT_STRUCT.TILE_WIDTH];\n      const h = points[i + POINT_STRUCT.TILE_HEIGHT];\n      x1 += points[i + POINT_STRUCT.ANIM_X] * tileAnim[0];\n      y1 += points[i + POINT_STRUCT.ANIM_Y] * tileAnim[1];\n      const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\n      const alpha = points[i + POINT_STRUCT.ALPHA]; // canvas does not work with rotate yet\n\n      if (textureIndex >= 0 && this.tileset[textureIndex]) {\n        renderer.context.globalAlpha = alpha;\n        renderer.context.drawImage(this.tileset[textureIndex].getDrawableSource(), x1, y1, w, h, x2, y2, w, h);\n      } else {\n        renderer.context.globalAlpha = 0.5;\n        renderer.context.fillRect(x2, y2, w, h);\n      }\n\n      renderer.context.globalAlpha = 1;\n    }\n  }\n\n  __init12() {\n    this.vbId = 0;\n  }\n\n  __init13() {\n    this.vb = null;\n  }\n\n  __init14() {\n    this.vbBuffer = null;\n  }\n\n  __init15() {\n    this.vbArray = null;\n  }\n\n  __init16() {\n    this.vbInts = null;\n  }\n\n  destroyVb() {\n    if (this.vb) {\n      this.vb.destroy();\n      this.vb = null;\n    }\n  }\n\n  render(renderer) {\n    const plugin = renderer.plugins.tilemap;\n    const shader = plugin.getShader();\n    renderer.batch.setObjectRenderer(plugin);\n    this._globalMat = shader.uniforms.projTransMatrix;\n    renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n    shader.uniforms.shadowColor = this.shadowColor;\n    shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n    this.renderWebGLCore(renderer, plugin);\n  }\n\n  renderWebGLCore(renderer, plugin) {\n    const points = this.pointsBuf;\n    if (points.length === 0) return;\n    const rectsCount = points.length / POINT_STRUCT_SIZE;\n    const shader = plugin.getShader();\n    const textures = this.tileset;\n    if (textures.length === 0) return;\n    plugin.bindTileTextures(renderer, textures);\n    renderer.shader.bind(shader, false); // lost context! recover!\n\n    let vb = this.vb;\n\n    if (!vb) {\n      vb = plugin.createVb();\n      this.vb = vb;\n      this.vbId = vb.id;\n      this.vbBuffer = null;\n      this.modificationMarker = 0;\n    }\n\n    plugin.checkIndexBuffer(rectsCount, vb);\n    const boundCountPerBuffer = settings.TEXTILE_UNITS;\n    const vertexBuf = vb.getBuffer('aVertexPosition'); // if layer was changed, re-upload vertices\n\n    const vertices = rectsCount * vb.vertPerQuad;\n    if (vertices === 0) return;\n\n    if (this.modificationMarker !== vertices) {\n      this.modificationMarker = vertices;\n      const vs = vb.stride * vertices;\n\n      if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n        // !@#$ happens, need resize\n        let bk = vb.stride;\n\n        while (bk < vs) {\n          bk *= 2;\n        }\n\n        this.vbBuffer = new ArrayBuffer(bk);\n        this.vbArray = new Float32Array(this.vbBuffer);\n        this.vbInts = new Uint32Array(this.vbBuffer);\n        vertexBuf.update(this.vbBuffer);\n      }\n\n      const arr = this.vbArray; // const ints = this.vbInts;\n      // upload vertices!\n\n      let sz = 0; // let tint = 0xffffffff;\n\n      let textureId = 0;\n      let shiftU = this.offsetX;\n      let shiftV = this.offsetY; // let tint = 0xffffffff;\n      // const tint = -1;\n\n      for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE) {\n        const eps = 0.5;\n\n        if (this.compositeParent) {\n          const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\n\n          if (boundCountPerBuffer > 1) {\n            // TODO: what if its more than 4?\n            textureId = textureIndex >> 2;\n            shiftU = this.offsetX * (textureIndex & 1);\n            shiftV = this.offsetY * (textureIndex >> 1 & 1);\n          } else {\n            textureId = textureIndex;\n            shiftU = 0;\n            shiftV = 0;\n          }\n        }\n\n        const x = points[i + POINT_STRUCT.X];\n        const y = points[i + POINT_STRUCT.Y];\n        const w = points[i + POINT_STRUCT.TILE_WIDTH];\n        const h = points[i + POINT_STRUCT.TILE_HEIGHT];\n        const u = points[i + POINT_STRUCT.U] + shiftU;\n        const v = points[i + POINT_STRUCT.V] + shiftV;\n        let rotate = points[i + POINT_STRUCT.ROTATE];\n        const animX = points[i + POINT_STRUCT.ANIM_X];\n        const animY = points[i + POINT_STRUCT.ANIM_Y];\n        const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\n        const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\n        const animXEncoded = animX + animWidth * 2048;\n        const animYEncoded = animY + animHeight * 2048;\n        const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\n        const alpha = points[i + POINT_STRUCT.ALPHA];\n        let u0;\n        let v0;\n        let u1;\n        let v1;\n        let u2;\n        let v2;\n        let u3;\n        let v3;\n\n        if (rotate === 0) {\n          u0 = u;\n          v0 = v;\n          u1 = u + w;\n          v1 = v;\n          u2 = u + w;\n          v2 = v + h;\n          u3 = u;\n          v3 = v + h;\n        } else {\n          let w2 = w / 2;\n          let h2 = h / 2;\n\n          if (rotate % 4 !== 0) {\n            w2 = h / 2;\n            h2 = w / 2;\n          }\n\n          const cX = u + w2;\n          const cY = v + h2;\n          rotate = groupD8.add(rotate, groupD8.NW);\n          u0 = cX + w2 * groupD8.uX(rotate);\n          v0 = cY + h2 * groupD8.uY(rotate);\n          rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n\n          u1 = cX + w2 * groupD8.uX(rotate);\n          v1 = cY + h2 * groupD8.uY(rotate);\n          rotate = groupD8.add(rotate, 2);\n          u2 = cX + w2 * groupD8.uX(rotate);\n          v2 = cY + h2 * groupD8.uY(rotate);\n          rotate = groupD8.add(rotate, 2);\n          u3 = cX + w2 * groupD8.uX(rotate);\n          v3 = cY + h2 * groupD8.uY(rotate);\n        }\n\n        arr[sz++] = x;\n        arr[sz++] = y;\n        arr[sz++] = u0;\n        arr[sz++] = v0;\n        arr[sz++] = u + eps;\n        arr[sz++] = v + eps;\n        arr[sz++] = u + w - eps;\n        arr[sz++] = v + h - eps;\n        arr[sz++] = animXEncoded;\n        arr[sz++] = animYEncoded;\n        arr[sz++] = textureId;\n        arr[sz++] = animDivisor;\n        arr[sz++] = alpha;\n        arr[sz++] = x + w;\n        arr[sz++] = y;\n        arr[sz++] = u1;\n        arr[sz++] = v1;\n        arr[sz++] = u + eps;\n        arr[sz++] = v + eps;\n        arr[sz++] = u + w - eps;\n        arr[sz++] = v + h - eps;\n        arr[sz++] = animXEncoded;\n        arr[sz++] = animYEncoded;\n        arr[sz++] = textureId;\n        arr[sz++] = animDivisor;\n        arr[sz++] = alpha;\n        arr[sz++] = x + w;\n        arr[sz++] = y + h;\n        arr[sz++] = u2;\n        arr[sz++] = v2;\n        arr[sz++] = u + eps;\n        arr[sz++] = v + eps;\n        arr[sz++] = u + w - eps;\n        arr[sz++] = v + h - eps;\n        arr[sz++] = animXEncoded;\n        arr[sz++] = animYEncoded;\n        arr[sz++] = textureId;\n        arr[sz++] = animDivisor;\n        arr[sz++] = alpha;\n        arr[sz++] = x;\n        arr[sz++] = y + h;\n        arr[sz++] = u3;\n        arr[sz++] = v3;\n        arr[sz++] = u + eps;\n        arr[sz++] = v + eps;\n        arr[sz++] = u + w - eps;\n        arr[sz++] = v + h - eps;\n        arr[sz++] = animXEncoded;\n        arr[sz++] = animYEncoded;\n        arr[sz++] = textureId;\n        arr[sz++] = animDivisor;\n        arr[sz++] = alpha;\n      }\n\n      vertexBuf.update(arr);\n    }\n\n    renderer.geometry.bind(vb, shader);\n    renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\n  }\n  /**\r\n   * @internal\r\n   * @ignore\r\n   */\n\n\n  isModified(anim) {\n    if (this.modificationMarker !== this.pointsBuf.length || anim && this.hasAnimatedTile) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * This will pull forward the modification marker.\r\n   *\r\n   * @internal\r\n   * @ignore\r\n   */\n\n\n  clearModify() {\n    this.modificationMarker = this.pointsBuf.length;\n  }\n  /** @override */\n\n\n  _calculateBounds() {\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = this.tilemapBounds;\n\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  /** @override */\n\n\n  getLocalBounds(rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      return this.tilemapBounds.getRectangle(rect);\n    }\n\n    return super.getLocalBounds.call(this, rect);\n  }\n  /** @override */\n\n\n  destroy(options) {\n    super.destroy(options);\n    this.destroyVb();\n  }\n  /**\r\n   * Deprecated signature for {@link Tilemap.tile tile}.\r\n   *\r\n   * @deprecated Since @pixi/tilemap 3.\r\n   */\n\n\n  addFrame(texture, x, y, animX, animY) {\n    this.tile(texture, x, y, {\n      animX,\n      animY\n    });\n    return true;\n  }\n  /**\r\n   * Deprecated signature for {@link Tilemap.tile tile}.\r\n   *\r\n   * @deprecated Since @pixi/tilemap 3.\r\n   */\n  // eslint-disable-next-line max-params\n\n\n  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight) {\n    let animX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let animY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let rotate = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let animCountX = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1024;\n    let animCountY = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 1024;\n    let animDivisor = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 1;\n    let alpha = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 1;\n    return this.tile(textureIndex, x, y, {\n      u,\n      v,\n      tileWidth,\n      tileHeight,\n      animX,\n      animY,\n      rotate,\n      animCountX,\n      animCountY,\n      animDivisor,\n      alpha\n    });\n  }\n\n}\n/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */\n\n\nclass CompositeTilemap extends Container {\n  /** The hard limit on the number of tile textures used in each tilemap. */\n\n  /**\r\n   * The animation frame vector.\r\n   *\r\n   * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n   * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n   * row and `animCountY` per column.\r\n   *\r\n   * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n   * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n   */\n  __init() {\n    this.tileAnim = null;\n  }\n  /** The last modified tilemap. */\n\n\n  __init2() {\n    this.lastModifiedTilemap = null;\n  }\n\n  __init3() {\n    this.modificationMarker = 0;\n  }\n\n  __init4() {\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n  }\n\n  __init5() {\n    this._globalMat = null;\n  }\n  /**\r\n   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n   *  will work equivalently.\r\n   */\n\n\n  constructor(tileset) {\n    super();\n\n    CompositeTilemap.prototype.__init.call(this);\n\n    CompositeTilemap.prototype.__init2.call(this);\n\n    CompositeTilemap.prototype.__init3.call(this);\n\n    CompositeTilemap.prototype.__init4.call(this);\n\n    CompositeTilemap.prototype.__init5.call(this);\n\n    CompositeTilemap.prototype.__init6.call(this);\n\n    this.tileset(tileset);\n    this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\n  }\n  /**\r\n   * This will preinitialize the tilesets of the layered tilemaps.\r\n   *\r\n   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n   *\r\n   * @param tileTextures - The list of tile textures that make up the tileset.\r\n   */\n\n\n  tileset(tileTextures) {\n    if (!tileTextures) {\n      tileTextures = [];\n    }\n\n    const texPerChild = this.texturesPerTilemap;\n    const len1 = this.children.length;\n    const len2 = Math.ceil(tileTextures.length / texPerChild);\n\n    for (let i = 0; i < Math.min(len1, len2); i++) {\n      this.children[i].setTileset(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n    }\n\n    for (let i = len1; i < len2; i++) {\n      const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n      tilemap.compositeParent = true;\n      tilemap.offsetX = settings.TEXTILE_DIMEN;\n      tilemap.offsetY = settings.TEXTILE_DIMEN; // TODO: Don't use children\n\n      this.addChild(tilemap);\n    }\n\n    return this;\n  }\n  /** Clears the tilemap composite. */\n\n\n  clear() {\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].clear();\n    }\n\n    this.modificationMarker = 0;\n    return this;\n  }\n  /** Changes the rotation of the last added tile. */\n\n\n  tileRotate(rotate) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileRotate(rotate);\n    }\n\n    return this;\n  }\n  /** Changes `animX`, `animCountX` of the last added tile. */\n\n\n  tileAnimX(offset, count) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimX(offset, count);\n    }\n\n    return this;\n  }\n  /** Changes `animY`, `animCountY` of the last added tile. */\n\n\n  tileAnimY(offset, count) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimY(offset, count);\n    }\n\n    return this;\n  }\n  /** Changes `tileAnimDivisor` value of the last added tile. */\n\n\n  tileAnimDivisor(divisor) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimDivisor(divisor);\n    }\n\n    return this;\n  }\n  /**\r\n   * Adds a tile that paints the given tile texture at (x, y).\r\n   *\r\n   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n   * @param x - The local x-coordinate of the tile's location.\r\n   * @param y - The local y-coordinate of the tile's location.\r\n   * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n   * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n   *      animation frame textures in the base-texture.\r\n   * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n   *      animation frames textures in the base-texture.\r\n   * @param [options.rotate=0]\r\n   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n   *      per row.\r\n   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n   *      per column.\r\n   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n   * @param [options.alpha=1] - Tile alpha\r\n   * @return This tilemap, good for chaining.\r\n   */\n\n\n  tile(tileTexture, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let tilemap = null;\n    const children = this.children;\n    this.lastModifiedTilemap = null;\n\n    if (typeof tileTexture === 'number') {\n      const childIndex = tileTexture / this.texturesPerTilemap >> 0;\n      let tileIndex = 0;\n      tilemap = children[childIndex];\n\n      if (!tilemap) {\n        tilemap = children[0]; // Silently fail if the tilemap doesn't exist\n\n        if (!tilemap) return this;\n        tileIndex = 0;\n      } else {\n        tileIndex = tileTexture % this.texturesPerTilemap;\n      }\n\n      tilemap.tile(tileIndex, x, y, options);\n    } else {\n      if (typeof tileTexture === 'string') {\n        tileTexture = Texture.from(tileTexture);\n      } // Probe all tilemaps to find which tileset contains the base-texture.\n\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const tex = child.getTileset();\n\n        for (let j = 0; j < tex.length; j++) {\n          if (tex[j] === tileTexture.baseTexture) {\n            tilemap = child;\n            break;\n          }\n        }\n\n        if (tilemap) {\n          break;\n        }\n      } // If no tileset contains the base-texture, attempt to add it.\n\n\n      if (!tilemap) {\n        // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n\n          if (child.getTileset().length < this.texturesPerTilemap) {\n            tilemap = child;\n            child.getTileset().push(tileTexture.baseTexture);\n            break;\n          }\n        } // Otherwise, create a new tilemap initialized with that tile texture.\n\n\n        if (!tilemap) {\n          tilemap = new Tilemap(tileTexture.baseTexture);\n          tilemap.compositeParent = true;\n          tilemap.offsetX = settings.TEXTILE_DIMEN;\n          tilemap.offsetY = settings.TEXTILE_DIMEN;\n          this.addChild(tilemap);\n        }\n      }\n\n      tilemap.tile(tileTexture, x, y, options);\n    }\n\n    this.lastModifiedTilemap = tilemap;\n    return this;\n  }\n\n  renderCanvas(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n\n    const tilemapPlugin = CanvasTileRenderer.getInstance(renderer);\n\n    if (tilemapPlugin && !tilemapPlugin.dontUseTransform) {\n      const wt = this.worldTransform;\n      renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n    }\n\n    const layers = this.children;\n\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      layer.tileAnim = this.tileAnim;\n      layer.renderCanvasCore(renderer);\n    }\n  }\n\n  render(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n\n    const plugin = renderer.plugins.tilemap;\n    const shader = plugin.getShader();\n    renderer.batch.setObjectRenderer(plugin); // TODO: dont create new array, please\n\n    this._globalMat = shader.uniforms.projTransMatrix;\n    renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n    shader.uniforms.shadowColor = this.shadowColor;\n    shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n    renderer.shader.bind(shader, false);\n    const layers = this.children;\n\n    for (let i = 0; i < layers.length; i++) {\n      layers[i].renderWebGLCore(renderer, plugin);\n    }\n  }\n  /**\r\n   * @internal\r\n   * @ignore\r\n   */\n\n\n  isModified(anim) {\n    const layers = this.children;\n\n    if (this.modificationMarker !== layers.length) {\n      return true;\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n      if (layers[i].isModified(anim)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * @internal\r\n   * @ignore\r\n   */\n\n\n  clearModify() {\n    const layers = this.children;\n    this.modificationMarker = layers.length;\n\n    for (let i = 0; i < layers.length; i++) {\n      layers[i].clearModify();\n    }\n  }\n  /**\r\n   * @deprecated Since @pixi/tilemap 3.\r\n   * @see CompositeTilemap.tile\r\n   */\n\n\n  addFrame(texture, x, y, animX, animY, animWidth, animHeight, animDivisor, alpha) {\n    return this.tile(texture, x, y, {\n      animX,\n      animY,\n      animCountX: animWidth,\n      animCountY: animHeight,\n      animDivisor,\n      alpha\n    });\n  }\n  /**\r\n   * @deprecated @pixi/tilemap 3\r\n   * @see CompositeTilemap.tile\r\n   */\n  // eslint-disable-next-line max-params\n\n\n  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight) {\n    const childIndex = textureIndex / this.texturesPerTilemap >> 0;\n    const textureId = textureIndex % this.texturesPerTilemap;\n\n    if (this.children[childIndex] && this.children[childIndex].getTileset()) {\n      this.lastModifiedTilemap = this.children[childIndex];\n      this.lastModifiedTilemap.addRect(textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight);\n    } else {\n      this.lastModifiedTilemap = null;\n    }\n\n    return this;\n  }\n  /**\r\n   * Alias for {@link CompositeTilemap.tileset tileset}.\r\n   *\r\n   * @deprecated Since @pixi/tilemap 3.\r\n   */\n\n\n  __init6() {\n    this.setBitmaps = this.tileset;\n  }\n  /**\r\n   * @deprecated Since @pixi/tilemap 3.\r\n   * @readonly\r\n   * @see CompositeTilemap.texturesPerTilemap\r\n   */\n\n\n  get texPerChild() {\n    return this.texturesPerTilemap;\n  }\n\n} // For some reason ESLint goes mad with indendation in this file ^&^\n\n/* eslint-disable indent */\n\n/**\r\n * This texture tiling resource can be used to upload multiple base-textures together.\r\n *\r\n * This resource combines multiple base-textures into a \"textile\". They're laid out in\r\n * a dual column format, placed in row-order order. The size of each tile is predefined,\r\n * and defaults to {@link settings.TEXTILE_DIMEN}. This means that each input base-texture\r\n * must is smaller than that along both its width and height.\r\n *\r\n * @see settings.TEXTILE_UNITS\r\n */\n\n\nclass TextileResource extends Resource {\n  /** The base-texture that contains all the texture tiles. */\n  __init() {\n    this.baseTexture = null;\n  }\n\n  __init2() {\n    this._clearBuffer = null;\n  }\n  /**\r\n   * @param options - This will default to the \"settings\" exported by @pixi/tilemap.\r\n   * @param options.TEXTILE_DIMEN - The dimensions of each tile.\r\n   * @param options.TEXTILE_UNITS - The number of texture tiles.\r\n   */\n\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : settings;\n    super(options.TEXTILE_DIMEN * 2, options.TEXTILE_DIMEN * Math.ceil(options.TEXTILE_UNITS / 2));\n\n    TextileResource.prototype.__init.call(this);\n\n    TextileResource.prototype.__init2.call(this);\n\n    const tiles = this.tiles = new Array(options.TEXTILE_UNITS);\n    this.doClear = !!options.DO_CLEAR;\n    this.tileDimen = options.TEXTILE_DIMEN;\n\n    for (let j = 0; j < options.TEXTILE_UNITS; j++) {\n      tiles[j] = {\n        dirtyId: 0,\n        x: options.TEXTILE_DIMEN * (j & 1),\n        y: options.TEXTILE_DIMEN * (j >> 1),\n        baseTexture: Texture.WHITE.baseTexture\n      };\n    }\n  }\n  /**\r\n   * Sets the texture to be uploaded for the given tile.\r\n   *\r\n   * @param index - The index of the tile being set.\r\n   * @param texture - The texture with the base-texture to upload.\r\n   */\n\n\n  tile(index, texture) {\n    const tile = this.tiles[index];\n\n    if (tile.baseTexture === texture) {\n      return;\n    }\n\n    tile.baseTexture = texture;\n    this.baseTexture.update();\n    this.tiles[index].dirtyId = this.baseTexture.dirtyId;\n  }\n  /** @override */\n\n\n  bind(baseTexture) {\n    if (this.baseTexture) {\n      throw new Error('Only one baseTexture is allowed for this resource!');\n    }\n\n    this.baseTexture = baseTexture;\n    super.bind(baseTexture);\n  }\n  /** @override */\n\n\n  upload(renderer, texture, glTexture) {\n    const {\n      gl\n    } = renderer;\n    const {\n      width,\n      height\n    } = this;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.alphaMode === undefined || texture.alphaMode === ALPHA_MODES.UNPACK);\n\n    if (glTexture.dirtyId < 0) {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null);\n    }\n\n    const doClear = this.doClear;\n    const tiles = this.tiles;\n\n    if (doClear && !this._clearBuffer) {\n      this._clearBuffer = new Uint8Array(settings.TEXTILE_DIMEN * settings.TEXTILE_DIMEN * 4);\n    }\n\n    for (let i = 0; i < tiles.length; i++) {\n      const spr = tiles[i];\n      const tex = spr.baseTexture;\n\n      if (glTexture.dirtyId >= this.tiles[i].dirtyId) {\n        continue;\n      }\n\n      const res = tex.resource;\n\n      if (!tex.valid || !res || !res.source) {\n        continue;\n      }\n\n      if (doClear && (tex.width < this.tileDimen || tex.height < this.tileDimen)) {\n        gl.texSubImage2D(texture.target, 0, spr.x, spr.y, this.tileDimen, this.tileDimen, texture.format, texture.type, this._clearBuffer);\n      }\n\n      gl.texSubImage2D(texture.target, 0, spr.x, spr.y, texture.format, texture.type, res.source);\n    }\n\n    return true;\n  }\n\n}\n/**\r\n * This will generate fragment shader code that samples the correct texture into the \"color\" variable.\r\n *\r\n * @internal\r\n * @ignore\r\n * @param maxTextures - The texture array length in the shader's uniforms.\r\n */\n\n\nfunction generateSampleSrc(maxTextures) {\n  let src = '';\n  src += '\\n';\n  src += '\\n';\n  src += 'if(vTextureId <= -1.0) {';\n  src += '\\n\\tcolor = shadowColor;';\n  src += '\\n}';\n\n  for (let i = 0; i < maxTextures; i++) {\n    src += '\\nelse ';\n\n    if (i < maxTextures - 1) {\n      src += `if(textureId == ${i}.0)`;\n    }\n\n    src += '\\n{';\n    src += `\\n\\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;\n    src += '\\n}';\n  }\n\n  src += '\\n';\n  src += '\\n';\n  return src;\n}\n/**\r\n * @internal\r\n * @ignore\r\n * @param shader\r\n * @param maxTextures\r\n */\n\n\nfunction fillSamplers(shader, maxTextures) {\n  const sampleValues = [];\n\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n\n  shader.uniforms.uSamplers = sampleValues;\n  const samplerSize = [];\n\n  for (let i = 0; i < maxTextures; i++) {\n    // These are overwritten by TileRenderer when textures actually bound.\n    samplerSize.push(1.0 / 2048);\n    samplerSize.push(1.0 / 2048);\n  }\n\n  shader.uniforms.uSamplerSize = samplerSize;\n}\n/**\r\n * @internal\r\n * @ignore\r\n * @param maxTextures\r\n * @param fragmentSrc\r\n * @returns\r\n */\n\n\nfunction generateFragmentSrc(maxTextures, fragmentSrc) {\n  return fragmentSrc.replace(/%count%/gi, `${maxTextures}`).replace(/%forloop%/gi, generateSampleSrc(maxTextures));\n} // eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\n\n\nconst tilemapVertexTemplateSrc = `#version 100\nprecision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aFrame;\nattribute vec2 aAnim;\nattribute float aAnimDivisor;\nattribute float aTextureId;\nattribute float aAlpha;\n\nuniform mat3 projTransMatrix;\nuniform vec2 animationFrame;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vFrame;\nvarying float vAlpha;\n\nvoid main(void)\n{\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\n\n   vTextureCoord = aTextureCoord + animOffset;\n   vFrame = aFrame + vec4(animOffset, animOffset);\n   vTextureId = aTextureId;\n   vAlpha = aAlpha;\n}\n`;\nconst tilemapFragmentTemplateSrc = `#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvarying vec2 vTextureCoord;\nvarying vec4 vFrame;\nvarying float vTextureId;\nvarying float vAlpha;\nuniform vec4 shadowColor;\nuniform sampler2D uSamplers[%count%];\nuniform vec2 uSamplerSize[%count%];\n\nvoid main(void)\n{\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n   float textureId = floor(vTextureId + 0.5);\n\n   vec4 color;\n   %forloop%\n   gl_FragColor = color * vAlpha;\n}\n`; // For some reason ESLint goes mad with indendation in this file ^&^\n\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nclass TilemapShader extends Shader {\n  __init() {\n    this.maxTextures = 0;\n  }\n\n  constructor(maxTextures) {\n    super(new Program(tilemapVertexTemplateSrc, generateFragmentSrc(maxTextures, tilemapFragmentTemplateSrc)), {\n      animationFrame: new Float32Array(2),\n      uSamplers: [],\n      uSamplerSize: [],\n      projTransMatrix: new Matrix()\n    });\n\n    TilemapShader.prototype.__init.call(this);\n\n    this.maxTextures = maxTextures;\n    fillSamplers(this, this.maxTextures);\n  }\n\n}\n\nclass TilemapGeometry extends Geometry {\n  __init2() {\n    this.vertSize = 13;\n  }\n\n  __init3() {\n    this.vertPerQuad = 4;\n  }\n\n  __init4() {\n    this.stride = this.vertSize * 4;\n  }\n\n  __init5() {\n    this.lastTimeAccess = 0;\n  }\n\n  constructor() {\n    super();\n\n    TilemapGeometry.prototype.__init2.call(this);\n\n    TilemapGeometry.prototype.__init3.call(this);\n\n    TilemapGeometry.prototype.__init4.call(this);\n\n    TilemapGeometry.prototype.__init5.call(this);\n\n    const buf = this.buf = new Buffer(new Float32Array(2), true, false);\n    this.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0).addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4).addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4).addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4).addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4).addAttribute('aAnimDivisor', buf, 0, false, 0, this.stride, 11 * 4).addAttribute('aAlpha', buf, 0, false, 0, this.stride, 12 * 4);\n  }\n\n} // For some reason ESLint goes mad with indendation in this file ^&^\n\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\n/**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */\n\n\nclass TileRenderer extends ObjectRenderer {\n  /** The managing renderer */\n\n  /** The tile animation frame */\n  __init() {\n    this.tileAnim = [0, 0];\n  }\n\n  __init2() {\n    this.ibLen = 0;\n  } // index buffer length\n\n  /** The index buffer for the tilemaps to share. */\n\n\n  __init3() {\n    this.indexBuffer = null;\n  }\n  /** The shader used to render tilemaps. */\n\n  /**\r\n   * {@link TextileResource} instances used to upload textures batched in tiled groups. This is\r\n   * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.\r\n   */\n\n\n  __init4() {\n    this.textiles = [];\n  }\n  /** @param renderer - The managing renderer */\n\n\n  constructor(renderer) {\n    super(renderer);\n\n    TileRenderer.prototype.__init.call(this);\n\n    TileRenderer.prototype.__init2.call(this);\n\n    TileRenderer.prototype.__init3.call(this);\n\n    TileRenderer.prototype.__init4.call(this);\n\n    this.shader = new TilemapShader(settings.TEXTURES_PER_TILEMAP);\n    this.indexBuffer = new Buffer(undefined, true, true);\n    this.checkIndexBuffer(2000);\n    this.makeTextiles();\n  }\n  /**\r\n   * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.\r\n   *\r\n   * If {@link settings.TEXTILE_UNITS}\r\n   *\r\n   * @param renderer - The renderer to which the textures are to be bound.\r\n   * @param textures - The tile textures being bound.\r\n   */\n\n\n  bindTileTextures(renderer, textures) {\n    const len = textures.length;\n    const shader = this.shader;\n    const maxTextures = settings.TEXTURES_PER_TILEMAP;\n    const samplerSize = shader.uniforms.uSamplerSize;\n\n    if (len > settings.TEXTILE_UNITS * maxTextures) {\n      // TODO: Show error message instead of silently failing!\n      return;\n    }\n\n    if (settings.TEXTILE_UNITS <= 1) {\n      // Bind each texture directly & update samplerSize.\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n\n        if (!texture || !texture.valid) {\n          return;\n        }\n\n        renderer.texture.bind(textures[i], i);\n        samplerSize[i * 2] = 1.0 / textures[i].realWidth;\n        samplerSize[i * 2 + 1] = 1.0 / textures[i].realHeight;\n      }\n    } else {\n      // Ensure we have enough textiles, in case settings.TEXTILE_UNITS was modified.\n      this.makeTextiles();\n      const usedTextiles = Math.ceil(len / settings.TEXTILE_UNITS); // First ensure each textile has all tiles point to the right textures.\n\n      for (let i = 0; i < len; i++) {\n        const texture = textures[i];\n\n        if (texture && texture.valid) {\n          const resourceIndex = Math.floor(i / settings.TEXTILE_UNITS);\n          const tileIndex = i % settings.TEXTILE_UNITS;\n          this.textiles[resourceIndex].tile(tileIndex, texture);\n        }\n      } // Then bind the textiles + update samplerSize.\n\n\n      for (let i = 0; i < usedTextiles; i++) {\n        renderer.texture.bind(this.textiles[i].baseTexture, i);\n        samplerSize[i * 2] = 1.0 / this.textiles[i].width;\n        samplerSize[i * 2 + 1] = 1.0 / this.textiles[i].baseTexture.height;\n      }\n    }\n\n    shader.uniforms.uSamplerSize = samplerSize;\n  }\n\n  start() {// sorry, nothing\n  }\n  /**\r\n   * @internal\r\n   * @ignore\r\n   */\n\n\n  createVb() {\n    const geom = new TilemapGeometry();\n    geom.addIndex(this.indexBuffer);\n    geom.lastTimeAccess = Date.now();\n    return geom;\n  }\n  /** @return The {@link TilemapShader} shader that this rendering pipeline is using. */\n\n\n  getShader() {\n    return this.shader;\n  }\n\n  destroy() {\n    super.destroy(); // this.rectShader.destroy();\n\n    this.shader = null;\n  }\n\n  checkIndexBuffer(size) {\n    let _vb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    const totalIndices = size * 6;\n\n    if (totalIndices <= this.ibLen) {\n      return;\n    }\n\n    this.ibLen = totalIndices;\n    this.indexBuffer.update(createIndicesForQuads(size, settings.use32bitIndex ? new Uint32Array(size * 6) : undefined)); // \tTODO: create new index buffer instead?\n    // if (vb) {\n    // \tconst curIndex = vb.getIndex();\n    // \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n    // \t\tthis.swapIndex(vb, this.indexBuffer);\n    // \t}\n    // }\n  }\n  /** Makes textile resources and initializes {@link TileRenderer.textiles}. */\n\n\n  makeTextiles() {\n    if (settings.TEXTILE_UNITS <= 1) {\n      return;\n    }\n\n    for (let i = 0; i < settings.TEXTILE_UNITS; i++) {\n      if (this.textiles[i]) continue;\n      const resource = new TextileResource();\n      const baseTex = new BaseTexture(resource);\n      baseTex.scaleMode = settings.TEXTILE_SCALE_MODE;\n      baseTex.wrapMode = WRAP_MODES.CLAMP;\n      this.textiles[i] = resource;\n    }\n  }\n\n} // eslint-disable-next-line camelcase\n\n\nconst pixi_tilemap = {\n  CanvasTileRenderer,\n  CompositeRectTileLayer: CompositeTilemap,\n  CompositeTilemap,\n  Constant,\n  TextileResource,\n  MultiTextureResource: TextileResource,\n  RectTileLayer: Tilemap,\n  Tilemap,\n  TilemapShader,\n  TilemapGeometry,\n  RectTileShader: TilemapShader,\n  RectTileGeom: TilemapGeometry,\n  TileRenderer\n};\nRenderer.registerPlugin('tilemap', TileRenderer);\nexport { CanvasTileRenderer, CompositeTilemap as CompositeRectTileLayer, CompositeTilemap, Constant, POINT_STRUCT_SIZE, Tilemap as RectTileLayer, TextileResource, TileRenderer, Tilemap, TilemapGeometry, TilemapShader, fillSamplers, generateFragmentSrc, pixi_tilemap, settings };","map":{"version":3,"sources":["../src/CanvasTileRenderer.ts","../src/settings.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/TextileResource.ts","../src/shaderGenerator.ts","../src/TilemapShader.ts","../src/TileRenderer.ts","../src/index.ts"],"names":[],"mappings":"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,CAAA,OAAA;AACA,SAAA,SAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,EAAA,QAAA,CAAA,OAAA,EAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAAA,KAAA,EACA;AACA,SAAA,IAAA,CACA,OADA,EAEA,CAFA,EAGA,CAHA,EAIA;AACA,MAAA,KADA;AAEA,MAAA;AAFA,KAJA;AAUA,WAAA,IAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,EAAA,OAAA,CACA,YADA,EAEA,CAFA,EAGA,CAHA,EAIA,CAJA,EAKA,CALA,EAMA,SANA,EAOA,UAPA,EAgBA;AAAA,QARA,KAQA,uEARA,CAQA;AAAA,QAPA,KAOA,uEAPA,CAOA;AAAA,QANA,MAMA,uEANA,CAMA;AAAA,QALA,UAKA,0EALA,IAKA;AAAA,QAJA,UAIA,0EAJA,IAIA;AAAA,QAHA,WAGA,0EAHA,CAGA;AAAA,QAFA,KAEA,0EAFA,CAEA;AACA,WAAA,KAAA,IAAA,CACA,YADA,EAEA,CAFA,EAEA,CAFA,EAGA;AACA,MAAA,CADA;AACA,MAAA,CADA;AACA,MAAA,SADA;AACA,MAAA,UADA;AACA,MAAA,KADA;AACA,MAAA,KADA;AACA,MAAA,MADA;AACA,MAAA,UADA;AACA,MAAA,UADA;AACA,MAAA,WADA;AACA,MAAA;AADA,KAHA,CAAA;AAOA;;AAlrBA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;yCAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAA,MAAA,GAAA;AAAA,SAAA,QAAA,GAAA,IAAA;AAAA;AAEA;;;AACA,EAAA,OA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","sourcesContent":["import type { AbstractRenderer } from '@pixi/core';\r\n\r\n/**\r\n * The renderer plugin for canvas. It isn't registered by default.\r\n *\r\n * ```\r\n * import { CanvasTileRenderer } from '@pixi/tilemap';\r\n * import { CanvasRenderer } from '@pixi/canvas-core';\r\n *\r\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\r\n * // prevent a hard dependency on @pixi/canvas-core.\r\n * CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer);\r\n * ```\r\n */\r\n// TODO: Move to @pixi/tilemap-canvas\r\nexport class CanvasTileRenderer\r\n{\r\n    /** The renderer */\r\n    renderer: AbstractRenderer;\r\n\r\n    /** The global tile animation state */\r\n    tileAnim = [0, 0];\r\n\r\n    /** @deprecated */\r\n    dontUseTransform = false;\r\n\r\n    /** @param renderer */\r\n    constructor(renderer: AbstractRenderer)\r\n    {\r\n        this.renderer = renderer;\r\n        this.tileAnim = [0, 0];\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static getInstance(renderer: any): CanvasTileRenderer\r\n    {\r\n        if (!renderer.plugins.tilemap)\r\n        {\r\n            renderer.plugins.tilemap = new CanvasTileRenderer(renderer);\r\n        }\r\n\r\n        return renderer.plugins.tilemap;\r\n    }\r\n}\r\n","import { SCALE_MODES } from '@pixi/constants';\r\n\r\n/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */\r\nexport const settings = {\r\n    /** The default number of textures per tilemap in a tilemap composite. */\r\n    TEXTURES_PER_TILEMAP: 16,\r\n\r\n    /**\r\n     * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.\r\n     *\r\n     * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly\r\n     * upload the textures togther in a tiled fashion.\r\n     */\r\n    TEXTILE_DIMEN: 1024,\r\n\r\n    /**\r\n     * The number of texture tiles per {@link TextileResource}.\r\n     *\r\n     * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a\r\n     * higher value, textures will be uploaded together in a tiled fashion.\r\n     *\r\n     * Since {@link TextileResource} is a dual-column format, this should be even for packing\r\n     * efficiency. The optimal value is usually 4.\r\n     */\r\n    TEXTILE_UNITS: 1,\r\n\r\n    /** The scaling mode of the combined texture tiling. */\r\n    TEXTILE_SCALE_MODE: SCALE_MODES.LINEAR,\r\n\r\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\r\n    use32bitIndex: false,\r\n\r\n    /** Flags whether textiles should be cleared when each tile is uploaded. */\r\n    DO_CLEAR: true,\r\n\r\n    // Backward compatibility\r\n    get maxTextures(): number { return this.MAX_TEXTURES; },\r\n    set maxTextures(value: number) { this.MAX_TEXTURES = value; },\r\n\r\n    get boundSize(): number { return this.TEXTURE_TILE_DIMEN; },\r\n    set boundSize(value: number) { this.TILE_TEXTURE_DIMEN = value; },\r\n\r\n    get boundCountPerBuffer(): number { return this.TEXTILE_UNITS; },\r\n    set boundCountPerBuffer(value: number) { this.TEXTILE_UNITS = value; },\r\n};\r\n\r\n// @deprecated\r\nexport const Constant = settings;\r\n","import { Container, Bounds } from '@pixi/display';\r\nimport { DRAW_MODES } from '@pixi/constants';\r\nimport { Texture, Renderer } from '@pixi/core';\r\nimport { TileRenderer } from './TileRenderer';\r\nimport { Matrix, Rectangle, groupD8 } from '@pixi/math';\r\nimport { settings } from './settings';\r\nimport { CanvasTileRenderer } from './CanvasTileRenderer';\r\n\r\nimport type { BaseTexture } from '@pixi/core';\r\nimport type { IDestroyOptions } from '@pixi/display';\r\nimport type { TilemapGeometry } from './TilemapShader';\r\n\r\nenum POINT_STRUCT {\r\n    U,\r\n    V,\r\n    X,\r\n    Y,\r\n    TILE_WIDTH,\r\n    TILE_HEIGHT,\r\n    ROTATE,\r\n    ANIM_X,\r\n    ANIM_Y,\r\n    TEXTURE_INDEX,\r\n    ANIM_COUNT_X,\r\n    ANIM_COUNT_Y,\r\n    ANIM_DIVISOR,\r\n    ALPHA,\r\n}\r\n\r\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\r\n\r\n/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */\r\nexport class Tilemap extends Container\r\n{\r\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    _globalMat: Matrix = null;\r\n\r\n    /**\r\n     * The tile animation frame.\r\n     *\r\n     * @see CompositeTilemap.tileAnim\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /**\r\n     * This is the last uploaded size of the tilemap geometry.\r\n     * @ignore\r\n     */\r\n    modificationMarker = 0;\r\n\r\n    /** @ignore */\r\n    offsetX = 0;\r\n\r\n    /** @ignore */\r\n    offsetY = 0;\r\n\r\n    /** @ignore */\r\n    compositeParent = false;\r\n\r\n    /**\r\n     * The list of base-textures being used in the tilemap.\r\n     *\r\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n     * should be added after tiles have been added into the map.\r\n     */\r\n    protected tileset: Array<BaseTexture>;\r\n\r\n    /**\r\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n     */\r\n    protected readonly tilemapBounds = new Bounds();\r\n\r\n    /** Flags whether any animated tile was added. */\r\n    protected hasAnimatedTile = false;\r\n\r\n    /** The interleaved geometry of the tilemap. */\r\n    private pointsBuf: Array<number> = [];\r\n\r\n    /**\r\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n     *      base-textures in this array must not be duplicated.\r\n     */\r\n    constructor(tileset: BaseTexture | Array<BaseTexture>)\r\n    {\r\n        super();\r\n        this.setTileset(tileset);\r\n    }\r\n\r\n    /**\r\n     * @returns The tileset of this tilemap.\r\n     */\r\n    getTileset(): Array<BaseTexture>\r\n    {\r\n        return this.tileset;\r\n    }\r\n\r\n    /**\r\n     * Define the tileset used by the tilemap.\r\n     *\r\n     * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n     *  be wrapped into an array. This should not contain any duplicates.\r\n     */\r\n    setTileset(tileset: BaseTexture | Array<BaseTexture> = []): this\r\n    {\r\n        if (!Array.isArray(tileset))\r\n        {\r\n            tileset = [tileset];\r\n        }\r\n        for (let i = 0; i < tileset.length; i++)\r\n        {\r\n            if ((tileset[i] as unknown as Texture).baseTexture)\r\n            {\r\n                tileset[i] = (tileset[i] as unknown as Texture).baseTexture;\r\n            }\r\n        }\r\n\r\n        this.tileset = tileset;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**  Clears all the tiles added into this tilemap. */\r\n    clear(): this\r\n    {\r\n        this.pointsBuf.length = 0;\r\n        this.modificationMarker = 0;\r\n        this.tilemapBounds.clear();\r\n        this.hasAnimatedTile = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tiling texture to render.\r\n     * @param x - The local x-coordinate of the tile's position.\r\n     * @param y - The local y-coordinate of the tile's position.\r\n     * @param options - Additional tile options.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: number | string | Texture | BaseTexture,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let baseTexture: BaseTexture;\r\n        let textureIndex = -1;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            textureIndex = tileTexture;\r\n            baseTexture = this.tileset[textureIndex];\r\n        }\r\n        else\r\n        {\r\n            let texture: Texture | BaseTexture;\r\n\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                texture = Texture.from(tileTexture);\r\n            }\r\n            else\r\n            {\r\n                texture = tileTexture;\r\n            }\r\n\r\n            const textureList = this.tileset;\r\n\r\n            for (let i = 0; i < textureList.length; i++)\r\n            {\r\n                if (textureList[i] === texture.castToBaseTexture())\r\n                {\r\n                    textureIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if ('baseTexture' in texture)\r\n            {\r\n                options.u = options.u ?? texture.frame.x;\r\n                options.v = options.v ?? texture.frame.y;\r\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\r\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\r\n            }\r\n\r\n            baseTexture = texture.castToBaseTexture();\r\n        }\r\n\r\n        if (!baseTexture || textureIndex < 0)\r\n        {\r\n            console.error('The tile texture was not found in the tilemap tileset.');\r\n\r\n            return this;\r\n        }\r\n\r\n        const {\r\n            u = 0,\r\n            v = 0,\r\n            tileWidth = baseTexture.realWidth,\r\n            tileHeight = baseTexture.realHeight,\r\n            animX = 0,\r\n            animY = 0,\r\n            rotate = 0,\r\n            animCountX = 1024,\r\n            animCountY = 1024,\r\n            animDivisor = 1,\r\n            alpha = 1,\r\n        } = options;\r\n\r\n        const pb = this.pointsBuf;\r\n\r\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\r\n\r\n        pb.push(u);\r\n        pb.push(v);\r\n        pb.push(x);\r\n        pb.push(y);\r\n        pb.push(tileWidth);\r\n        pb.push(tileHeight);\r\n        pb.push(rotate);\r\n        pb.push(animX | 0);\r\n        pb.push(animY | 0);\r\n        pb.push(textureIndex);\r\n        pb.push(animCountX);\r\n        pb.push(animCountY);\r\n        pb.push(animDivisor);\r\n        pb.push(alpha);\r\n\r\n        this.tilemapBounds.addFramePad(x, y, x + tileWidth, y + tileHeight, 0, 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last tile. */\r\n    tileRotate(rotate: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\r\n    }\r\n\r\n    /** Changes the `animX`, `animCountX` of the last tile. */\r\n    tileAnimX(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\r\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\r\n    }\r\n\r\n    /** Changes the `animY`, `animCountY` of the last tile. */\r\n    tileAnimY(offset: number, count: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\r\n    }\r\n\r\n    /** Changes the `animDivisor` value of the last tile. */\r\n    tileAnimDivisor(divisor: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\r\n    }\r\n\r\n    tileAlpha(alpha: number): void\r\n    {\r\n        const pb = this.pointsBuf;\r\n\r\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = alpha;\r\n    }\r\n\r\n    renderCanvas = (renderer: any): void =>\r\n    {\r\n        const plugin = CanvasTileRenderer.getInstance(renderer);\r\n\r\n        if (plugin && !plugin.dontUseTransform)\r\n        {\r\n            const wt = this.worldTransform;\r\n\r\n            renderer.context.setTransform(\r\n                wt.a,\r\n                wt.b,\r\n                wt.c,\r\n                wt.d,\r\n                wt.tx * renderer.resolution,\r\n                wt.ty * renderer.resolution\r\n            );\r\n        }\r\n\r\n        this.renderCanvasCore(renderer);\r\n    }\r\n\r\n    renderCanvasCore(renderer: any): void\r\n    {\r\n        if (this.tileset.length === 0) return;\r\n        const points = this.pointsBuf;\r\n        const tileAnim = this.tileAnim || (renderer.plugins.tilemap && renderer.plugins.tilemap.tileAnim);\r\n\r\n        renderer.context.fillStyle = '#000000';\r\n        for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE)\r\n        {\r\n            let x1 = points[i + POINT_STRUCT.U];\r\n            let y1 = points[i + POINT_STRUCT.V];\r\n            const x2 = points[i + POINT_STRUCT.X];\r\n            const y2 = points[i + POINT_STRUCT.Y];\r\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\r\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\r\n\r\n            x1 += points[i + POINT_STRUCT.ANIM_X] * tileAnim[0];\r\n            y1 += points[i + POINT_STRUCT.ANIM_Y] * tileAnim[1];\r\n\r\n            const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\r\n            const alpha = points[i + POINT_STRUCT.ALPHA];\r\n\r\n            // canvas does not work with rotate yet\r\n\r\n            if (textureIndex >= 0 && this.tileset[textureIndex])\r\n            {\r\n                renderer.context.globalAlpha = alpha;\r\n                renderer.context.drawImage(\r\n                    (this.tileset[textureIndex] as any).getDrawableSource(),\r\n                    x1, y1, w, h, x2, y2, w, h\r\n                );\r\n            }\r\n            else\r\n            {\r\n                renderer.context.globalAlpha = 0.5;\r\n                renderer.context.fillRect(x2, y2, w, h);\r\n            }\r\n            renderer.context.globalAlpha = 1;\r\n        }\r\n    }\r\n\r\n    private vbId = 0;\r\n    private vb: TilemapGeometry = null;\r\n    private vbBuffer: ArrayBuffer = null;\r\n    private vbArray: Float32Array = null;\r\n    private vbInts: Uint32Array = null;\r\n\r\n    private destroyVb(): void\r\n    {\r\n        if (this.vb)\r\n        {\r\n            this.vb.destroy();\r\n            this.vb = null;\r\n        }\r\n    }\r\n\r\n    render(renderer: Renderer): void\r\n    {\r\n        const plugin = (renderer.plugins as any).tilemap;\r\n        const shader = plugin.getShader();\r\n\r\n        renderer.batch.setObjectRenderer(plugin);\r\n        this._globalMat = shader.uniforms.projTransMatrix;\r\n        renderer\r\n            .globalUniforms\r\n            .uniforms\r\n            .projectionMatrix\r\n            .copyTo(this._globalMat)\r\n            .append(this.worldTransform);\r\n\r\n        shader.uniforms.shadowColor = this.shadowColor;\r\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\r\n\r\n        this.renderWebGLCore(renderer, plugin);\r\n    }\r\n\r\n    renderWebGLCore(renderer: Renderer, plugin: TileRenderer): void\r\n    {\r\n        const points = this.pointsBuf;\r\n\r\n        if (points.length === 0) return;\r\n        const rectsCount = points.length / POINT_STRUCT_SIZE;\r\n\r\n        const shader = plugin.getShader();\r\n        const textures = this.tileset;\r\n\r\n        if (textures.length === 0) return;\r\n\r\n        plugin.bindTileTextures(renderer, textures);\r\n        renderer.shader.bind(shader, false);\r\n\r\n        // lost context! recover!\r\n        let vb = this.vb;\r\n\r\n        if (!vb)\r\n        {\r\n            vb = plugin.createVb();\r\n            this.vb = vb;\r\n            this.vbId = (vb as any).id;\r\n            this.vbBuffer = null;\r\n            this.modificationMarker = 0;\r\n        }\r\n\r\n        plugin.checkIndexBuffer(rectsCount, vb);\r\n        const boundCountPerBuffer = settings.TEXTILE_UNITS;\r\n\r\n        const vertexBuf = vb.getBuffer('aVertexPosition');\r\n        // if layer was changed, re-upload vertices\r\n        const vertices = rectsCount * vb.vertPerQuad;\r\n\r\n        if (vertices === 0) return;\r\n        if (this.modificationMarker !== vertices)\r\n        {\r\n            this.modificationMarker = vertices;\r\n            const vs = vb.stride * vertices;\r\n\r\n            if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\r\n            {\r\n                // !@#$ happens, need resize\r\n                let bk = vb.stride;\r\n\r\n                while (bk < vs)\r\n                {\r\n                    bk *= 2;\r\n                }\r\n                this.vbBuffer = new ArrayBuffer(bk);\r\n                this.vbArray = new Float32Array(this.vbBuffer);\r\n                this.vbInts = new Uint32Array(this.vbBuffer);\r\n                vertexBuf.update(this.vbBuffer);\r\n            }\r\n\r\n            const arr = this.vbArray;\r\n            // const ints = this.vbInts;\r\n            // upload vertices!\r\n            let sz = 0;\r\n            // let tint = 0xffffffff;\r\n            let textureId = 0;\r\n            let shiftU: number = this.offsetX;\r\n            let shiftV: number = this.offsetY;\r\n\r\n            // let tint = 0xffffffff;\r\n            // const tint = -1;\r\n\r\n            for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\r\n            {\r\n                const eps = 0.5;\r\n\r\n                if (this.compositeParent)\r\n                {\r\n                    const textureIndex = points[i + POINT_STRUCT.TEXTURE_INDEX];\r\n\r\n                    if (boundCountPerBuffer > 1)\r\n                    {\r\n                        // TODO: what if its more than 4?\r\n                        textureId = (textureIndex >> 2);\r\n                        shiftU = this.offsetX * (textureIndex & 1);\r\n                        shiftV = this.offsetY * ((textureIndex >> 1) & 1);\r\n                    }\r\n                    else\r\n                    {\r\n                        textureId = textureIndex;\r\n                        shiftU = 0;\r\n                        shiftV = 0;\r\n                    }\r\n                }\r\n                const x = points[i + POINT_STRUCT.X];\r\n                const y = points[i + POINT_STRUCT.Y];\r\n                const w = points[i + POINT_STRUCT.TILE_WIDTH];\r\n                const h = points[i + POINT_STRUCT.TILE_HEIGHT];\r\n                const u = points[i + POINT_STRUCT.U] + shiftU;\r\n                const v = points[i + POINT_STRUCT.V] + shiftV;\r\n                let rotate = points[i + POINT_STRUCT.ROTATE];\r\n\r\n                const animX = points[i + POINT_STRUCT.ANIM_X];\r\n                const animY = points[i + POINT_STRUCT.ANIM_Y];\r\n                const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\r\n                const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\r\n\r\n                const animXEncoded = animX + (animWidth * 2048);\r\n                const animYEncoded = animY + (animHeight * 2048);\r\n                const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\r\n                const alpha = points[i + POINT_STRUCT.ALPHA];\r\n\r\n                let u0: number;\r\n                let v0: number; let u1: number;\r\n                let v1: number; let u2: number;\r\n                let v2: number; let u3: number;\r\n                let v3: number;\r\n\r\n                if (rotate === 0)\r\n                {\r\n                    u0 = u;\r\n                    v0 = v;\r\n                    u1 = u + w;\r\n                    v1 = v;\r\n                    u2 = u + w;\r\n                    v2 = v + h;\r\n                    u3 = u;\r\n                    v3 = v + h;\r\n                }\r\n                else\r\n                {\r\n                    let w2 = w / 2;\r\n                    let h2 = h / 2;\r\n\r\n                    if (rotate % 4 !== 0)\r\n                    {\r\n                        w2 = h / 2;\r\n                        h2 = w / 2;\r\n                    }\r\n                    const cX = u + w2;\r\n                    const cY = v + h2;\r\n\r\n                    rotate = groupD8.add(rotate, groupD8.NW);\r\n                    u0 = cX + (w2 * groupD8.uX(rotate));\r\n                    v0 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\r\n                    u1 = cX + (w2 * groupD8.uX(rotate));\r\n                    v1 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2);\r\n                    u2 = cX + (w2 * groupD8.uX(rotate));\r\n                    v2 = cY + (h2 * groupD8.uY(rotate));\r\n\r\n                    rotate = groupD8.add(rotate, 2);\r\n                    u3 = cX + (w2 * groupD8.uX(rotate));\r\n                    v3 = cY + (h2 * groupD8.uY(rotate));\r\n                }\r\n\r\n                arr[sz++] = x;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u0;\r\n                arr[sz++] = v0;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u1;\r\n                arr[sz++] = v1;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u2;\r\n                arr[sz++] = v2;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n\r\n                arr[sz++] = x;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u3;\r\n                arr[sz++] = v3;\r\n                arr[sz++] = u + eps;\r\n                arr[sz++] = v + eps;\r\n                arr[sz++] = u + w - eps;\r\n                arr[sz++] = v + h - eps;\r\n                arr[sz++] = animXEncoded;\r\n                arr[sz++] = animYEncoded;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = animDivisor;\r\n                arr[sz++] = alpha;\r\n            }\r\n\r\n            vertexBuf.update(arr);\r\n        }\r\n\r\n        (renderer.geometry as any).bind(vb, shader);\r\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        if (this.modificationMarker !== this.pointsBuf.length\r\n            || (anim && this.hasAnimatedTile))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This will pull forward the modification marker.\r\n     *\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        this.modificationMarker = this.pointsBuf.length;\r\n    }\r\n\r\n    /** @override */\r\n    protected _calculateBounds(): void\r\n    {\r\n        const { minX, minY, maxX, maxY } = this.tilemapBounds;\r\n\r\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\r\n    }\r\n\r\n    /** @override */\r\n    public getLocalBounds(rect?: Rectangle): Rectangle\r\n    {\r\n        // we can do a fast local bounds if the sprite has no children!\r\n        if (this.children.length === 0)\r\n        {\r\n            return this.tilemapBounds.getRectangle(rect);\r\n        }\r\n\r\n        return super.getLocalBounds.call(this, rect);\r\n    }\r\n\r\n    /** @override */\r\n    destroy(options?: IDestroyOptions): void\r\n    {\r\n        super.destroy(options);\r\n        this.destroyVb();\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\r\n    {\r\n        this.tile(\r\n            texture,\r\n            x,\r\n            y,\r\n            {\r\n                animX,\r\n                animY,\r\n            }\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX = 0,\r\n        animY = 0,\r\n        rotate = 0,\r\n        animCountX = 1024,\r\n        animCountY = 1024,\r\n        animDivisor = 1,\r\n        alpha = 1,\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            textureIndex,\r\n            x, y,\r\n            {\r\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, alpha\r\n            }\r\n        );\r\n    }\r\n}\r\n","import { Container } from '@pixi/display';\r\nimport { Texture, Renderer, BaseTexture } from '@pixi/core';\r\nimport { Matrix } from '@pixi/math';\r\nimport { Tilemap } from './Tilemap';\r\nimport { settings } from './settings';\r\nimport { CanvasTileRenderer } from \"./CanvasTileRenderer\";\r\n\r\nimport type { TileRenderer } from './TileRenderer';\r\n\r\n/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */\r\nexport class CompositeTilemap extends Container\r\n{\r\n    /** The hard limit on the number of tile textures used in each tilemap. */\r\n    public readonly texturesPerTilemap: number;\r\n\r\n    /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */\r\n    public tileAnim: [number, number] = null;\r\n\r\n    /** The last modified tilemap. */\r\n    protected lastModifiedTilemap: Tilemap = null;\r\n\r\n    private modificationMarker = 0;\r\n    private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    private _globalMat: Matrix = null;\r\n\r\n    /**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */\r\n    constructor(tileset?: Array<BaseTexture>)\r\n    {\r\n        super();\r\n\r\n        this.tileset(tileset);\r\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\r\n    }\r\n\r\n    /**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */\r\n    tileset(tileTextures: Array<BaseTexture>): this\r\n    {\r\n        if (!tileTextures)\r\n        {\r\n            tileTextures = [];\r\n        }\r\n\r\n        const texPerChild = this.texturesPerTilemap;\r\n        const len1 = this.children.length;\r\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\r\n\r\n        for (let i = 0; i < Math.min(len1, len2); i++)\r\n        {\r\n            (this.children[i] as Tilemap).setTileset(\r\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\r\n            );\r\n        }\r\n        for (let i = len1; i < len2; i++)\r\n        {\r\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\r\n\r\n            tilemap.compositeParent = true;\r\n            tilemap.offsetX = settings.TEXTILE_DIMEN;\r\n            tilemap.offsetY = settings.TEXTILE_DIMEN;\r\n\r\n            // TODO: Don't use children\r\n            this.addChild(tilemap);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Clears the tilemap composite. */\r\n    clear(): this\r\n    {\r\n        for (let i = 0; i < this.children.length; i++)\r\n        {\r\n            (this.children[i] as Tilemap).clear();\r\n        }\r\n\r\n        this.modificationMarker = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last added tile. */\r\n    tileRotate(rotate: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileRotate(rotate);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animX`, `animCountX` of the last added tile. */\r\n    tileAnimX(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimX(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animY`, `animCountY` of the last added tile. */\r\n    tileAnimY(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimY(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `tileAnimDivisor` value of the last added tile. */\r\n    tileAnimDivisor(divisor: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            alpha?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let tilemap: Tilemap = null;\r\n        const children = this.children;\r\n\r\n        this.lastModifiedTilemap = null;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\r\n            let tileIndex  = 0;\r\n\r\n            tilemap = children[childIndex] as Tilemap;\r\n\r\n            if (!tilemap)\r\n            {\r\n                tilemap = children[0] as Tilemap;\r\n\r\n                // Silently fail if the tilemap doesn't exist\r\n                if (!tilemap) return this;\r\n\r\n                tileIndex = 0;\r\n            }\r\n            else\r\n            {\r\n                tileIndex = tileTexture % this.texturesPerTilemap;\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileIndex,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                tileTexture = Texture.from(tileTexture);\r\n            }\r\n\r\n            // Probe all tilemaps to find which tileset contains the base-texture.\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                const child = children[i] as Tilemap;\r\n                const tex = child.getTileset();\r\n\r\n                for (let j = 0; j < tex.length; j++)\r\n                {\r\n                    if (tex[j] === tileTexture.baseTexture)\r\n                    {\r\n                        tilemap = child;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (tilemap)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If no tileset contains the base-texture, attempt to add it.\r\n            if (!tilemap)\r\n            {\r\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\r\n                for (let i = children.length - 1; i >= 0; i--)\r\n                {\r\n                    const child = children[i] as Tilemap;\r\n\r\n                    if (child.getTileset().length < this.texturesPerTilemap)\r\n                    {\r\n                        tilemap = child;\r\n                        child.getTileset().push(tileTexture.baseTexture);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Otherwise, create a new tilemap initialized with that tile texture.\r\n                if (!tilemap)\r\n                {\r\n                    tilemap = new Tilemap(tileTexture.baseTexture);\r\n                    tilemap.compositeParent = true;\r\n                    tilemap.offsetX = settings.TEXTILE_DIMEN;\r\n                    tilemap.offsetY = settings.TEXTILE_DIMEN;\r\n\r\n                    this.addChild(tilemap);\r\n                }\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileTexture,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n\r\n        this.lastModifiedTilemap = tilemap;\r\n\r\n        return this;\r\n    }\r\n\r\n    renderCanvas(renderer: any): void\r\n    {\r\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const tilemapPlugin = CanvasTileRenderer.getInstance(renderer)\r\n\r\n        if (tilemapPlugin && !tilemapPlugin.dontUseTransform)\r\n        {\r\n            const wt = this.worldTransform;\r\n\r\n            renderer.context.setTransform(\r\n                wt.a,\r\n                wt.b,\r\n                wt.c,\r\n                wt.d,\r\n                wt.tx * renderer.resolution,\r\n                wt.ty * renderer.resolution\r\n            );\r\n        }\r\n\r\n        const layers = this.children;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = (layers[i] as Tilemap);\r\n\r\n            layer.tileAnim = this.tileAnim;\r\n            layer.renderCanvasCore(renderer);\r\n        }\r\n    }\r\n\r\n    render(renderer: Renderer): void\r\n    {\r\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const plugin = renderer.plugins.tilemap as TileRenderer;\r\n        const shader = plugin.getShader();\r\n\r\n        renderer.batch.setObjectRenderer(plugin);\r\n\r\n        // TODO: dont create new array, please\r\n        this._globalMat = shader.uniforms.projTransMatrix;\r\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\r\n        shader.uniforms.shadowColor = this.shadowColor;\r\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\r\n\r\n        renderer.shader.bind(shader, false);\r\n\r\n        const layers = this.children;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).renderWebGLCore(renderer, plugin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        const layers = this.children;\r\n\r\n        if (this.modificationMarker !== layers.length)\r\n        {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            if ((layers[i] as Tilemap).isModified(anim))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        const layers = this.children;\r\n\r\n        this.modificationMarker = layers.length;\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).clearModify();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    addFrame(\r\n        texture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        animWidth?: number,\r\n        animHeight?: number,\r\n        animDivisor?: number,\r\n        alpha?: number\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            texture,\r\n            x, y,\r\n            {\r\n                animX,\r\n                animY,\r\n                animCountX: animWidth,\r\n                animCountY: animHeight,\r\n                animDivisor,\r\n                alpha\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        rotate?: number,\r\n        animWidth?: number,\r\n        animHeight?: number\r\n    ): this\r\n    {\r\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\r\n        const textureId: number = textureIndex % this.texturesPerTilemap;\r\n\r\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset())\r\n        {\r\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\r\n            this.lastModifiedTilemap.addRect(\r\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\r\n            );\r\n        }\r\n        else\r\n        {\r\n            this.lastModifiedTilemap = null;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    setBitmaps = this.tileset;\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */\r\n    get texPerChild(): number { return this.texturesPerTilemap; }\r\n}\r\n","import { ALPHA_MODES } from '@pixi/constants';\r\nimport { BaseTexture, Renderer, Resource, Texture, GLTexture } from '@pixi/core';\r\nimport { settings } from './settings';\r\n\r\nexport interface TextileOptions\r\n{\r\n\tTEXTILE_DIMEN: number;\r\n\tTEXTILE_UNITS: number;\r\n\tDO_CLEAR?: boolean;\r\n}\r\n\r\ntype TextureTile = {\r\n\tdirtyId: number;\r\n\tx: number;\r\n\ty: number;\r\n\tbaseTexture: BaseTexture;\r\n};\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable indent */\r\n\r\n/**\r\n * This texture tiling resource can be used to upload multiple base-textures together.\r\n *\r\n * This resource combines multiple base-textures into a \"textile\". They're laid out in\r\n * a dual column format, placed in row-order order. The size of each tile is predefined,\r\n * and defaults to {@link settings.TEXTILE_DIMEN}. This means that each input base-texture\r\n * must is smaller than that along both its width and height.\r\n *\r\n * @see settings.TEXTILE_UNITS\r\n */\r\nexport class TextileResource extends Resource\r\n{\r\n\t/** The base-texture that contains all the texture tiles. */\r\n\tpublic baseTexture: BaseTexture = null;\r\n\r\n\tprivate readonly doClear: boolean;\r\n\tprivate readonly tileDimen: number;\r\n\tprivate readonly tiles: Array<TextureTile>;\r\n\r\n\tprivate _clearBuffer: Uint8Array = null;\r\n\r\n\t/**\r\n\t * @param options - This will default to the \"settings\" exported by @pixi/tilemap.\r\n\t * @param options.TEXTILE_DIMEN - The dimensions of each tile.\r\n\t * @param options.TEXTILE_UNITS - The number of texture tiles.\r\n\t */\r\n\tconstructor(options: TextileOptions = settings)\r\n\t{\r\n\t\tsuper(\r\n\t\t\toptions.TEXTILE_DIMEN * 2,\r\n\t\t\toptions.TEXTILE_DIMEN * Math.ceil(options.TEXTILE_UNITS / 2),\r\n\t\t);\r\n\r\n\t\tconst tiles: TextureTile[] = this.tiles = new Array(options.TEXTILE_UNITS);\r\n\r\n\t\tthis.doClear = !!options.DO_CLEAR;\r\n\t\tthis.tileDimen = options.TEXTILE_DIMEN;\r\n\r\n\t\tfor (let j = 0; j < options.TEXTILE_UNITS; j++)\r\n\t\t{\r\n\t\t\ttiles[j] = {\r\n\t\t\t\tdirtyId: 0,\r\n\t\t\t\tx: options.TEXTILE_DIMEN * (j & 1),\r\n\t\t\t\ty: options.TEXTILE_DIMEN * (j >> 1),\r\n\t\t\t\tbaseTexture: Texture.WHITE.baseTexture,\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the texture to be uploaded for the given tile.\r\n\t *\r\n\t * @param index - The index of the tile being set.\r\n\t * @param texture - The texture with the base-texture to upload.\r\n\t */\r\n\ttile(index: number, texture: BaseTexture): void\r\n\t{\r\n\t\tconst tile = this.tiles[index];\r\n\r\n\t\tif (tile.baseTexture === texture)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttile.baseTexture = texture;\r\n\t\tthis.baseTexture.update();\r\n\r\n\t\tthis.tiles[index].dirtyId = (this.baseTexture as any).dirtyId;\r\n\t}\r\n\r\n\t/** @override */\r\n\tbind(baseTexture: BaseTexture): void\r\n\t{\r\n\t\tif (this.baseTexture)\r\n\t\t{\r\n\t\t\tthrow new Error('Only one baseTexture is allowed for this resource!');\r\n\t\t}\r\n\r\n\t\tthis.baseTexture = baseTexture;\r\n\t\tsuper.bind(baseTexture);\r\n\t}\r\n\r\n\t/** @override */\r\n\tupload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\r\n\t{\r\n\t\tconst { gl } = renderer;\r\n\t\tconst { width, height } = this;\r\n\r\n\t\tgl.pixelStorei(\r\n\t\t\tgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\r\n\t\t\ttexture.alphaMode === undefined || texture.alphaMode === ALPHA_MODES.UNPACK\r\n\t\t);\r\n\r\n\t\tif (glTexture.dirtyId < 0)\r\n\t\t{\r\n\t\t\t(glTexture as any).width = width;\r\n\t\t\t(glTexture as any).height = height;\r\n\r\n\t\t\tgl.texImage2D(texture.target, 0,\r\n\t\t\t\ttexture.format,\r\n\t\t\t\twidth,\r\n\t\t\t\theight,\r\n\t\t\t\t0,\r\n\t\t\t\ttexture.format,\r\n\t\t\t\ttexture.type,\r\n\t\t\t\tnull);\r\n\t\t}\r\n\r\n\t\tconst doClear = this.doClear;\r\n\t\tconst tiles = this.tiles;\r\n\r\n\t\tif (doClear && !this._clearBuffer)\r\n\t\t{\r\n\t\t\tthis._clearBuffer = new Uint8Array(settings.TEXTILE_DIMEN * settings.TEXTILE_DIMEN * 4);\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < tiles.length; i++)\r\n\t\t{\r\n\t\t\tconst spr = tiles[i];\r\n\t\t\tconst tex = spr.baseTexture;\r\n\r\n\t\t\tif (glTexture.dirtyId >= this.tiles[i].dirtyId)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst res = tex.resource as any;\r\n\r\n\t\t\tif (!tex.valid || !res || !res.source)\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (doClear && (tex.width < this.tileDimen || tex.height < this.tileDimen))\r\n\t\t\t{\r\n\t\t\t\tgl.texSubImage2D(texture.target, 0,\r\n\t\t\t\t\tspr.x,\r\n\t\t\t\t\tspr.y,\r\n\t\t\t\t\tthis.tileDimen,\r\n\t\t\t\t\tthis.tileDimen,\r\n\t\t\t\t\ttexture.format,\r\n\t\t\t\t\ttexture.type,\r\n\t\t\t\t\tthis._clearBuffer);\r\n\t\t\t}\r\n\r\n\t\t\tgl.texSubImage2D(texture.target, 0,\r\n\t\t\t\tspr.x,\r\n\t\t\t\tspr.y,\r\n\t\t\t\ttexture.format,\r\n\t\t\t\ttexture.type,\r\n\t\t\t\tres.source);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n","import type { TilemapShader } from './TilemapShader';\r\n\r\n/**\r\n * This will generate fragment shader code that samples the correct texture into the \"color\" variable.\r\n *\r\n * @internal\r\n * @ignore\r\n * @param maxTextures - The texture array length in the shader's uniforms.\r\n */\r\nfunction generateSampleSrc(maxTextures: number): string\r\n{\r\n    let src = '';\r\n\r\n    src += '\\n';\r\n    src += '\\n';\r\n\r\n    src += 'if(vTextureId <= -1.0) {';\r\n    src += '\\n\\tcolor = shadowColor;';\r\n    src += '\\n}';\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        src += '\\nelse ';\r\n\r\n        if (i < maxTextures - 1)\r\n        {\r\n            src += `if(textureId == ${i}.0)`;\r\n        }\r\n\r\n        src += '\\n{';\r\n        src += `\\n\\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;\r\n        src += '\\n}';\r\n    }\r\n\r\n    src += '\\n';\r\n    src += '\\n';\r\n\r\n    return src;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param shader\r\n * @param maxTextures\r\n */\r\nexport function fillSamplers(shader: TilemapShader, maxTextures: number): void\r\n{\r\n    const sampleValues: Array<number> = [];\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        sampleValues[i] = i;\r\n    }\r\n\r\n    shader.uniforms.uSamplers = sampleValues;\r\n\r\n    const samplerSize: Array<number> = [];\r\n\r\n    for (let i = 0; i < maxTextures; i++)\r\n    {\r\n        // These are overwritten by TileRenderer when textures actually bound.\r\n        samplerSize.push(1.0 / 2048);\r\n        samplerSize.push(1.0 / 2048);\r\n    }\r\n\r\n    shader.uniforms.uSamplerSize = samplerSize;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param maxTextures\r\n * @param fragmentSrc\r\n * @returns\r\n */\r\nexport function generateFragmentSrc(maxTextures: number, fragmentSrc: string): string\r\n{\r\n    return fragmentSrc.replace(/%count%/gi, `${maxTextures}`)\r\n        .replace(/%forloop%/gi, generateSampleSrc(maxTextures));\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\r\n///<reference path=\"../global.d.ts\" />\r\n\r\nimport * as shaderGenerator from './shaderGenerator';\r\n\r\nconst tilemapVertexTemplateSrc = `#version 100\r\nprecision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aFrame;\r\nattribute vec2 aAnim;\r\nattribute float aAnimDivisor;\r\nattribute float aTextureId;\r\nattribute float aAlpha;\r\n\r\nuniform mat3 projTransMatrix;\r\nuniform vec2 animationFrame;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vFrame;\r\nvarying float vAlpha;\r\n\r\nvoid main(void)\r\n{\r\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\r\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\r\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\r\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\r\n\r\n   vTextureCoord = aTextureCoord + animOffset;\r\n   vFrame = aFrame + vec4(animOffset, animOffset);\r\n   vTextureId = aTextureId;\r\n   vAlpha = aAlpha;\r\n}\r\n`;\r\n\r\nconst tilemapFragmentTemplateSrc = `#version 100\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vFrame;\r\nvarying float vTextureId;\r\nvarying float vAlpha;\r\nuniform vec4 shadowColor;\r\nuniform sampler2D uSamplers[%count%];\r\nuniform vec2 uSamplerSize[%count%];\r\n\r\nvoid main(void)\r\n{\r\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n   float textureId = floor(vTextureId + 0.5);\r\n\r\n   vec4 color;\r\n   %forloop%\r\n   gl_FragColor = color * vAlpha;\r\n}\r\n`;\r\n\r\nimport { Buffer, Geometry, Shader, Program } from '@pixi/core';\r\nimport { Matrix } from '@pixi/math';\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport class TilemapShader extends Shader\r\n{\r\n\tmaxTextures = 0;\r\n\r\n\tconstructor(maxTextures: number)\r\n\t{\r\n\t    super(\r\n\t        new Program(\r\n\t\t\t\ttilemapVertexTemplateSrc,\r\n\t\t\t\tshaderGenerator.generateFragmentSrc(maxTextures, tilemapFragmentTemplateSrc)\r\n\t\t\t),\r\n\t        {\r\n\t            animationFrame: new Float32Array(2),\r\n\t            uSamplers: [],\r\n\t            uSamplerSize: [],\r\n\t            projTransMatrix: new Matrix()\r\n\t        }\r\n\t    );\r\n\r\n\t    this.maxTextures = maxTextures;\r\n\t    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n\t}\r\n}\r\n\r\nexport class TilemapGeometry extends Geometry\r\n{\r\n\tvertSize = 13;\r\n\tvertPerQuad = 4;\r\n\tstride = this.vertSize * 4;\r\n\tlastTimeAccess = 0;\r\n\r\n\tconstructor()\r\n\t{\r\n\t    super();\r\n\r\n\t    const buf = this.buf = new Buffer(new Float32Array(2), true, false);\r\n\r\n\t    this.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0)\r\n\t        .addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4)\r\n\t        .addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4)\r\n\t        .addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4)\r\n\t        .addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4)\r\n            .addAttribute('aAnimDivisor', buf, 0, false, 0, this.stride, 11 * 4)\r\n            .addAttribute('aAlpha', buf, 0, false, 0, this.stride, 12 * 4);\r\n\t}\r\n\r\n\tbuf: Buffer;\r\n}\r\n","import { WRAP_MODES } from '@pixi/constants';\r\nimport { BaseTexture, Buffer, ObjectRenderer, Renderer } from '@pixi/core';\r\nimport { settings } from './settings';\r\nimport { TilemapGeometry, TilemapShader } from './TilemapShader';\r\nimport { TextileResource } from './TextileResource';\r\nimport * as utils from '@pixi/utils';\r\n\r\n// For some reason ESLint goes mad with indendation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\n/**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */\r\nexport class TileRenderer extends ObjectRenderer\r\n{\r\n\t/** The managing renderer */\r\n\tpublic readonly renderer: Renderer;\r\n\r\n\t/** The tile animation frame */\r\n\tpublic tileAnim = [0, 0];\r\n\r\n\tprivate ibLen = 0;// index buffer length\r\n\r\n\t/** The index buffer for the tilemaps to share. */\r\n\tprivate indexBuffer: Buffer = null;\r\n\r\n\t/** The shader used to render tilemaps. */\r\n\tprivate shader: TilemapShader;\r\n\r\n\t/**\r\n\t * {@link TextileResource} instances used to upload textures batched in tiled groups. This is\r\n\t * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.\r\n\t */\r\n\tprivate textiles: Array<TextileResource> = [];\r\n\r\n\t/** @param renderer - The managing renderer */\r\n\tconstructor(renderer: Renderer)\r\n\t{\r\n\t    super(renderer);\r\n\r\n\t    this.shader = new TilemapShader(settings.TEXTURES_PER_TILEMAP);\r\n\t    this.indexBuffer = new Buffer(undefined, true, true);\r\n\t    this.checkIndexBuffer(2000);\r\n\t    this.makeTextiles();\r\n\t}\r\n\r\n\t/**\r\n\t * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.\r\n\t *\r\n\t * If {@link settings.TEXTILE_UNITS}\r\n\t *\r\n\t * @param renderer - The renderer to which the textures are to be bound.\r\n\t * @param textures - The tile textures being bound.\r\n\t */\r\n\tbindTileTextures(renderer: Renderer, textures: Array<BaseTexture>): void\r\n\t{\r\n\t    const len = textures.length;\r\n\t\tconst shader = this.shader;\r\n\t    const maxTextures = settings.TEXTURES_PER_TILEMAP;\r\n\t\tconst samplerSize: Array<number> = shader.uniforms.uSamplerSize;\r\n\r\n\t    if (len > settings.TEXTILE_UNITS * maxTextures)\r\n\t    {\r\n\t\t\t// TODO: Show error message instead of silently failing!\r\n\t        return;\r\n\t    }\r\n\r\n\t\tif (settings.TEXTILE_UNITS <= 1)\r\n\t    {\r\n\t\t\t// Bind each texture directly & update samplerSize.\r\n\t\t\tfor (let i = 0; i < textures.length; i++)\r\n\t\t\t{\r\n\t\t\t\tconst texture = textures[i];\r\n\r\n\t\t\t\tif (!texture || !texture.valid)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\trenderer.texture.bind(textures[i], i);\r\n\r\n\t\t\t\tsamplerSize[i * 2] = 1.0 / textures[i].realWidth;\r\n\t\t\t\tsamplerSize[(i * 2) + 1] = 1.0 / textures[i].realHeight;\r\n\t\t\t}\r\n\t    }\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Ensure we have enough textiles, in case settings.TEXTILE_UNITS was modified.\r\n\t\t\tthis.makeTextiles();\r\n\r\n\t\t\tconst usedTextiles = Math.ceil(len / settings.TEXTILE_UNITS);\r\n\r\n\t\t\t// First ensure each textile has all tiles point to the right textures.\r\n\t\t\tfor (let i = 0; i < len; i++)\r\n\t\t\t{\r\n\t\t\t\tconst texture = textures[i];\r\n\r\n\t\t\t\tif (texture && texture.valid)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst resourceIndex = Math.floor(i / settings.TEXTILE_UNITS);\r\n\t\t\t\t\tconst tileIndex = i % settings.TEXTILE_UNITS;\r\n\r\n\t\t\t\t\tthis.textiles[resourceIndex].tile(tileIndex, texture);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Then bind the textiles + update samplerSize.\r\n\t\t\tfor (let i = 0; i < usedTextiles; i++)\r\n\t\t\t{\r\n\t\t\t\trenderer.texture.bind(this.textiles[i].baseTexture, i);\r\n\r\n\t\t\t\tsamplerSize[i * 2] = 1.0 / this.textiles[i].width;\r\n\t\t\t\tsamplerSize[(i * 2) + 1] = 1.0 / this.textiles[i].baseTexture.height;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tshader.uniforms.uSamplerSize = samplerSize;\r\n\t}\r\n\r\n\tstart(): void\r\n\t{\r\n\t    // sorry, nothing\r\n\t}\r\n\r\n\t/**\r\n\t * @internal\r\n\t * @ignore\r\n\t */\r\n\tcreateVb(): TilemapGeometry\r\n\t{\r\n\t    const geom = new TilemapGeometry();\r\n\r\n\t    geom.addIndex(this.indexBuffer);\r\n\t    geom.lastTimeAccess = Date.now();\r\n\r\n\t    return geom;\r\n\t}\r\n\r\n\t/** @return The {@link TilemapShader} shader that this rendering pipeline is using. */\r\n\tgetShader(): TilemapShader { return this.shader; }\r\n\r\n\tdestroy(): void\r\n\t{\r\n\t    super.destroy();\r\n\t    // this.rectShader.destroy();\r\n\t    this.shader = null;\r\n\t}\r\n\r\n\tpublic checkIndexBuffer(size: number, _vb: TilemapGeometry = null): void\r\n\t{\r\n\t    const totalIndices = size * 6;\r\n\r\n\t    if (totalIndices <= this.ibLen)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    let len = totalIndices;\r\n\r\n\t    while (len < totalIndices)\r\n\t    {\r\n\t        len <<= 1;\r\n\t    }\r\n\r\n\t    this.ibLen = totalIndices;\r\n\t    this.indexBuffer.update(utils.createIndicesForQuads(size,\r\n\t        settings.use32bitIndex ? new Uint32Array(size * 6) : undefined));\r\n\r\n\t    // \tTODO: create new index buffer instead?\r\n\t    // if (vb) {\r\n\t    // \tconst curIndex = vb.getIndex();\r\n\t    // \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\r\n\t    // \t\tthis.swapIndex(vb, this.indexBuffer);\r\n\t    // \t}\r\n\t    // }\r\n\t}\r\n\r\n\t/** Makes textile resources and initializes {@link TileRenderer.textiles}. */\r\n\tprivate makeTextiles(): void\r\n\t{\r\n\t    if (settings.TEXTILE_UNITS <= 1)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    for (let i = 0; i < settings.TEXTILE_UNITS; i++)\r\n\t    {\r\n\t\t\tif (this.textiles[i]) continue;\r\n\r\n\t\t\tconst resource = new TextileResource();\r\n\t        const baseTex = new BaseTexture(resource);\r\n\r\n\t        baseTex.scaleMode = settings.TEXTILE_SCALE_MODE;\r\n\t        baseTex.wrapMode = WRAP_MODES.CLAMP;\r\n\r\n\t\t\tthis.textiles[i] = resource;\r\n\t    }\r\n\t}\r\n}\r\n","import { CanvasTileRenderer } from './CanvasTileRenderer';\r\nimport { CompositeTilemap } from './CompositeTilemap';\r\nimport { Constant } from './settings';\r\nimport { TextileResource } from './TextileResource';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapShader, TilemapGeometry } from './TilemapShader';\r\nimport { TileRenderer } from './TileRenderer';\r\n\r\n// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\r\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nimport * as constants from '@pixi/constants';\r\nimport {Renderer} from \"@pixi/core\";\r\n\r\n// eslint-disable-next-line camelcase\r\nexport const pixi_tilemap = {\r\n    CanvasTileRenderer,\r\n    CompositeRectTileLayer: CompositeTilemap,\r\n    CompositeTilemap,\r\n    Constant,\r\n    TextileResource,\r\n    MultiTextureResource: TextileResource,\r\n    RectTileLayer: Tilemap,\r\n    Tilemap,\r\n    TilemapShader,\r\n    TilemapGeometry,\r\n    RectTileShader: TilemapShader,\r\n    RectTileGeom: TilemapGeometry,\r\n    TileRenderer,\r\n};\r\n\r\nexport * from './CanvasTileRenderer';\r\nexport * from './CompositeTilemap';\r\nexport * from './settings';\r\nexport * from './TextileResource';\r\nexport * from './Tilemap';\r\nexport * from './TilemapShader';\r\nexport * from './shaderGenerator';\r\nexport * from './TileRenderer';\r\n\r\nexport { CompositeTilemap as CompositeRectTileLayer } from './CompositeTilemap';\r\nexport { Tilemap as RectTileLayer } from './Tilemap';\r\n\r\nRenderer.registerPlugin('tilemap', TileRenderer as any);\r\n"]},"metadata":{},"sourceType":"module"}