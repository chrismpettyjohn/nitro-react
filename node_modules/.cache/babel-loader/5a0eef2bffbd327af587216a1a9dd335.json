{"ast":null,"code":"import { SpriteUtilities } from '../../../../../room/utils/SpriteUtilities';\nimport { ColorData } from './ColorData';\nimport { DirectionData } from './DirectionData';\nimport { LayerData } from './LayerData';\nexport class SizeData {\n  constructor(layerCount, angle) {\n    this._layerCount = void 0;\n    this._angle = void 0;\n    this._defaultDirection = void 0;\n    this._directions = void 0;\n    this._colors = void 0;\n    this._lastDirectionData = void 0;\n    this._lastDirection = void 0;\n    this._layerCount = layerCount < 0 ? 0 : layerCount > SizeData.MAX_LAYERS ? SizeData.MAX_LAYERS : layerCount;\n    this._angle = angle < 1 ? 1 : angle > 360 ? 360 : angle;\n    this._defaultDirection = new DirectionData(this._layerCount);\n    this._directions = new Map();\n    this._colors = [];\n    this._lastDirectionData = null;\n    this._lastDirection = -1;\n  }\n\n  dispose() {\n    if (this._defaultDirection) this._defaultDirection.dispose();\n\n    for (const direction of this._directions.values()) {\n      if (!direction) continue;\n      direction.dispose();\n    }\n\n    for (const color of this._colors) {\n      if (!color) continue;\n      color.dispose();\n    }\n\n    this.reset();\n  }\n\n  reset() {\n    this._defaultDirection = null;\n    this._colors = [];\n    this._lastDirectionData = null;\n    this._lastDirection = -1;\n\n    this._directions.clear();\n  }\n\n  processLayers(layers) {\n    if (!layers) return false;\n    return this.setDirectionLayers(this._defaultDirection, layers);\n  }\n\n  processDirections(directions) {\n    if (!directions) return false;\n\n    for (const key in directions) {\n      const direction = directions[key];\n      if (!direction) continue;\n      const directionNumber = parseInt(key);\n      if (this._directions.get(directionNumber)) return false;\n      const directionData = new DirectionData(this._layerCount);\n      directionData.setFromDirection(this._defaultDirection);\n      this.setDirectionLayers(directionData, direction.layers);\n\n      this._directions.set(directionNumber, directionData);\n\n      this._lastDirectionData = null;\n      this._lastDirection = -1;\n    }\n\n    return true;\n  }\n\n  processColors(colors) {\n    if (!colors) return false;\n\n    for (const key in colors) {\n      const color = colors[key];\n      if (!color) continue;\n      const colorNumber = parseInt(key);\n      if (this._colors[colorNumber]) return false;\n      const colorData = new ColorData(this._layerCount);\n\n      for (const layer in color.layers) {\n        const colorLayer = color.layers[layer];\n        if (!colorLayer) continue;\n        const layerId = parseInt(layer);\n        const colorId = colorLayer.color;\n        colorData.setColorLayer(layerId, colorId);\n      }\n\n      this._colors[colorNumber] = colorData;\n    }\n\n    return true;\n  }\n\n  setDirectionLayers(directionData, layers) {\n    if (!directionData || !layers) return false;\n\n    for (const key in layers) {\n      const layer = layers[key];\n      if (!layer) continue;\n      const layerId = parseInt(key);\n      if (layerId < 0 || layerId >= this._layerCount) return false;\n      if (layer.ink !== undefined) directionData.setLayerInk(layerId, SpriteUtilities.inkToBlendMode(layer.ink));\n      if (layer.tag !== undefined) directionData.setLayerTag(layerId, layer.tag);\n      if (layer.alpha !== undefined) directionData.setLayerAlpha(layerId, layer.alpha);\n      if (layer.ignoreMouse !== undefined) directionData.setLayerIgnoreMouse(layerId, layer.ignoreMouse);\n      if (layer.x !== undefined) directionData.setLayerXOffset(layerId, layer.x);\n      if (layer.y !== undefined) directionData.setLayerYOffset(layerId, layer.y);\n      if (layer.z !== undefined) directionData.setLayerZOffset(layerId, layer.z / -1000);\n    }\n\n    return true;\n  }\n\n  getValidDirection(direction) {\n    const existing = this._directions.get(direction);\n\n    if (existing) return direction;\n    direction = (direction % 360 + 360) % 360;\n    let currentAngle = -1;\n    let validDirection = -1;\n\n    for (const key of this._directions.keys()) {\n      let angle = (key * this._angle - direction + 360) % 360;\n      if (angle > 180) angle = 360 - angle;\n\n      if (angle < currentAngle || currentAngle < 0) {\n        currentAngle = angle;\n        validDirection = key;\n      }\n    }\n\n    if (validDirection >= 0) return Math.trunc(validDirection);\n    return 0;\n  }\n\n  getDirectionData(direction) {\n    if (direction === this._lastDirection && this._lastDirectionData) return this._lastDirectionData;\n\n    let directionData = this._directions.get(direction);\n\n    if (!directionData) directionData = this._defaultDirection;\n    this._lastDirection = direction;\n    this._lastDirectionData = directionData;\n    return this._lastDirectionData;\n  }\n\n  getLayerTag(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_TAG;\n    return directionData.getLayerTag(layerId);\n  }\n\n  getLayerInk(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_INK;\n    return directionData.getLayerInk(layerId);\n  }\n\n  getLayerAlpha(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_ALPHA;\n    return directionData.getLayerAlpha(layerId);\n  }\n\n  getLayerColor(layerId, colorId) {\n    const existing = this._colors[colorId];\n    if (!existing) return ColorData.DEFAULT_COLOR;\n    return existing.getLayerColor(layerId);\n  }\n\n  getLayerIgnoreMouse(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_IGNORE_MOUSE;\n    return directionData.getLayerIgnoreMouse(layerId);\n  }\n\n  getLayerXOffset(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_XOFFSET;\n    return directionData.getLayerXOffset(layerId);\n  }\n\n  getLayerYOffset(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_YOFFSET;\n    return directionData.getLayerYOffset(layerId);\n  }\n\n  getLayerZOffset(direction, layerId) {\n    const directionData = this.getDirectionData(direction);\n    if (!directionData) return LayerData.DEFAULT_ZOFFSET;\n    return directionData.getLayerZOffset(layerId);\n  }\n\n  get layerCount() {\n    return this._layerCount;\n  }\n\n}\nSizeData.MAX_LAYERS = 26;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/data/SizeData.ts"],"names":["SpriteUtilities","ColorData","DirectionData","LayerData","SizeData","constructor","layerCount","angle","_layerCount","_angle","_defaultDirection","_directions","_colors","_lastDirectionData","_lastDirection","MAX_LAYERS","Map","dispose","direction","values","color","reset","clear","processLayers","layers","setDirectionLayers","processDirections","directions","key","directionNumber","parseInt","get","directionData","setFromDirection","set","processColors","colors","colorNumber","colorData","layer","colorLayer","layerId","colorId","setColorLayer","ink","undefined","setLayerInk","inkToBlendMode","tag","setLayerTag","alpha","setLayerAlpha","ignoreMouse","setLayerIgnoreMouse","x","setLayerXOffset","y","setLayerYOffset","z","setLayerZOffset","getValidDirection","existing","currentAngle","validDirection","keys","Math","trunc","getDirectionData","getLayerTag","DEFAULT_TAG","getLayerInk","DEFAULT_INK","getLayerAlpha","DEFAULT_ALPHA","getLayerColor","DEFAULT_COLOR","getLayerIgnoreMouse","DEFAULT_IGNORE_MOUSE","getLayerXOffset","DEFAULT_XOFFSET","getLayerYOffset","DEFAULT_YOFFSET","getLayerZOffset","DEFAULT_ZOFFSET"],"mappings":"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","sourcesContent":["import { IAssetColor, IAssetVisualizationDirection, IAssetVisualizationLayer } from '../../../../../core/asset/interfaces/visualization';\r\nimport { SpriteUtilities } from '../../../../../room/utils/SpriteUtilities';\r\nimport { ColorData } from './ColorData';\r\nimport { DirectionData } from './DirectionData';\r\nimport { LayerData } from './LayerData';\r\n\r\nexport class SizeData\r\n{\r\n    public static MAX_LAYERS: number = 26;\r\n\r\n    private _layerCount: number;\r\n    private _angle: number;\r\n\r\n    private _defaultDirection: DirectionData;\r\n    private _directions: Map<number, DirectionData>;\r\n    private _colors: ColorData[];\r\n    private _lastDirectionData: DirectionData;\r\n    private _lastDirection: number;\r\n\r\n    constructor(layerCount: number, angle: number)\r\n    {\r\n        this._layerCount = ((layerCount < 0) ? 0 : ((layerCount > SizeData.MAX_LAYERS) ? SizeData.MAX_LAYERS : layerCount));\r\n        this._angle = angle < 1 ? 1 : angle > 360 ? 360 : angle;\r\n\r\n        this._defaultDirection = new DirectionData(this._layerCount);\r\n        this._directions = new Map();\r\n        this._colors = [];\r\n        this._lastDirectionData = null;\r\n        this._lastDirection = -1;\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        if(this._defaultDirection) this._defaultDirection.dispose();\r\n\r\n        for(const direction of this._directions.values())\r\n        {\r\n            if(!direction) continue;\r\n\r\n            direction.dispose();\r\n        }\r\n\r\n        for(const color of this._colors)\r\n        {\r\n            if(!color) continue;\r\n\r\n            color.dispose();\r\n        }\r\n\r\n        this.reset();\r\n    }\r\n\r\n    protected reset(): void\r\n    {\r\n        this._defaultDirection = null;\r\n        this._colors = [];\r\n        this._lastDirectionData = null;\r\n        this._lastDirection = -1;\r\n\r\n        this._directions.clear();\r\n    }\r\n\r\n    public processLayers(layers: { [index: string]: IAssetVisualizationLayer }): boolean\r\n    {\r\n        if(!layers) return false;\r\n\r\n        return this.setDirectionLayers(this._defaultDirection, layers);\r\n    }\r\n\r\n    public processDirections(directions: { [index: string]: IAssetVisualizationDirection }): boolean\r\n    {\r\n        if(!directions) return false;\r\n\r\n        for(const key in directions)\r\n        {\r\n            const direction = directions[key];\r\n\r\n            if(!direction) continue;\r\n\r\n            const directionNumber = parseInt(key);\r\n\r\n            if(this._directions.get(directionNumber)) return false;\r\n\r\n            const directionData = new DirectionData(this._layerCount);\r\n\r\n            directionData.setFromDirection(this._defaultDirection);\r\n\r\n            this.setDirectionLayers(directionData, direction.layers);\r\n\r\n            this._directions.set(directionNumber, directionData);\r\n\r\n            this._lastDirectionData = null;\r\n            this._lastDirection = -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public processColors(colors: { [index: string]: IAssetColor }): boolean\r\n    {\r\n        if(!colors) return false;\r\n\r\n        for(const key in colors)\r\n        {\r\n            const color = colors[key];\r\n\r\n            if(!color) continue;\r\n\r\n            const colorNumber = parseInt(key);\r\n\r\n            if(this._colors[colorNumber]) return false;\r\n\r\n            const colorData = new ColorData(this._layerCount);\r\n\r\n            for(const layer in color.layers)\r\n            {\r\n                const colorLayer = color.layers[layer];\r\n\r\n                if(!colorLayer) continue;\r\n\r\n                const layerId = parseInt(layer);\r\n                const colorId = colorLayer.color;\r\n\r\n                colorData.setColorLayer(layerId, colorId);\r\n            }\r\n\r\n            this._colors[colorNumber] = colorData;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private setDirectionLayers(directionData: DirectionData, layers: { [index: string]: IAssetVisualizationLayer }): boolean\r\n    {\r\n        if(!directionData || !layers) return false;\r\n\r\n        for(const key in layers)\r\n        {\r\n            const layer = layers[key];\r\n\r\n            if(!layer) continue;\r\n\r\n            const layerId = parseInt(key);\r\n\r\n            if(layerId < 0 || (layerId >= this._layerCount)) return false;\r\n\r\n            if(layer.ink !== undefined) directionData.setLayerInk(layerId, SpriteUtilities.inkToBlendMode(layer.ink));\r\n\r\n            if(layer.tag !== undefined) directionData.setLayerTag(layerId, layer.tag);\r\n\r\n            if(layer.alpha !== undefined) directionData.setLayerAlpha(layerId, layer.alpha);\r\n\r\n            if(layer.ignoreMouse !== undefined) directionData.setLayerIgnoreMouse(layerId, layer.ignoreMouse);\r\n\r\n            if(layer.x !== undefined) directionData.setLayerXOffset(layerId, layer.x);\r\n\r\n            if(layer.y !== undefined) directionData.setLayerYOffset(layerId, layer.y);\r\n\r\n            if(layer.z !== undefined) directionData.setLayerZOffset(layerId, (layer.z / -1000));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public getValidDirection(direction: number): number\r\n    {\r\n        const existing = this._directions.get(direction);\r\n\r\n        if(existing) return direction;\r\n\r\n        direction = (((direction % 360) + 360) % 360);\r\n\r\n        let currentAngle = -1;\r\n        let validDirection = -1;\r\n\r\n        for(const key of this._directions.keys())\r\n        {\r\n            let angle = ((((key * this._angle) - direction) + 360) % 360);\r\n\r\n            if(angle > 180) angle = (360 - angle);\r\n\r\n            if((angle < currentAngle) || (currentAngle < 0))\r\n            {\r\n                currentAngle = angle;\r\n                validDirection = key;\r\n            }\r\n        }\r\n\r\n        if(validDirection >= 0) return Math.trunc(validDirection);\r\n\r\n        return 0;\r\n    }\r\n\r\n    public getDirectionData(direction: number): DirectionData\r\n    {\r\n        if(direction === this._lastDirection && this._lastDirectionData) return this._lastDirectionData;\r\n\r\n        let directionData = this._directions.get(direction);\r\n\r\n        if(!directionData) directionData = this._defaultDirection;\r\n\r\n        this._lastDirection = direction;\r\n        this._lastDirectionData = directionData;\r\n\r\n        return this._lastDirectionData;\r\n    }\r\n\r\n    public getLayerTag(direction: number, layerId: number): string\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_TAG;\r\n\r\n        return directionData.getLayerTag(layerId);\r\n    }\r\n\r\n    public getLayerInk(direction: number, layerId: number): number\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_INK;\r\n\r\n        return directionData.getLayerInk(layerId);\r\n    }\r\n\r\n    public getLayerAlpha(direction: number, layerId: number): number\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_ALPHA;\r\n\r\n        return directionData.getLayerAlpha(layerId);\r\n    }\r\n\r\n    public getLayerColor(layerId: number, colorId: number): number\r\n    {\r\n        const existing = this._colors[colorId] as ColorData;\r\n\r\n        if(!existing) return ColorData.DEFAULT_COLOR;\r\n\r\n        return existing.getLayerColor(layerId);\r\n    }\r\n\r\n    public getLayerIgnoreMouse(direction: number, layerId: number): boolean\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_IGNORE_MOUSE;\r\n\r\n        return directionData.getLayerIgnoreMouse(layerId);\r\n    }\r\n\r\n    public getLayerXOffset(direction: number, layerId: number): number\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_XOFFSET;\r\n\r\n        return directionData.getLayerXOffset(layerId);\r\n    }\r\n\r\n    public getLayerYOffset(direction: number, layerId: number): number\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_YOFFSET;\r\n\r\n        return directionData.getLayerYOffset(layerId);\r\n    }\r\n\r\n    public getLayerZOffset(direction: number, layerId: number): number\r\n    {\r\n        const directionData = this.getDirectionData(direction);\r\n\r\n        if(!directionData) return LayerData.DEFAULT_ZOFFSET;\r\n\r\n        return directionData.getLayerZOffset(layerId);\r\n    }\r\n\r\n    public get layerCount(): number\r\n    {\r\n        return this._layerCount;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}