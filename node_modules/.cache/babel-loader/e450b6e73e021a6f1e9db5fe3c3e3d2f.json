{"ast":null,"code":"import { RoomObjectVariable } from '../../RoomObjectVariable';\nimport { RoomObjectVisualizationType } from '../../RoomObjectVisualizationType';\nimport { AnimationData } from '../data/AnimationData';\nimport { AnimationFrame } from '../data/AnimationFrame';\nimport { AnimationStateData } from '../data/AnimationStateData';\nimport { FurnitureAnimatedVisualizationData } from './FurnitureAnimatedVisualizationData';\nimport { FurnitureVisualization } from './FurnitureVisualization';\nexport class FurnitureAnimatedVisualization extends FurnitureVisualization {\n  constructor() {\n    super();\n    this._data = void 0;\n    this._state = void 0;\n    this._frameIncrease = void 0;\n    this._animationData = void 0;\n    this._animationScale = void 0;\n    this._animationChangeTime = void 0;\n    this._animatedLayerCount = void 0;\n    this._directionChanged = void 0;\n    this._state = -1;\n    this._frameIncrease = 1;\n    this._animationData = new AnimationStateData();\n    this._animationScale = 0;\n    this._animationChangeTime = 0;\n    this._animatedLayerCount = 0;\n    this._directionChanged = false;\n  }\n\n  initialize(data) {\n    if (!(data instanceof FurnitureAnimatedVisualizationData)) return false;\n    return super.initialize(data);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._animationData) {\n      this._animationData.dispose();\n\n      this._animationData = null;\n    }\n  }\n\n  get animatedLayerCount() {\n    return this._animatedLayerCount;\n  }\n\n  get animationId() {\n    return this._animationData.animationId;\n  }\n\n  getAnimationId(animationData) {\n    if (this.animationId !== FurnitureAnimatedVisualization.DEFAULT_ANIMATION_ID && this._data.hasAnimation(this._animationScale, this.animationId)) return this.animationId;\n    return FurnitureAnimatedVisualization.DEFAULT_ANIMATION_ID;\n  }\n\n  updateObject(scale, direction) {\n    if (super.updateObject(scale, direction)) {\n      const state = this.object.getState(0);\n\n      if (state !== this._state) {\n        this.setAnimation(state);\n        this._state = state;\n        this._animationChangeTime = this.object.model.getValue(RoomObjectVariable.FURNITURE_STATE_UPDATE_TIME) || 0;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateModel(scale) {\n    if (super.updateModel(scale)) {\n      if (this.usesAnimationResetting()) {\n        const updateTime = this.object.model.getValue(RoomObjectVariable.FURNITURE_STATE_UPDATE_TIME);\n\n        if (updateTime > this._animationChangeTime) {\n          this._animationChangeTime = updateTime;\n          this.setAnimation(this._state);\n        }\n      }\n\n      const state = this.object.model.getValue(RoomObjectVariable.FURNITURE_AUTOMATIC_STATE_INDEX);\n\n      if (!isNaN(state)) {\n        const animationId = this._data.getAnimationId(this._animationScale, state);\n\n        this.setAnimation(animationId);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  isPlayingTransition(animationData, animationId) {\n    if (!AnimationData.isTransitionFromAnimation(animationData.animationId) && !AnimationData.isTransitionToAnimation(animationData.animationId)) return false;\n    if (animationId !== animationData.animationAfterTransitionId) return false;\n    if (animationData.animationOver) return false;\n    return true;\n  }\n\n  getCurrentState(animationData) {\n    const animationId = animationData.animationId;\n    if (!AnimationData.isTransitionFromAnimation(animationId) && !AnimationData.isTransitionToAnimation(animationId)) return animationId;\n    return animationData.animationAfterTransitionId;\n  }\n\n  setAnimation(animationId) {\n    if (!this._data) return;\n    this.setSubAnimation(this._animationData, animationId, this._state >= 0);\n  }\n\n  setSubAnimation(animationData, animationId) {\n    let _arg_3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const currentAnimation = animationData.animationId;\n\n    if (_arg_3) {\n      if (this.isPlayingTransition(animationData, animationId)) return false;\n      const state = this.getCurrentState(animationData);\n\n      if (animationId !== state) {\n        if (!this._data.isImmediateChange(this._animationScale, animationId, state)) {\n          let transition = AnimationData.getTransitionFromAnimationId(state);\n\n          if (this._data.hasAnimation(this._animationScale, transition)) {\n            animationData.animationAfterTransitionId = animationId;\n            animationId = transition;\n          } else {\n            transition = AnimationData.getTransitionToAnimationId(animationId);\n\n            if (this._data.hasAnimation(this._animationScale, transition)) {\n              animationData.animationAfterTransitionId = animationId;\n              animationId = transition;\n            }\n          }\n        }\n      } else {\n        if (AnimationData.isTransitionFromAnimation(animationData.animationId)) {\n          const transition = AnimationData.getTransitionToAnimationId(animationId);\n\n          if (this._data.hasAnimation(this._animationScale, transition)) {\n            animationData.animationAfterTransitionId = animationId;\n            animationId = transition;\n          }\n        } else if (!AnimationData.isTransitionToAnimation(animationData.animationId)) {\n          if (this.usesAnimationResetting()) {\n            const transition = AnimationData.getTransitionFromAnimationId(state);\n\n            if (this._data.hasAnimation(this._animationScale, transition)) {\n              animationData.animationAfterTransitionId = animationId;\n              animationId = transition;\n            } else {\n              const transition = AnimationData.getTransitionToAnimationId(animationId);\n\n              if (this._data.hasAnimation(this._animationScale, transition)) {\n                animationData.animationAfterTransitionId = animationId;\n                animationId = transition;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentAnimation !== animationId) {\n      animationData.animationId = animationId;\n      return true;\n    }\n\n    return false;\n  }\n\n  getLastFramePlayed(layerId) {\n    return this._animationData.getLastFramePlayed(layerId);\n  }\n\n  resetAllAnimationFrames() {\n    if (!this._animationData) return;\n\n    this._animationData.setLayerCount(this._animatedLayerCount);\n  }\n\n  updateAnimation(scale) {\n    if (!this._data) return 0;\n\n    if (scale !== this._animationScale) {\n      this._animationScale = scale;\n      this._animatedLayerCount = this._data.getLayerCount(scale);\n      this.resetAllAnimationFrames();\n    }\n\n    const update = this.updateAnimations(scale);\n    this._directionChanged = false;\n    return update;\n  }\n\n  updateAnimations(scale) {\n    if (this._animationData.animationOver && !this._directionChanged) return 0;\n    const update = this.updateFramesForAnimation(this._animationData, scale);\n\n    if (this._animationData.animationOver) {\n      if (AnimationData.isTransitionFromAnimation(this._animationData.animationId) || AnimationData.isTransitionToAnimation(this._animationData.animationId)) {\n        this.setAnimation(this._animationData.animationAfterTransitionId);\n        this._animationData.animationOver = false;\n      }\n    }\n\n    return update;\n  }\n\n  updateFramesForAnimation(animationData, scale) {\n    if (animationData.animationOver && !this._directionChanged) return 0;\n    const animationId = this.getAnimationId(animationData);\n    let frameCount = animationData.frameCounter;\n    if (!frameCount) frameCount = this._data.getStartFrame(scale, animationId, this._direction);\n    frameCount += this.frameIncrease;\n    animationData.frameCounter = frameCount;\n    animationData.animationOver = true;\n    let animationPlayed = false;\n    let layerId = this._animatedLayerCount - 1;\n    let update = 0;\n    let layerUpdate = 1 << this._animatedLayerCount - 1;\n\n    while (layerId >= 0) {\n      let sequenceId = 0;\n      animationPlayed = animationData.getAnimationPlayed(layerId);\n\n      if (!animationPlayed || this._directionChanged) {\n        let lastFramePlayed = animationData.getLastFramePlayed(layerId);\n        let frame = animationData.getFrame(layerId);\n\n        if (frame) {\n          if (frame.isLastFrame && frame.remainingFrameRepeats <= this.frameIncrease) {\n            lastFramePlayed = true;\n          }\n        }\n\n        if (this._directionChanged || !frame || frame.remainingFrameRepeats >= 0 && (frame.remainingFrameRepeats = frame.remainingFrameRepeats - this.frameIncrease) <= 0) {\n          sequenceId = AnimationFrame.SEQUENCE_NOT_DEFINED;\n          if (frame) sequenceId = frame.activeSequence;\n\n          if (sequenceId === AnimationFrame.SEQUENCE_NOT_DEFINED) {\n            frame = this._data.getFrame(scale, animationId, this._direction, layerId, frameCount);\n          } else {\n            frame = this._data.getFrameFromSequence(scale, animationId, this._direction, layerId, sequenceId, frame.activeSequenceOffset + frame.repeats, frameCount);\n          }\n\n          animationData.setFrame(layerId, frame);\n          update = update | layerUpdate;\n        }\n\n        if (!frame || frame.remainingFrameRepeats == AnimationFrame.FRAME_REPEAT_FOREVER) {\n          lastFramePlayed = true;\n          animationPlayed = true;\n        } else {\n          animationData.animationOver = false;\n        }\n\n        animationData.setLastFramePlayed(layerId, lastFramePlayed);\n        animationData.setAnimationPlayed(layerId, animationPlayed);\n      }\n\n      layerUpdate = layerUpdate >> 1;\n      layerId--;\n    }\n\n    return update;\n  }\n\n  getFrameNumber(scale, layerId) {\n    const currentFrame = this._animationData.getFrame(layerId);\n\n    if (!currentFrame) return super.getFrameNumber(scale, layerId);\n    return currentFrame.id;\n  }\n\n  getLayerXOffset(scale, direction, layerId) {\n    const offset = super.getLayerXOffset(scale, direction, layerId);\n\n    const currentFrame = this._animationData.getFrame(layerId);\n\n    if (!currentFrame) return offset;\n    return offset + currentFrame.x;\n  }\n\n  getLayerYOffset(scale, direction, layerId) {\n    const offset = super.getLayerYOffset(scale, direction, layerId);\n\n    const currentFrame = this._animationData.getFrame(layerId);\n\n    if (!currentFrame) return offset;\n    return offset + currentFrame.y;\n  }\n\n  usesAnimationResetting() {\n    return false;\n  }\n\n  setDirection(direction) {\n    if (this._direction === direction) return;\n    super.setDirection(direction);\n    this._directionChanged = true;\n  }\n\n  get frameIncrease() {\n    return this._frameIncrease;\n  }\n\n}\nFurnitureAnimatedVisualization.TYPE = RoomObjectVisualizationType.FURNITURE_ANIMATED;\nFurnitureAnimatedVisualization.DEFAULT_ANIMATION_ID = 0;","map":{"version":3,"sources":["/var/www/game.bobba.ca/node_modules/@nitrots/nitro-renderer/src/nitro/room/object/visualization/furniture/FurnitureAnimatedVisualization.ts"],"names":["RoomObjectVariable","RoomObjectVisualizationType","AnimationData","AnimationFrame","AnimationStateData","FurnitureAnimatedVisualizationData","FurnitureVisualization","FurnitureAnimatedVisualization","constructor","_data","_state","_frameIncrease","_animationData","_animationScale","_animationChangeTime","_animatedLayerCount","_directionChanged","initialize","data","dispose","animatedLayerCount","animationId","getAnimationId","animationData","DEFAULT_ANIMATION_ID","hasAnimation","updateObject","scale","direction","state","object","getState","setAnimation","model","getValue","FURNITURE_STATE_UPDATE_TIME","updateModel","usesAnimationResetting","updateTime","FURNITURE_AUTOMATIC_STATE_INDEX","isNaN","isPlayingTransition","isTransitionFromAnimation","isTransitionToAnimation","animationAfterTransitionId","animationOver","getCurrentState","setSubAnimation","_arg_3","currentAnimation","isImmediateChange","transition","getTransitionFromAnimationId","getTransitionToAnimationId","getLastFramePlayed","layerId","resetAllAnimationFrames","setLayerCount","updateAnimation","getLayerCount","update","updateAnimations","updateFramesForAnimation","frameCount","frameCounter","getStartFrame","_direction","frameIncrease","animationPlayed","layerUpdate","sequenceId","getAnimationPlayed","lastFramePlayed","frame","getFrame","isLastFrame","remainingFrameRepeats","SEQUENCE_NOT_DEFINED","activeSequence","getFrameFromSequence","activeSequenceOffset","repeats","setFrame","FRAME_REPEAT_FOREVER","setLastFramePlayed","setAnimationPlayed","getFrameNumber","currentFrame","id","getLayerXOffset","offset","x","getLayerYOffset","y","setDirection","TYPE","FURNITURE_ANIMATED"],"mappings":"AACA,SAASA,kBAAT,QAAmC,0BAAnC;AACA,SAASC,2BAAT,QAA4C,mCAA5C;AACA,SAASC,aAAT,QAA8B,uBAA9B;AACA,SAASC,cAAT,QAA+B,wBAA/B;AACA,SAASC,kBAAT,QAAmC,4BAAnC;AACA,SAASC,kCAAT,QAAmD,sCAAnD;AACA,SAASC,sBAAT,QAAuC,0BAAvC;AAEA,OAAO,MAAMC,8BAAN,SAA6CD,sBAA7C,CACP;AAcIE,EAAAA,WAAW,GACX;AACI;AADJ,SAXUC,KAWV;AAAA,SATUC,MASV;AAAA,SARUC,cAQV;AAAA,SAPQC,cAOR;AAAA,SANQC,eAMR;AAAA,SALQC,oBAKR;AAAA,SAJQC,mBAIR;AAAA,SAHQC,iBAGR;AAGI,SAAKN,MAAL,GAAc,CAAC,CAAf;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,cAAL,GAAsB,IAAIR,kBAAJ,EAAtB;AACA,SAAKS,eAAL,GAAuB,CAAvB;AACA,SAAKC,oBAAL,GAA4B,CAA5B;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACA,SAAKC,iBAAL,GAAyB,KAAzB;AACH;;AAEMC,EAAAA,UAAU,CAACC,IAAD,EACjB;AACI,QAAG,EAAEA,IAAI,YAAYb,kCAAlB,CAAH,EAA0D,OAAO,KAAP;AAE1D,WAAO,MAAMY,UAAN,CAAiBC,IAAjB,CAAP;AACH;;AAEMC,EAAAA,OAAO,GACd;AACI,UAAMA,OAAN;;AAEA,QAAG,KAAKP,cAAR,EACA;AACI,WAAKA,cAAL,CAAoBO,OAApB;;AAEA,WAAKP,cAAL,GAAsB,IAAtB;AACH;AACJ;;AAE+B,MAAlBQ,kBAAkB,GAChC;AACI,WAAO,KAAKL,mBAAZ;AACH;;AAEqB,MAAXM,WAAW,GACtB;AACI,WAAO,KAAKT,cAAL,CAAoBS,WAA3B;AACH;;AAESC,EAAAA,cAAc,CAACC,aAAD,EACxB;AACI,QAAI,KAAKF,WAAL,KAAqBd,8BAA8B,CAACiB,oBAArD,IAA8E,KAAKf,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8C,KAAKQ,WAAnD,CAAjF,EAAkJ,OAAO,KAAKA,WAAZ;AAElJ,WAAOd,8BAA8B,CAACiB,oBAAtC;AACH;;AAESE,EAAAA,YAAY,CAACC,KAAD,EAAgBC,SAAhB,EACtB;AACI,QAAG,MAAMF,YAAN,CAAmBC,KAAnB,EAA0BC,SAA1B,CAAH,EACA;AACI,YAAMC,KAAK,GAAG,KAAKC,MAAL,CAAYC,QAAZ,CAAqB,CAArB,CAAd;;AAEA,UAAGF,KAAK,KAAK,KAAKnB,MAAlB,EACA;AACI,aAAKsB,YAAL,CAAkBH,KAAlB;AAEA,aAAKnB,MAAL,GAAcmB,KAAd;AAEA,aAAKf,oBAAL,GAA6B,KAAKgB,MAAL,CAAYG,KAAZ,CAAkBC,QAAlB,CAAmClC,kBAAkB,CAACmC,2BAAtD,KAAsF,CAAnH;AACH;;AAED,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAESC,EAAAA,WAAW,CAACT,KAAD,EACrB;AACI,QAAG,MAAMS,WAAN,CAAkBT,KAAlB,CAAH,EACA;AACI,UAAG,KAAKU,sBAAL,EAAH,EACA;AACI,cAAMC,UAAU,GAAG,KAAKR,MAAL,CAAYG,KAAZ,CAAkBC,QAAlB,CAAmClC,kBAAkB,CAACmC,2BAAtD,CAAnB;;AAEA,YAAGG,UAAU,GAAG,KAAKxB,oBAArB,EACA;AACI,eAAKA,oBAAL,GAA4BwB,UAA5B;AAEA,eAAKN,YAAL,CAAkB,KAAKtB,MAAvB;AACH;AACJ;;AAED,YAAMmB,KAAK,GAAG,KAAKC,MAAL,CAAYG,KAAZ,CAAkBC,QAAlB,CAAmClC,kBAAkB,CAACuC,+BAAtD,CAAd;;AAEA,UAAG,CAACC,KAAK,CAACX,KAAD,CAAT,EACA;AACI,cAAMR,WAAW,GAAG,KAAKZ,KAAL,CAAWa,cAAX,CAA0B,KAAKT,eAA/B,EAAgDgB,KAAhD,CAApB;;AAEA,aAAKG,YAAL,CAAkBX,WAAlB;AACH;;AAED,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAEOoB,EAAAA,mBAAmB,CAAClB,aAAD,EAAoCF,WAApC,EAC3B;AACI,QAAG,CAACnB,aAAa,CAACwC,yBAAd,CAAwCnB,aAAa,CAACF,WAAtD,CAAD,IAAuE,CAACnB,aAAa,CAACyC,uBAAd,CAAsCpB,aAAa,CAACF,WAApD,CAA3E,EAA6I,OAAO,KAAP;AAE7I,QAAGA,WAAW,KAAKE,aAAa,CAACqB,0BAAjC,EAA6D,OAAO,KAAP;AAE7D,QAAGrB,aAAa,CAACsB,aAAjB,EAAgC,OAAO,KAAP;AAEhC,WAAO,IAAP;AACH;;AAEOC,EAAAA,eAAe,CAACvB,aAAD,EACvB;AACI,UAAMF,WAAW,GAAGE,aAAa,CAACF,WAAlC;AAEA,QAAG,CAACnB,aAAa,CAACwC,yBAAd,CAAwCrB,WAAxC,CAAD,IAAyD,CAACnB,aAAa,CAACyC,uBAAd,CAAsCtB,WAAtC,CAA7D,EAAiH,OAAOA,WAAP;AAEjH,WAAOE,aAAa,CAACqB,0BAArB;AACH;;AAESZ,EAAAA,YAAY,CAACX,WAAD,EACtB;AACI,QAAG,CAAC,KAAKZ,KAAT,EAAgB;AAEhB,SAAKsC,eAAL,CAAqB,KAAKnC,cAA1B,EAA0CS,WAA1C,EAAwD,KAAKX,MAAL,IAAe,CAAvE;AACH;;AAESqC,EAAAA,eAAe,CAACxB,aAAD,EAAoCF,WAApC,EACzB;AAAA,QADkF2B,MAClF,uEADoG,IACpG;;AACI,UAAMC,gBAAgB,GAAG1B,aAAa,CAACF,WAAvC;;AAEA,QAAG2B,MAAH,EACA;AACI,UAAG,KAAKP,mBAAL,CAAyBlB,aAAzB,EAAwCF,WAAxC,CAAH,EAAyD,OAAO,KAAP;AAEzD,YAAMQ,KAAK,GAAG,KAAKiB,eAAL,CAAqBvB,aAArB,CAAd;;AAEA,UAAGF,WAAW,KAAKQ,KAAnB,EACA;AACI,YAAG,CAAC,KAAKpB,KAAL,CAAWyC,iBAAX,CAA6B,KAAKrC,eAAlC,EAAmDQ,WAAnD,EAAgEQ,KAAhE,CAAJ,EACA;AACI,cAAIsB,UAAU,GAAGjD,aAAa,CAACkD,4BAAd,CAA2CvB,KAA3C,CAAjB;;AAEA,cAAG,KAAKpB,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8CsC,UAA9C,CAAH,EACA;AACI5B,YAAAA,aAAa,CAACqB,0BAAd,GAA2CvB,WAA3C;AACAA,YAAAA,WAAW,GAAG8B,UAAd;AACH,WAJD,MAMA;AACIA,YAAAA,UAAU,GAAGjD,aAAa,CAACmD,0BAAd,CAAyChC,WAAzC,CAAb;;AAEA,gBAAG,KAAKZ,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8CsC,UAA9C,CAAH,EACA;AACI5B,cAAAA,aAAa,CAACqB,0BAAd,GAA2CvB,WAA3C;AACAA,cAAAA,WAAW,GAAG8B,UAAd;AACH;AACJ;AACJ;AACJ,OAtBD,MAwBA;AACI,YAAGjD,aAAa,CAACwC,yBAAd,CAAwCnB,aAAa,CAACF,WAAtD,CAAH,EACA;AACI,gBAAM8B,UAAU,GAAGjD,aAAa,CAACmD,0BAAd,CAAyChC,WAAzC,CAAnB;;AAEA,cAAG,KAAKZ,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8CsC,UAA9C,CAAH,EACA;AACI5B,YAAAA,aAAa,CAACqB,0BAAd,GAA2CvB,WAA3C;AACAA,YAAAA,WAAW,GAAG8B,UAAd;AACH;AACJ,SATD,MAWK,IAAG,CAACjD,aAAa,CAACyC,uBAAd,CAAsCpB,aAAa,CAACF,WAApD,CAAJ,EACL;AACI,cAAG,KAAKgB,sBAAL,EAAH,EACA;AACI,kBAAMc,UAAU,GAAGjD,aAAa,CAACkD,4BAAd,CAA2CvB,KAA3C,CAAnB;;AAEA,gBAAG,KAAKpB,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8CsC,UAA9C,CAAH,EACA;AACI5B,cAAAA,aAAa,CAACqB,0BAAd,GAA2CvB,WAA3C;AACAA,cAAAA,WAAW,GAAG8B,UAAd;AACH,aAJD,MAMA;AACI,oBAAMA,UAAU,GAAGjD,aAAa,CAACmD,0BAAd,CAAyChC,WAAzC,CAAnB;;AAEA,kBAAG,KAAKZ,KAAL,CAAWgB,YAAX,CAAwB,KAAKZ,eAA7B,EAA8CsC,UAA9C,CAAH,EACA;AACI5B,gBAAAA,aAAa,CAACqB,0BAAd,GAA2CvB,WAA3C;AACAA,gBAAAA,WAAW,GAAG8B,UAAd;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;;AAED,QAAGF,gBAAgB,KAAK5B,WAAxB,EACA;AACIE,MAAAA,aAAa,CAACF,WAAd,GAA4BA,WAA5B;AAEA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAESiC,EAAAA,kBAAkB,CAACC,OAAD,EAC5B;AACI,WAAO,KAAK3C,cAAL,CAAoB0C,kBAApB,CAAuCC,OAAvC,CAAP;AACH;;AAESC,EAAAA,uBAAuB,GACjC;AACI,QAAG,CAAC,KAAK5C,cAAT,EAAyB;;AAEzB,SAAKA,cAAL,CAAoB6C,aAApB,CAAkC,KAAK1C,mBAAvC;AACH;;AAES2C,EAAAA,eAAe,CAAC/B,KAAD,EACzB;AACI,QAAG,CAAC,KAAKlB,KAAT,EAAgB,OAAO,CAAP;;AAEhB,QAAGkB,KAAK,KAAK,KAAKd,eAAlB,EACA;AACI,WAAKA,eAAL,GAAuBc,KAAvB;AACA,WAAKZ,mBAAL,GAA2B,KAAKN,KAAL,CAAWkD,aAAX,CAAyBhC,KAAzB,CAA3B;AAEA,WAAK6B,uBAAL;AACH;;AAED,UAAMI,MAAM,GAAG,KAAKC,gBAAL,CAAsBlC,KAAtB,CAAf;AAEA,SAAKX,iBAAL,GAAyB,KAAzB;AAEA,WAAO4C,MAAP;AACH;;AAESC,EAAAA,gBAAgB,CAAClC,KAAD,EAC1B;AACI,QAAG,KAAKf,cAAL,CAAoBiC,aAApB,IAAqC,CAAC,KAAK7B,iBAA9C,EAAiE,OAAO,CAAP;AAEjE,UAAM4C,MAAM,GAAG,KAAKE,wBAAL,CAA8B,KAAKlD,cAAnC,EAAmDe,KAAnD,CAAf;;AAEA,QAAG,KAAKf,cAAL,CAAoBiC,aAAvB,EACA;AACI,UAAI3C,aAAa,CAACwC,yBAAd,CAAwC,KAAK9B,cAAL,CAAoBS,WAA5D,CAAD,IAA+EnB,aAAa,CAACyC,uBAAd,CAAsC,KAAK/B,cAAL,CAAoBS,WAA1D,CAAlF,EACA;AACI,aAAKW,YAAL,CAAkB,KAAKpB,cAAL,CAAoBgC,0BAAtC;AACA,aAAKhC,cAAL,CAAoBiC,aAApB,GAAoC,KAApC;AACH;AACJ;;AAED,WAAOe,MAAP;AACH;;AAESE,EAAAA,wBAAwB,CAACvC,aAAD,EAAoCI,KAApC,EAClC;AACI,QAAGJ,aAAa,CAACsB,aAAd,IAA+B,CAAC,KAAK7B,iBAAxC,EAA2D,OAAO,CAAP;AAE3D,UAAMK,WAAW,GAAG,KAAKC,cAAL,CAAoBC,aAApB,CAApB;AACA,QAAIwC,UAAU,GAAGxC,aAAa,CAACyC,YAA/B;AAEA,QAAG,CAACD,UAAJ,EAAgBA,UAAU,GAAG,KAAKtD,KAAL,CAAWwD,aAAX,CAAyBtC,KAAzB,EAAgCN,WAAhC,EAA6C,KAAK6C,UAAlD,CAAb;AAEhBH,IAAAA,UAAU,IAAI,KAAKI,aAAnB;AACA5C,IAAAA,aAAa,CAACyC,YAAd,GAA6BD,UAA7B;AACAxC,IAAAA,aAAa,CAACsB,aAAd,GAA8B,IAA9B;AAEA,QAAIuB,eAAe,GAAG,KAAtB;AACA,QAAIb,OAAO,GAAI,KAAKxC,mBAAL,GAA2B,CAA1C;AACA,QAAI6C,MAAM,GAAG,CAAb;AACA,QAAIS,WAAW,GAAI,KAAM,KAAKtD,mBAAL,GAA2B,CAApD;;AAEA,WAAMwC,OAAO,IAAI,CAAjB,EACA;AACI,UAAIe,UAAU,GAAG,CAAjB;AAEAF,MAAAA,eAAe,GAAG7C,aAAa,CAACgD,kBAAd,CAAiChB,OAAjC,CAAlB;;AAEA,UAAG,CAACa,eAAD,IAAoB,KAAKpD,iBAA5B,EACA;AACI,YAAIwD,eAAe,GAAGjD,aAAa,CAAC+B,kBAAd,CAAiCC,OAAjC,CAAtB;AACA,YAAIkB,KAAK,GAAGlD,aAAa,CAACmD,QAAd,CAAuBnB,OAAvB,CAAZ;;AAEA,YAAGkB,KAAH,EACA;AACI,cAAGA,KAAK,CAACE,WAAN,IAAsBF,KAAK,CAACG,qBAAN,IAA+B,KAAKT,aAA7D,EACA;AACIK,YAAAA,eAAe,GAAG,IAAlB;AACH;AACJ;;AAED,YAAI,KAAKxD,iBAAL,IAA0B,CAACyD,KAA5B,IAAwCA,KAAK,CAACG,qBAAN,IAA+B,CAAhC,IAAuC,CAACH,KAAK,CAACG,qBAAN,GAA+BH,KAAK,CAACG,qBAAN,GAA8B,KAAKT,aAAnE,KAAsF,CAAvK,EACA;AACIG,UAAAA,UAAU,GAAGnE,cAAc,CAAC0E,oBAA5B;AAEA,cAAGJ,KAAH,EAAUH,UAAU,GAAGG,KAAK,CAACK,cAAnB;;AAEV,cAAGR,UAAU,KAAKnE,cAAc,CAAC0E,oBAAjC,EACA;AACIJ,YAAAA,KAAK,GAAG,KAAKhE,KAAL,CAAWiE,QAAX,CAAoB/C,KAApB,EAA2BN,WAA3B,EAAwC,KAAK6C,UAA7C,EAAyDX,OAAzD,EAAkEQ,UAAlE,CAAR;AACH,WAHD,MAKA;AACIU,YAAAA,KAAK,GAAG,KAAKhE,KAAL,CAAWsE,oBAAX,CAAgCpD,KAAhC,EAAuCN,WAAvC,EAAoD,KAAK6C,UAAzD,EAAqEX,OAArE,EAA8Ee,UAA9E,EAA2FG,KAAK,CAACO,oBAAN,GAA6BP,KAAK,CAACQ,OAA9H,EAAwIlB,UAAxI,CAAR;AACH;;AAEDxC,UAAAA,aAAa,CAAC2D,QAAd,CAAuB3B,OAAvB,EAAgCkB,KAAhC;AAEAb,UAAAA,MAAM,GAAIA,MAAM,GAAGS,WAAnB;AACH;;AAED,YAAG,CAACI,KAAD,IAAWA,KAAK,CAACG,qBAAN,IAA+BzE,cAAc,CAACgF,oBAA5D,EACA;AACIX,UAAAA,eAAe,GAAG,IAAlB;AACAJ,UAAAA,eAAe,GAAG,IAAlB;AACH,SAJD,MAMA;AACI7C,UAAAA,aAAa,CAACsB,aAAd,GAA8B,KAA9B;AACH;;AAEDtB,QAAAA,aAAa,CAAC6D,kBAAd,CAAiC7B,OAAjC,EAA0CiB,eAA1C;AACAjD,QAAAA,aAAa,CAAC8D,kBAAd,CAAiC9B,OAAjC,EAA0Ca,eAA1C;AACH;;AAEDC,MAAAA,WAAW,GAAIA,WAAW,IAAI,CAA9B;AAEAd,MAAAA,OAAO;AACV;;AAED,WAAOK,MAAP;AACH;;AAES0B,EAAAA,cAAc,CAAC3D,KAAD,EAAgB4B,OAAhB,EACxB;AACI,UAAMgC,YAAY,GAAG,KAAK3E,cAAL,CAAoB8D,QAApB,CAA6BnB,OAA7B,CAArB;;AAEA,QAAG,CAACgC,YAAJ,EAAkB,OAAO,MAAMD,cAAN,CAAqB3D,KAArB,EAA4B4B,OAA5B,CAAP;AAElB,WAAOgC,YAAY,CAACC,EAApB;AACH;;AAESC,EAAAA,eAAe,CAAC9D,KAAD,EAAgBC,SAAhB,EAAmC2B,OAAnC,EACzB;AACI,UAAMmC,MAAM,GAAG,MAAMD,eAAN,CAAsB9D,KAAtB,EAA6BC,SAA7B,EAAwC2B,OAAxC,CAAf;;AAEA,UAAMgC,YAAY,GAAG,KAAK3E,cAAL,CAAoB8D,QAApB,CAA6BnB,OAA7B,CAArB;;AAEA,QAAG,CAACgC,YAAJ,EAAkB,OAAOG,MAAP;AAElB,WAAQA,MAAM,GAAGH,YAAY,CAACI,CAA9B;AACH;;AAESC,EAAAA,eAAe,CAACjE,KAAD,EAAgBC,SAAhB,EAAmC2B,OAAnC,EACzB;AACI,UAAMmC,MAAM,GAAG,MAAME,eAAN,CAAsBjE,KAAtB,EAA6BC,SAA7B,EAAwC2B,OAAxC,CAAf;;AAEA,UAAMgC,YAAY,GAAG,KAAK3E,cAAL,CAAoB8D,QAApB,CAA6BnB,OAA7B,CAArB;;AAEA,QAAG,CAACgC,YAAJ,EAAkB,OAAOG,MAAP;AAElB,WAAQA,MAAM,GAAGH,YAAY,CAACM,CAA9B;AACH;;AAESxD,EAAAA,sBAAsB,GAChC;AACI,WAAO,KAAP;AACH;;AAESyD,EAAAA,YAAY,CAAClE,SAAD,EACtB;AACI,QAAG,KAAKsC,UAAL,KAAoBtC,SAAvB,EAAkC;AAElC,UAAMkE,YAAN,CAAmBlE,SAAnB;AAEA,SAAKZ,iBAAL,GAAyB,IAAzB;AACH;;AAE0B,MAAbmD,aAAa,GAC3B;AACI,WAAO,KAAKxD,cAAZ;AACH;;AAhZL;AADaJ,8B,CAEKwF,I,GAAe9F,2BAA2B,CAAC+F,kB;AAFhDzF,8B,CAGKiB,oB,GAA+B,C","sourcesContent":["import { IObjectVisualizationData } from '../../../../../room/object/visualization/IRoomObjectVisualizationData';\r\nimport { RoomObjectVariable } from '../../RoomObjectVariable';\r\nimport { RoomObjectVisualizationType } from '../../RoomObjectVisualizationType';\r\nimport { AnimationData } from '../data/AnimationData';\r\nimport { AnimationFrame } from '../data/AnimationFrame';\r\nimport { AnimationStateData } from '../data/AnimationStateData';\r\nimport { FurnitureAnimatedVisualizationData } from './FurnitureAnimatedVisualizationData';\r\nimport { FurnitureVisualization } from './FurnitureVisualization';\r\n\r\nexport class FurnitureAnimatedVisualization extends FurnitureVisualization\r\n{\r\n    public static TYPE: string = RoomObjectVisualizationType.FURNITURE_ANIMATED;\r\n    public static DEFAULT_ANIMATION_ID: number = 0;\r\n\r\n    protected _data: FurnitureAnimatedVisualizationData;\r\n\r\n    protected _state: number;\r\n    protected _frameIncrease: number;\r\n    private _animationData: AnimationStateData;\r\n    private _animationScale: number;\r\n    private _animationChangeTime: number;\r\n    private _animatedLayerCount: number;\r\n    private _directionChanged: boolean;\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this._state = -1;\r\n        this._frameIncrease = 1;\r\n        this._animationData = new AnimationStateData();\r\n        this._animationScale = 0;\r\n        this._animationChangeTime = 0;\r\n        this._animatedLayerCount = 0;\r\n        this._directionChanged = false;\r\n    }\r\n\r\n    public initialize(data: IObjectVisualizationData): boolean\r\n    {\r\n        if(!(data instanceof FurnitureAnimatedVisualizationData)) return false;\r\n\r\n        return super.initialize(data);\r\n    }\r\n\r\n    public dispose(): void\r\n    {\r\n        super.dispose();\r\n\r\n        if(this._animationData)\r\n        {\r\n            this._animationData.dispose();\r\n\r\n            this._animationData = null;\r\n        }\r\n    }\r\n\r\n    protected get animatedLayerCount(): number\r\n    {\r\n        return this._animatedLayerCount;\r\n    }\r\n\r\n    public get animationId(): number\r\n    {\r\n        return this._animationData.animationId;\r\n    }\r\n\r\n    protected getAnimationId(animationData: AnimationStateData): number\r\n    {\r\n        if((this.animationId !== FurnitureAnimatedVisualization.DEFAULT_ANIMATION_ID) && this._data.hasAnimation(this._animationScale, this.animationId)) return this.animationId;\r\n\r\n        return FurnitureAnimatedVisualization.DEFAULT_ANIMATION_ID;\r\n    }\r\n\r\n    protected updateObject(scale: number, direction: number): boolean\r\n    {\r\n        if(super.updateObject(scale, direction))\r\n        {\r\n            const state = this.object.getState(0);\r\n\r\n            if(state !== this._state)\r\n            {\r\n                this.setAnimation(state);\r\n\r\n                this._state = state;\r\n\r\n                this._animationChangeTime = (this.object.model.getValue<number>(RoomObjectVariable.FURNITURE_STATE_UPDATE_TIME) || 0);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected updateModel(scale: number): boolean\r\n    {\r\n        if(super.updateModel(scale))\r\n        {\r\n            if(this.usesAnimationResetting())\r\n            {\r\n                const updateTime = this.object.model.getValue<number>(RoomObjectVariable.FURNITURE_STATE_UPDATE_TIME);\r\n\r\n                if(updateTime > this._animationChangeTime)\r\n                {\r\n                    this._animationChangeTime = updateTime;\r\n\r\n                    this.setAnimation(this._state);\r\n                }\r\n            }\r\n\r\n            const state = this.object.model.getValue<number>(RoomObjectVariable.FURNITURE_AUTOMATIC_STATE_INDEX);\r\n\r\n            if(!isNaN(state))\r\n            {\r\n                const animationId = this._data.getAnimationId(this._animationScale, state);\r\n\r\n                this.setAnimation(animationId);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private isPlayingTransition(animationData: AnimationStateData, animationId: number): boolean\r\n    {\r\n        if(!AnimationData.isTransitionFromAnimation(animationData.animationId) && !AnimationData.isTransitionToAnimation(animationData.animationId)) return false;\r\n\r\n        if(animationId !== animationData.animationAfterTransitionId) return false;\r\n\r\n        if(animationData.animationOver) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    private getCurrentState(animationData: AnimationStateData): number\r\n    {\r\n        const animationId = animationData.animationId;\r\n\r\n        if(!AnimationData.isTransitionFromAnimation(animationId) && !AnimationData.isTransitionToAnimation(animationId)) return animationId;\r\n\r\n        return animationData.animationAfterTransitionId;\r\n    }\r\n\r\n    protected setAnimation(animationId: number): void\r\n    {\r\n        if(!this._data) return;\r\n\r\n        this.setSubAnimation(this._animationData, animationId, (this._state >= 0));\r\n    }\r\n\r\n    protected setSubAnimation(animationData: AnimationStateData, animationId: number, _arg_3: boolean = true): boolean\r\n    {\r\n        const currentAnimation = animationData.animationId;\r\n\r\n        if(_arg_3)\r\n        {\r\n            if(this.isPlayingTransition(animationData, animationId)) return false;\r\n\r\n            const state = this.getCurrentState(animationData);\r\n\r\n            if(animationId !== state)\r\n            {\r\n                if(!this._data.isImmediateChange(this._animationScale, animationId, state))\r\n                {\r\n                    let transition = AnimationData.getTransitionFromAnimationId(state);\r\n\r\n                    if(this._data.hasAnimation(this._animationScale, transition))\r\n                    {\r\n                        animationData.animationAfterTransitionId = animationId;\r\n                        animationId = transition;\r\n                    }\r\n                    else\r\n                    {\r\n                        transition = AnimationData.getTransitionToAnimationId(animationId);\r\n\r\n                        if(this._data.hasAnimation(this._animationScale, transition))\r\n                        {\r\n                            animationData.animationAfterTransitionId = animationId;\r\n                            animationId = transition;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if(AnimationData.isTransitionFromAnimation(animationData.animationId))\r\n                {\r\n                    const transition = AnimationData.getTransitionToAnimationId(animationId);\r\n\r\n                    if(this._data.hasAnimation(this._animationScale, transition))\r\n                    {\r\n                        animationData.animationAfterTransitionId = animationId;\r\n                        animationId = transition;\r\n                    }\r\n                }\r\n\r\n                else if(!AnimationData.isTransitionToAnimation(animationData.animationId))\r\n                {\r\n                    if(this.usesAnimationResetting())\r\n                    {\r\n                        const transition = AnimationData.getTransitionFromAnimationId(state);\r\n\r\n                        if(this._data.hasAnimation(this._animationScale, transition))\r\n                        {\r\n                            animationData.animationAfterTransitionId = animationId;\r\n                            animationId = transition;\r\n                        }\r\n                        else\r\n                        {\r\n                            const transition = AnimationData.getTransitionToAnimationId(animationId);\r\n\r\n                            if(this._data.hasAnimation(this._animationScale, transition))\r\n                            {\r\n                                animationData.animationAfterTransitionId = animationId;\r\n                                animationId = transition;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(currentAnimation !== animationId)\r\n        {\r\n            animationData.animationId = animationId;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected getLastFramePlayed(layerId: number): boolean\r\n    {\r\n        return this._animationData.getLastFramePlayed(layerId);\r\n    }\r\n\r\n    protected resetAllAnimationFrames(): void\r\n    {\r\n        if(!this._animationData) return;\r\n\r\n        this._animationData.setLayerCount(this._animatedLayerCount);\r\n    }\r\n\r\n    protected updateAnimation(scale: number): number\r\n    {\r\n        if(!this._data) return 0;\r\n\r\n        if(scale !== this._animationScale)\r\n        {\r\n            this._animationScale = scale;\r\n            this._animatedLayerCount = this._data.getLayerCount(scale);\r\n\r\n            this.resetAllAnimationFrames();\r\n        }\r\n\r\n        const update = this.updateAnimations(scale);\r\n\r\n        this._directionChanged = false;\r\n\r\n        return update;\r\n    }\r\n\r\n    protected updateAnimations(scale: number): number\r\n    {\r\n        if(this._animationData.animationOver && !this._directionChanged) return 0;\r\n\r\n        const update = this.updateFramesForAnimation(this._animationData, scale);\r\n\r\n        if(this._animationData.animationOver)\r\n        {\r\n            if((AnimationData.isTransitionFromAnimation(this._animationData.animationId)) || (AnimationData.isTransitionToAnimation(this._animationData.animationId)))\r\n            {\r\n                this.setAnimation(this._animationData.animationAfterTransitionId);\r\n                this._animationData.animationOver = false;\r\n            }\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    protected updateFramesForAnimation(animationData: AnimationStateData, scale: number): number\r\n    {\r\n        if(animationData.animationOver && !this._directionChanged) return 0;\r\n\r\n        const animationId = this.getAnimationId(animationData);\r\n        let frameCount = animationData.frameCounter;\r\n\r\n        if(!frameCount) frameCount = this._data.getStartFrame(scale, animationId, this._direction);\r\n\r\n        frameCount += this.frameIncrease;\r\n        animationData.frameCounter = frameCount;\r\n        animationData.animationOver = true;\r\n\r\n        let animationPlayed = false;\r\n        let layerId = (this._animatedLayerCount - 1);\r\n        let update = 0;\r\n        let layerUpdate = (1 << (this._animatedLayerCount - 1));\r\n\r\n        while(layerId >= 0)\r\n        {\r\n            let sequenceId = 0;\r\n\r\n            animationPlayed = animationData.getAnimationPlayed(layerId);\r\n\r\n            if(!animationPlayed || this._directionChanged)\r\n            {\r\n                let lastFramePlayed = animationData.getLastFramePlayed(layerId);\r\n                let frame = animationData.getFrame(layerId);\r\n\r\n                if(frame)\r\n                {\r\n                    if(frame.isLastFrame && (frame.remainingFrameRepeats <= this.frameIncrease))\r\n                    {\r\n                        lastFramePlayed = true;\r\n                    }\r\n                }\r\n\r\n                if((this._directionChanged || !frame) || ((frame.remainingFrameRepeats >= 0) && ((frame.remainingFrameRepeats = (frame.remainingFrameRepeats - this.frameIncrease)) <= 0)))\r\n                {\r\n                    sequenceId = AnimationFrame.SEQUENCE_NOT_DEFINED;\r\n\r\n                    if(frame) sequenceId = frame.activeSequence;\r\n\r\n                    if(sequenceId === AnimationFrame.SEQUENCE_NOT_DEFINED)\r\n                    {\r\n                        frame = this._data.getFrame(scale, animationId, this._direction, layerId, frameCount);\r\n                    }\r\n                    else\r\n                    {\r\n                        frame = this._data.getFrameFromSequence(scale, animationId, this._direction, layerId, sequenceId, (frame.activeSequenceOffset + frame.repeats), frameCount);\r\n                    }\r\n\r\n                    animationData.setFrame(layerId, frame);\r\n\r\n                    update = (update | layerUpdate);\r\n                }\r\n\r\n                if(!frame || (frame.remainingFrameRepeats == AnimationFrame.FRAME_REPEAT_FOREVER))\r\n                {\r\n                    lastFramePlayed = true;\r\n                    animationPlayed = true;\r\n                }\r\n                else\r\n                {\r\n                    animationData.animationOver = false;\r\n                }\r\n\r\n                animationData.setLastFramePlayed(layerId, lastFramePlayed);\r\n                animationData.setAnimationPlayed(layerId, animationPlayed);\r\n            }\r\n\r\n            layerUpdate = (layerUpdate >> 1);\r\n\r\n            layerId--;\r\n        }\r\n\r\n        return update;\r\n    }\r\n\r\n    protected getFrameNumber(scale: number, layerId: number): number\r\n    {\r\n        const currentFrame = this._animationData.getFrame(layerId);\r\n\r\n        if(!currentFrame) return super.getFrameNumber(scale, layerId);\r\n\r\n        return currentFrame.id;\r\n    }\r\n\r\n    protected getLayerXOffset(scale: number, direction: number, layerId: number): number\r\n    {\r\n        const offset = super.getLayerXOffset(scale, direction, layerId);\r\n\r\n        const currentFrame = this._animationData.getFrame(layerId);\r\n\r\n        if(!currentFrame) return offset;\r\n\r\n        return (offset + currentFrame.x);\r\n    }\r\n\r\n    protected getLayerYOffset(scale: number, direction: number, layerId: number): number\r\n    {\r\n        const offset = super.getLayerYOffset(scale, direction, layerId);\r\n\r\n        const currentFrame = this._animationData.getFrame(layerId);\r\n\r\n        if(!currentFrame) return offset;\r\n\r\n        return (offset + currentFrame.y);\r\n    }\r\n\r\n    protected usesAnimationResetting(): boolean\r\n    {\r\n        return false;\r\n    }\r\n\r\n    protected setDirection(direction: number): void\r\n    {\r\n        if(this._direction === direction) return;\r\n\r\n        super.setDirection(direction);\r\n\r\n        this._directionChanged = true;\r\n    }\r\n\r\n    protected get frameIncrease(): number\r\n    {\r\n        return this._frameIncrease;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}